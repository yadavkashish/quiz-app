/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ 2157:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Fs: () => (/* binding */ IAB_PURPOSES),
/* harmony export */   KS: () => (/* binding */ PERFORMANCE),
/* harmony export */   Li: () => (/* binding */ EMPTY_CATEGORY_CONSENT),
/* harmony export */   Lp: () => (/* binding */ FUNCTIONAL),
/* harmony export */   a3: () => (/* binding */ NECESSARY),
/* harmony export */   bd: () => (/* binding */ categories),
/* harmony export */   p7: () => (/* binding */ UNCLASSIFIED),
/* harmony export */   qc: () => (/* binding */ EMPTY_CONSENT),
/* harmony export */   rO: () => (/* binding */ ADVERTISING)
/* harmony export */ });
/* unused harmony exports FULL_CATEGORY_CONSENT, NO_CONSENT */
/* harmony import */ var _primitives__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9083);
const NECESSARY="necessary";const PERFORMANCE="performance";const FUNCTIONAL="functional";const ADVERTISING="advertising";const UNCLASSIFIED="unclassified";const IAB_PURPOSES="iab_purposes";const categories=[NECESSARY,PERFORMANCE,FUNCTIONAL,ADVERTISING];// empty consent, for example when user clicks "deny" - which means he accept only necessay
const EMPTY_CONSENT=Object.freeze({});const FULL_CATEGORY_CONSENT=Object.freeze({[NECESSARY]:_primitives__WEBPACK_IMPORTED_MODULE_0__/* .TRUE */ .uX,[PERFORMANCE]:_primitives__WEBPACK_IMPORTED_MODULE_0__/* .TRUE */ .uX,[FUNCTIONAL]:_primitives__WEBPACK_IMPORTED_MODULE_0__/* .TRUE */ .uX,[ADVERTISING]:_primitives__WEBPACK_IMPORTED_MODULE_0__/* .TRUE */ .uX});const EMPTY_CATEGORY_CONSENT=Object.freeze({[NECESSARY]:_primitives__WEBPACK_IMPORTED_MODULE_0__/* .TRUE */ .uX,[PERFORMANCE]:_primitives__WEBPACK_IMPORTED_MODULE_0__/* .FALSE */ .Dv,[FUNCTIONAL]:_primitives__WEBPACK_IMPORTED_MODULE_0__/* .FALSE */ .Dv,[ADVERTISING]:_primitives__WEBPACK_IMPORTED_MODULE_0__/* .FALSE */ .Dv});// no consent - this is before user saves their preference
const NO_CONSENT=null;

/***/ }),

/***/ 3867:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   h5: () => (/* binding */ EU_COUNTRIES),
/* harmony export */   ie: () => (/* binding */ REGION_CHECK_COUNTRIES),
/* harmony export */   np: () => (/* binding */ DEFAULT_NON_EU_BANNER_COUNTRIES)
/* harmony export */ });
const EU_COUNTRIES=["AT",// Austria
"BE",// Belgium
"BG",// Bulgaria
"HR",// Croatia
"CY",// Cyprus
"CZ",// Czech Republic
"DK",// Denmark
"EE",// Estonia
"FI",// Finland
"FR",// France
"DE",// Germany
"GR",// Greece
"HU",// Hungary
"IE",// Ireland
"IT",// Italy
"LV",// Latvia
"LT",// Lithuania
"LU",// Luxembourg
"MT",// Malta
"NL",// the Netherlands
"PL",// Poland
"PT",// Portugal
"RO",// Romania
"SK",// Slovakia
"SI",// Slovenia
"ES",// Spain
"SE"// Sweden
];const DEFAULT_NON_EU_BANNER_COUNTRIES=["IS",// Iceland
"NO",// Norway
"CH",// Switzerland
"GB"// United Kingdom
];const REGION_CHECK_COUNTRIES=["US",// United States
"CA"// Canada
];

/***/ }),

/***/ 4327:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BK: () => (/* binding */ _HEAD_),
/* harmony export */   X6: () => (/* binding */ _WINDOW_),
/* harmony export */   uI: () => (/* binding */ _DOCUMENT_)
/* harmony export */ });
const _DOCUMENT_=document;const _WINDOW_=window;const _HEAD_=_DOCUMENT_.head;

/***/ }),

/***/ 6525:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ae: () => (/* binding */ MISSING_GVL),
/* harmony export */   Aw: () => (/* binding */ MISSING_API_KEY),
/* harmony export */   HV: () => (/* binding */ NEW_CONSENT_INVALID_TYPE),
/* harmony export */   Hf: () => (/* binding */ MISSING_IAB_LIB_LEGINT_NAME),
/* harmony export */   KL: () => (/* binding */ PROBABLY_MISSING_API_KEY),
/* harmony export */   L_: () => (/* binding */ WRONG_TCF_MULTI_CATEGORY_DATA),
/* harmony export */   Uz: () => (/* binding */ CANT_OPEN_PANEL_STEALTH_MODE),
/* harmony export */   XU: () => (/* binding */ BULK_SEND_FAILED),
/* harmony export */   ZG: () => (/* binding */ CONTEXT_OUTSIDE_PROVIDER),
/* harmony export */   aL: () => (/* binding */ MISSING_IAB_LIB_NAME),
/* harmony export */   fB: () => (/* binding */ WRONG_TCF_SINGLE_CATEGORY_DATA),
/* harmony export */   o9: () => (/* binding */ INVALID_SERVICE),
/* harmony export */   qx: () => (/* binding */ COOKIE_LOADING_FAILED),
/* harmony export */   rC: () => (/* binding */ MISSING_GATP),
/* harmony export */   t4: () => (/* binding */ INVALID_CATEGORY),
/* harmony export */   zc: () => (/* binding */ UNKNOWN_BANNER_TYPE)
/* harmony export */ });
/* harmony import */ var core_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2353);
/* harmony import */ var constants_categories__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2157);
const CATEGORIES=constants_categories__WEBPACK_IMPORTED_MODULE_0__/* .categories */ .bd.join(", ").toLowerCase();const MISSING_API_KEY=core_config__WEBPACK_IMPORTED_MODULE_1__/* .LOGS_PREFIX */ .f2+" Missing API key.";const PROBABLY_MISSING_API_KEY=core_config__WEBPACK_IMPORTED_MODULE_1__/* .LOGS_PREFIX */ .f2+" Failed to load configs, check API key";const CANT_OPEN_PANEL_STEALTH_MODE=core_config__WEBPACK_IMPORTED_MODULE_1__/* .LOGS_PREFIX */ .f2+" Can't toggle panel in stealth mode";const NEW_CONSENT_INVALID_TYPE=core_config__WEBPACK_IMPORTED_MODULE_1__/* .LOGS_PREFIX */ .f2+" new consent must be an object";const INVALID_CATEGORY=core_config__WEBPACK_IMPORTED_MODULE_1__/* .LOGS_PREFIX */ .f2+" Unrecognized category, not one of: "+CATEGORIES;const INVALID_SERVICE=core_config__WEBPACK_IMPORTED_MODULE_1__/* .LOGS_PREFIX */ .f2+" Unrecognized service key.";const UNKNOWN_BANNER_TYPE=core_config__WEBPACK_IMPORTED_MODULE_1__/* .LOGS_PREFIX */ .f2+" Unrecognized banner type.";const CONTEXT_OUTSIDE_PROVIDER=core_config__WEBPACK_IMPORTED_MODULE_1__/* .LOGS_PREFIX */ .f2+" useContext outside provider";const COOKIE_LOADING_FAILED=core_config__WEBPACK_IMPORTED_MODULE_1__/* .LOGS_PREFIX */ .f2+" Failed to load cookies";const BULK_SEND_FAILED=core_config__WEBPACK_IMPORTED_MODULE_1__/* .LOGS_PREFIX */ .f2+" Failed to send bulk consent message";// TCF
const MISSING_GVL=core_config__WEBPACK_IMPORTED_MODULE_1__/* .LOGS_PREFIX */ .f2+" Missing Global Vendor List. There is a chance it was still loading. You can check if it exist using: publicAPI > TCFgvl";const MISSING_GATP=core_config__WEBPACK_IMPORTED_MODULE_1__/* .LOGS_PREFIX */ .f2+" Missing Google Ad Technology Providers List (GATP). There is a chance it was still loading. You can check if it exist using: publicAPI > TCFgatp";const MISSING_IAB_LIB_NAME=`${core_config__WEBPACK_IMPORTED_MODULE_1__/* .LOGS_PREFIX */ .f2} TCF category with switch is missing IAB LIB name`;const MISSING_IAB_LIB_LEGINT_NAME=`${core_config__WEBPACK_IMPORTED_MODULE_1__/* .LOGS_PREFIX */ .f2} TCF category with switch is missing IAB LIB legitimate interest name`;const WRONG_TCF_MULTI_CATEGORY_DATA=`${core_config__WEBPACK_IMPORTED_MODULE_1__/* .LOGS_PREFIX */ .f2} Couldn't update categories. Wrong structure of passed data. To update multiple categories expected structure is this: [[categoryName, id], [categoryName, id]]`;const WRONG_TCF_SINGLE_CATEGORY_DATA=`${core_config__WEBPACK_IMPORTED_MODULE_1__/* .LOGS_PREFIX */ .f2} Couldn't update category. Wrong structure of passed data. To update single category expected structure is this: [categoryName, id]`;

/***/ }),

/***/ 5545:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   N: () => (/* binding */ NUMBER_0),
/* harmony export */   V: () => (/* binding */ NUMBER_1)
/* harmony export */ });
const NUMBER_0=0,NUMBER_1=1;

/***/ }),

/***/ 9083:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Dv: () => (/* binding */ FALSE),
/* harmony export */   QV: () => (/* binding */ NULL),
/* harmony export */   i_: () => (/* binding */ UNDEFINED),
/* harmony export */   qh: () => (/* binding */ UNDEFINED_STRING),
/* harmony export */   uX: () => (/* binding */ TRUE)
/* harmony export */ });
/* unused harmony export NAN */
const NULL=null;const TRUE=true;const FALSE=false;const UNDEFINED=undefined;const UNDEFINED_STRING="undefined";const NAN=(/* unused pure expression or super */ null && (NaN));

/***/ }),

/***/ 544:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   i: () => (/* binding */ DAY_IN_SECONDS),
/* harmony export */   z: () => (/* binding */ YEAR_IN_SECONDS)
/* harmony export */ });
const DAY_IN_SECONDS=24*60*60;const YEAR_IN_SECONDS=365*DAY_IN_SECONDS;

/***/ }),

/***/ 9424:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   G: () => (/* binding */ APP_STATE_CONTEXT)
/* harmony export */ });
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3987);
/* harmony import */ var constants_primitives__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9083);
const APP_STATE_CONTEXT=(0,preact__WEBPACK_IMPORTED_MODULE_0__/* .createContext */ .kr)(constants_primitives__WEBPACK_IMPORTED_MODULE_1__/* .UNDEFINED */ .i_);/* unused harmony default export */ var __WEBPACK_DEFAULT_EXPORT__ = ((/* unused pure expression or super */ null && (APP_STATE_CONTEXT)));

/***/ }),

/***/ 6996:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   p: () => (/* binding */ createCookieFirstPublicApiInstance)
/* harmony export */ });
/* harmony import */ var constants_categories__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2157);
/* harmony import */ var constants_primitives__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(9083);
/* harmony import */ var constants_errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6525);
/* harmony import */ var types_config_files_mainConfig__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7086);
/* harmony import */ var helpers_dispatchConsentLoadedEvent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3116);
/* harmony import */ var helpers_dispatchRenderEmbedsEvent__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(3825);
/* harmony import */ var helpers_consent_makeCategoryConsentObject__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(1394);
/* harmony import */ var helpers_consent_makeGranularConsentObject__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(3018);
/* harmony import */ var helpers_isArray__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(9264);
/* harmony import */ var helpers_isObject__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(7067);
/* harmony import */ var helpers_includes__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(8217);
const createCookieFirstPublicApiInstance=deps=>{// prepare dependencies and helpers
const _dep=deps;const consentCtx=_dep.consent;const widgetConfig=deps.widgetConfig;const stealthMode=!!deps.stealthMode;const hasConsented=!!consentCtx.hasConsented;let consent=constants_primitives__WEBPACK_IMPORTED_MODULE_7__/* .NULL */ .QV;let acceptedServices={};if(hasConsented){const userConsent=consentCtx.userConsent;// calculate which categories are accepted
const categoryConsent=(0,helpers_consent_makeCategoryConsentObject__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(userConsent,widgetConfig);// calculate which services are accepted
const granularConsent=(0,helpers_consent_makeGranularConsentObject__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(userConsent,widgetConfig);consent=categoryConsent;acceptedServices=granularConsent;}const consentTimestamp=consentCtx.consentTimestamp;const visitorId=consentCtx.visitorId;const parseCategoryArg=function(){let category=arguments.length>0&&arguments[0]!==undefined?arguments[0]:"";const cats=(0,helpers_isArray__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(category)?category:[category];if(!cats.every(c=>(0,helpers_includes__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)(constants_categories__WEBPACK_IMPORTED_MODULE_0__/* .categories */ .bd,c))){throw new Error(constants_errors__WEBPACK_IMPORTED_MODULE_1__/* .INVALID_CATEGORY */ .t4);}return cats;};const parseServiceArg=function(){let service=arguments.length>0&&arguments[0]!==undefined?arguments[0]:"";const allServices=widgetConfig.scripts.map(s=>s.consent_key);const requestedServices=(0,helpers_isArray__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(service)?service:[service];if(!requestedServices.every(s=>(0,helpers_includes__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)(allServices,s))){throw new Error(constants_errors__WEBPACK_IMPORTED_MODULE_1__/* .INVALID_SERVICE */ .o9);}return requestedServices;};const deny=()=>consentCtx.deny();const declineAllCategories=()=>{return deny();};/**
   * Declare the final object
   */const publicApi={stealthMode,hasConsented,consent,acceptedServices,consentTimestamp,visitorId,openPanel(){let tab=arguments.length>0&&arguments[0]!==undefined?arguments[0]:types_config_files_mainConfig__WEBPACK_IMPORTED_MODULE_2__/* .PANEL_SETTINGS_TAB */ .bl;_dep.setPanelTab(tab);},closePanel(){_dep.setPanelTab(constants_primitives__WEBPACK_IMPORTED_MODULE_7__/* .NULL */ .QV);},updateConsent(){let consent=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};if(!(0,helpers_isObject__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z)(consent)){throw new Error(constants_errors__WEBPACK_IMPORTED_MODULE_1__/* .NEW_CONSENT_INVALID_TYPE */ .HV);}return consentCtx.handleConsent(consent);},acceptCategory(category){const cats=parseCategoryArg(category);// create consent object with only the accepted scripts
return consentCtx.acceptCategories(cats);},declineCategory(category){const cats=parseCategoryArg(category);// if first consent, decline all categories.
if(!consent){return declineAllCategories();}// create consent object without scripts containing the rejected category
return consentCtx.declineCategories(cats);},acceptService(service){const services=parseServiceArg(service);// create consent object with only the accepted scripts
return consentCtx.acceptServices(services);},declineService(service){const services=parseServiceArg(service);// if first consent, decline all
if(!consent){return declineAllCategories();}// create consent object without rejected scripts
return consentCtx.declineServices(services);},acceptAllCategories:consentCtx.acceptAll,acceptPreselectedCategories:consentCtx.acceptDefault,deny:deny,declineAllCategories:declineAllCategories,withdrawConsent:consentCtx.handleWithdraw,fetchLatestScan:_dep.fetchLatestScan,renderEmbeds(){(0,helpers_dispatchRenderEmbedsEvent__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)();},// a way for SPAs to notify us about view change
notifyViewChanged(){(0,helpers_dispatchConsentLoadedEvent__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .ZP)(consent||constants_categories__WEBPACK_IMPORTED_MODULE_0__/* .EMPTY_CONSENT */ .qc,hasConsented,widgetConfig);(0,helpers_dispatchRenderEmbedsEvent__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)();},changeLanguage:_dep.setUserLang};return publicApi;};

/***/ }),

/***/ 3672:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ TRANSLATIONS_CONTEXT),
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var constants_primitives__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9083);
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3987);
const TRANSLATIONS_CONTEXT=(0,preact__WEBPACK_IMPORTED_MODULE_0__/* .createContext */ .kr)(constants_primitives__WEBPACK_IMPORTED_MODULE_1__/* .NULL */ .QV);/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TRANSLATIONS_CONTEXT);

/***/ }),

/***/ 9475:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $: () => (/* binding */ USER_CONSENT_CONTEXT),
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3987);
const USER_CONSENT_CONTEXT=(0,preact__WEBPACK_IMPORTED_MODULE_0__/* .createContext */ .kr)(undefined);/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (USER_CONSENT_CONTEXT);

/***/ }),

/***/ 2353:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AV: () => (/* binding */ EDGE_API_URL),
/* harmony export */   BX: () => (/* binding */ BUTTON_ATTR),
/* harmony export */   Bs: () => (/* binding */ EMBED_ELEMENTS_PREFIX),
/* harmony export */   Ep: () => (/* binding */ LANGUAGE_COOKIE),
/* harmony export */   HB: () => (/* binding */ REGION_CHECK_URL),
/* harmony export */   Ji: () => (/* binding */ APP_VERSION),
/* harmony export */   MZ: () => (/* binding */ VISITOR_ID_COOKIE),
/* harmony export */   OH: () => (/* binding */ EVENTS_PREFIX),
/* harmony export */   Q8: () => (/* binding */ CONSENT_COOKIE),
/* harmony export */   QO: () => (/* binding */ CATEGORY_ATTR),
/* harmony export */   T5: () => (/* binding */ API_URL),
/* harmony export */   W$: () => (/* binding */ JS_API_OBJECT_NAME),
/* harmony export */   Ys: () => (/* binding */ ACTION_ATTR),
/* harmony export */   eR: () => (/* binding */ ACCENT_COLOR_ATTR),
/* harmony export */   ee: () => (/* binding */ BG_COLOR_ATTR),
/* harmony export */   f2: () => (/* binding */ LOGS_PREFIX),
/* harmony export */   fx: () => (/* binding */ WITHDRAW_COOKIE),
/* harmony export */   iT: () => (/* binding */ OUTLINE_ACCENT_COLOR_ATTR),
/* harmony export */   o$: () => (/* binding */ GENERIC_PREFIX),
/* harmony export */   sT: () => (/* binding */ TCSTRING_COOKIE),
/* harmony export */   ud: () => (/* binding */ STATIC_URL),
/* harmony export */   wf: () => (/* binding */ CORNER_STYLE_ATTR),
/* harmony export */   xC: () => (/* binding */ DATA_ATTRIBUTES_PREFIX),
/* harmony export */   xl: () => (/* binding */ WIDGET_ATTR)
/* harmony export */ });
/* unused harmony exports PUBLIC_URL, DEFAULT_BULK_IFRAME, ACCENT_BG_COLOR_ATTR */
const API_URL="https://api.cookiefirst.com/prod";const EDGE_API_URL="https://edge.cookiefirst.com/prod"||0;const STATIC_URL="https://consent-eu.cookiefirst.com"||0;const PUBLIC_URL=(/* unused pure expression or super */ null && ("https://consent-eu.cookiefirst.com/banner/v2.15.3"||0));const DEFAULT_BULK_IFRAME=(/* unused pure expression or super */ null && ("https://consent.cookiefirst.com/bulk/handler.html"));const REGION_CHECK_URL=`${EDGE_API_URL}/location`;const DATA_ATTRIBUTES_PREFIX="data-cookiefirst";const EMBED_ELEMENTS_PREFIX="cookiefirst";const GENERIC_PREFIX= false?0:"cf";// WHITELABEL ATTRIBUTES
const ACCENT_COLOR_ATTR=`${DATA_ATTRIBUTES_PREFIX}-accent-color`;const ACCENT_BG_COLOR_ATTR=(/* unused pure expression or super */ null && (`${DATA_ATTRIBUTES_PREFIX}-accent-bg-color`));const CORNER_STYLE_ATTR=`${DATA_ATTRIBUTES_PREFIX}-corner-style`;const OUTLINE_ACCENT_COLOR_ATTR=`${DATA_ATTRIBUTES_PREFIX}-outline-accent-color`;const BG_COLOR_ATTR=`${DATA_ATTRIBUTES_PREFIX}-bg-color`;const WIDGET_ATTR=`${DATA_ATTRIBUTES_PREFIX}-widget`;const BUTTON_ATTR=`${DATA_ATTRIBUTES_PREFIX}-button`;const ACTION_ATTR=`${DATA_ATTRIBUTES_PREFIX}-action`;const CATEGORY_ATTR=`${DATA_ATTRIBUTES_PREFIX}-category`;const CONSENT_COOKIE= false?0:"cookiefirst-consent";const VISITOR_ID_COOKIE= false?0:"cookiefirst-id";const LANGUAGE_COOKIE= false?0:"cf-user-lang";const TCSTRING_COOKIE= false?0:"cf-user-tcstring";const JS_API_OBJECT_NAME= false?0:"CookieFirst";const APP_VERSION="2.15.3";const LOGS_PREFIX= false?0:"[CF]";const EVENTS_PREFIX= false?0:"cf";const WITHDRAW_COOKIE="WITHDRAW";

/***/ }),

/***/ 7108:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* unused harmony export IntegrationSettings */
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2353);
/* harmony import */ var constants_primitives__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9083);
class IntegrationSettings{constructor(){this.apiKey="";this.dir=constants_primitives__WEBPACK_IMPORTED_MODULE_0__/* .NULL */ .QV;this.wildcardDir=constants_primitives__WEBPACK_IMPORTED_MODULE_0__/* .NULL */ .QV;this.dataLayer="dataLayer";this.stealthMode=constants_primitives__WEBPACK_IMPORTED_MODULE_0__/* .FALSE */ .Dv;this.forcedLang=constants_primitives__WEBPACK_IMPORTED_MODULE_0__/* .NULL */ .QV;this.silentMode=constants_primitives__WEBPACK_IMPORTED_MODULE_0__/* .TRUE */ .uX;this.debugMode=constants_primitives__WEBPACK_IMPORTED_MODULE_0__/* .FALSE */ .Dv;this.staticFilesUrl=_config__WEBPACK_IMPORTED_MODULE_1__/* .STATIC_URL */ .ud||"";}set(key,value){const self=this;self[key]=value;}}const integrationSettings=new IntegrationSettings();/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (integrationSettings);

/***/ }),

/***/ 8042:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Z: () => (/* binding */ api_fetch)
});

// EXTERNAL MODULE: ./src/core/config.ts
var core_config = __webpack_require__(2353);
// EXTERNAL MODULE: ./src/helpers/objectKeys.ts
var objectKeys = __webpack_require__(1733);
;// CONCATENATED MODULE: ./src/helpers/api/ApiError.ts
class ApiError extends Error{constructor(msg,body){super(msg);this.body=void 0;this.body=body;}}/* harmony default export */ const api_ApiError = (ApiError);
// EXTERNAL MODULE: ./src/helpers/createPromise.ts
var createPromise = __webpack_require__(2662);
;// CONCATENATED MODULE: ./src/helpers/api/fetch.ts
function fetchWrapper(url){let config=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};return (0,createPromise/* default */.Z)((resolve,reject)=>{const abort=function(msg){let body=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};reject(new api_ApiError(`${core_config/* LOGS_PREFIX */.f2} Request to ${url} failed: ${msg}`,body));};fetch(url,config).then(res=>{if(!res.ok){if(res.status){if(res.status===422){res.json().then(body=>{abort(res.status,body);}).catch(err=>abort(res.status));return;}abort(res.status);return;}abort("");return;}const headers={};const keys=(0,objectKeys/* default */.Z)(res.headers||{});for(let i=keys.length-1;i>=0;i--){const key=keys[i];const newKey=key.toLowerCase();headers[newKey]=res.headers[key];}resolve([res,headers]);},e=>abort(e.message));});}/* harmony default export */ const api_fetch = (fetchWrapper);

/***/ }),

/***/ 8576:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _fetch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8042);
/* harmony import */ var helpers_createPromise__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2662);
function getJson(url){let config=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};return (0,helpers_createPromise__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)((resolve,reject)=>{(0,_fetch__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(url,{...config,headers:{...(config.headers||{}),Accept:'application/json'}}).then(_ref=>{let[res,headers]=_ref;res.json().then(body=>resolve([body,headers]),reject);},reject);});}/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getJson);

/***/ }),

/***/ 437:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var core_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2353);
/* harmony import */ var helpers_deleteLocalStorageItem__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(63);
/* harmony import */ var helpers_deleteLocalCookie__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5426);
/* harmony import */ var constants_primitives__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9083);
const deleteLocalConsent=function(){let bulkConfig=arguments.length>0&&arguments[0]!==undefined?arguments[0]:constants_primitives__WEBPACK_IMPORTED_MODULE_1__/* .NULL */ .QV;(0,helpers_deleteLocalCookie__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(core_config__WEBPACK_IMPORTED_MODULE_2__/* .CONSENT_COOKIE */ .Q8,bulkConfig);(0,helpers_deleteLocalStorageItem__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(core_config__WEBPACK_IMPORTED_MODULE_2__/* .CONSENT_COOKIE */ .Q8);};/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (deleteLocalConsent);

/***/ }),

/***/ 5144:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var constants_primitives__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9083);
/* harmony import */ var constants_time__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(544);
/* harmony import */ var helpers_getTimestamp__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6007);
const hasConsentExpired=function(consentTimestamp){let consentLifetime=arguments.length>1&&arguments[1]!==undefined?arguments[1]:constants_time__WEBPACK_IMPORTED_MODULE_0__/* .YEAR_IN_SECONDS */ .z;// don't expire consents saved before we introduced timestamp saving in the consent object
if(typeof consentTimestamp!=="number"){return constants_primitives__WEBPACK_IMPORTED_MODULE_1__/* .FALSE */ .Dv;}const now=(0,helpers_getTimestamp__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)();// check if consent timestamp is older than configured
return now-consentTimestamp>=consentLifetime;};/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (hasConsentExpired);

/***/ }),

/***/ 2520:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var types_consent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5304);
/* harmony import */ var constants_primitives__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9083);
/* harmony import */ var constants_categories__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2157);
/* harmony import */ var _isServiceAccepted__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5820);
/* harmony import */ var helpers_includes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(8217);
const isCategoryAccepted=(category,consent,consentPolicy,scripts)=>{if(category===constants_categories__WEBPACK_IMPORTED_MODULE_0__/* .NECESSARY */ .a3){return constants_primitives__WEBPACK_IMPORTED_MODULE_2__/* .TRUE */ .uX;}if(consentPolicy===types_consent__WEBPACK_IMPORTED_MODULE_3__/* .CONSENT_POLICY_GRANULAR_OPTIN */ .Gc&&scripts){const categoryScripts=scripts.filter(i=>{return (0,helpers_includes__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(i.categories,category);});// in granular consent, category can't be ever accepted
// if there are no services connected to it
if(!categoryScripts.length){return constants_primitives__WEBPACK_IMPORTED_MODULE_2__/* .FALSE */ .Dv;}const acceptedScripts=categoryScripts.filter(script=>{return (0,_isServiceAccepted__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(script,consent,consentPolicy);});return acceptedScripts.length===categoryScripts.length;}else if(consentPolicy===types_consent__WEBPACK_IMPORTED_MODULE_3__/* .CONSENT_POLICY_CATEGORY_OPTIN */ .hs){return!!consent[category];}return constants_primitives__WEBPACK_IMPORTED_MODULE_2__/* .FALSE */ .Dv;};/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isCategoryAccepted);

/***/ }),

/***/ 5820:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var types_consent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5304);
/* harmony import */ var constants_categories__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2157);
/* harmony import */ var constants_primitives__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9083);
/* harmony import */ var helpers_includes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8217);
const isServiceAccepted=(service,consent,consentPolicy)=>{const{consent_key,categories}=service;if((0,helpers_includes__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(categories,constants_categories__WEBPACK_IMPORTED_MODULE_0__/* .NECESSARY */ .a3)){return constants_primitives__WEBPACK_IMPORTED_MODULE_2__/* .TRUE */ .uX;}if(consentPolicy===types_consent__WEBPACK_IMPORTED_MODULE_3__/* .CONSENT_POLICY_GRANULAR_OPTIN */ .Gc){return!!consent[consent_key];}else{return categories.every(cat=>!!consent[cat]);}};/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isServiceAccepted);

/***/ }),

/***/ 9094:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var types_consent__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(5304);
/* harmony import */ var core_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2353);
/* harmony import */ var constants_primitives__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(9083);
/* harmony import */ var helpers_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6639);
/* harmony import */ var helpers_getCookie__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9368);
/* harmony import */ var helpers_getLocalStorageItem__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(8915);
/* harmony import */ var helpers_objectKeys__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(1733);
/* harmony import */ var helpers_report__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(7432);
/* harmony import */ var helpers_includes__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(8217);
/* harmony import */ var helpers_deleteLocalStorageItem__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(63);
const loadLocalConsentCookie=()=>{const cookie=(0,helpers_getCookie__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(core_config__WEBPACK_IMPORTED_MODULE_2__/* .CONSENT_COOKIE */ .Q8);// cookie doesn't exist, no consent
if(!cookie){return constants_primitives__WEBPACK_IMPORTED_MODULE_3__/* .NULL */ .QV;}// Check if cookie is equal to "withdraw" value
if(cookie===core_config__WEBPACK_IMPORTED_MODULE_2__/* .WITHDRAW_COOKIE */ .fx){return{value:cookie};}try{const decoded=JSON.parse(decodeURIComponent(cookie));return decoded;}catch(e){(0,helpers_logger__WEBPACK_IMPORTED_MODULE_0__/* .consentLogger */ .OM)("Failed to decode local consent cookie:");(0,helpers_report__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(e);// not valid JSON value in cookie
return constants_primitives__WEBPACK_IMPORTED_MODULE_3__/* .NULL */ .QV;}};const formatStoredValue=storedValue=>{const consent=(0,helpers_objectKeys__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(storedValue).reduce((consentObj,key)=>{// don't pass a few keys to the final consent object
if((0,helpers_includes__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(["version","timestamp","type"],key)){return consentObj;}return{...consentObj,[key]:!!storedValue[key]};},{});let type=types_consent__WEBPACK_IMPORTED_MODULE_7__/* .CONSENT_TYPE_CATEGORY */ .LV;if((0,helpers_includes__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)([types_consent__WEBPACK_IMPORTED_MODULE_7__/* .CONSENT_TYPE_CATEGORY */ .LV,types_consent__WEBPACK_IMPORTED_MODULE_7__/* .CONSENT_TYPE_GRANULAR */ .an],storedValue.type||"")){type=storedValue.type;}return[{...consent,version:storedValue.version},parseInt(storedValue.timestamp||"0"),// use numeric timestamp here,
type];};const loadLocalConsent=()=>{// try to load consent from cookie
const cookie=loadLocalConsentCookie();if(cookie){// Check if value of cookie is 'withdraw'
if(cookie.value===core_config__WEBPACK_IMPORTED_MODULE_2__/* .WITHDRAW_COOKIE */ .fx){// If so, doesn't return any consent and clear local storage consent.
(0,helpers_deleteLocalStorageItem__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(core_config__WEBPACK_IMPORTED_MODULE_2__/* .CONSENT_COOKIE */ .Q8);return constants_primitives__WEBPACK_IMPORTED_MODULE_3__/* .NULL */ .QV;}return formatStoredValue(cookie);}// fall back to localstorage if cookie is not available
const localStorageItem=(0,helpers_getLocalStorageItem__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)(core_config__WEBPACK_IMPORTED_MODULE_2__/* .CONSENT_COOKIE */ .Q8,constants_primitives__WEBPACK_IMPORTED_MODULE_3__/* .NULL */ .QV);if(localStorageItem){return formatStoredValue(localStorageItem);}// no consent
return constants_primitives__WEBPACK_IMPORTED_MODULE_3__/* .NULL */ .QV;};/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (loadLocalConsent);

/***/ }),

/***/ 1394:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var constants_categories__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2157);
/* harmony import */ var _isCategoryAccepted__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2520);
const makeCategoryConsentObject=(consent,widgetConfig)=>{const categoryConsent=constants_categories__WEBPACK_IMPORTED_MODULE_0__/* .categories */ .bd.reduce((aggregate,cat)=>{aggregate[cat]=(0,_isCategoryAccepted__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(cat,consent,widgetConfig.consentPolicy,widgetConfig.scripts);return aggregate;},// make sure to clone the default value
// to ensure it's not overwriting the imported object
// https://gitlab.com/cookiefirst/cookiefirst/-/issues/363
{...constants_categories__WEBPACK_IMPORTED_MODULE_0__/* .EMPTY_CATEGORY_CONSENT */ .Li});return categoryConsent;};/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (makeCategoryConsentObject);

/***/ }),

/***/ 3018:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var constants_categories__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2157);
/* harmony import */ var _isServiceAccepted__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5820);
const makeGranularConsentObject=(consent,widgetConfig)=>{const granularConsent=widgetConfig.scripts.reduce((aggregate,script)=>{return{...aggregate,[script.consent_key]:(0,_isServiceAccepted__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(script,consent,widgetConfig.consentPolicy)};},{...constants_categories__WEBPACK_IMPORTED_MODULE_0__/* .EMPTY_CONSENT */ .qc});return granularConsent;};/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (makeGranularConsentObject);

/***/ }),

/***/ 4348:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var constants_primitives__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9083);
const shouldResetConsent=(timestamp,lastConsentReset)=>{if(!lastConsentReset||typeof lastConsentReset!=="number"){return constants_primitives__WEBPACK_IMPORTED_MODULE_0__/* .FALSE */ .Dv;}const ts=parseInt(timestamp);if(timestamp&&!isNaN(ts)&&ts>=lastConsentReset){return constants_primitives__WEBPACK_IMPORTED_MODULE_0__/* .FALSE */ .Dv;}return constants_primitives__WEBPACK_IMPORTED_MODULE_0__/* .TRUE */ .uX;};/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (shouldResetConsent);

/***/ }),

/***/ 1250:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var constants_primitives__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9083);
/* harmony import */ var constants_countries__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3867);
/* harmony import */ var helpers_isScannerApp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5006);
/* harmony import */ var helpers_includes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8217);
const shouldUseFullConsent=function(widgetConfig){let visitorCountry=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;let visitorRegion=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;// when scanner app visits, act as if user already consented to all categories
if((0,helpers_isScannerApp__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)()){return constants_primitives__WEBPACK_IMPORTED_MODULE_1__/* .TRUE */ .uX;}const{bannerNonEuCountries,bannerNonEuRegions,hideOutsideEU}=widgetConfig;// when not in EU and settings allow it, act as if user already consented to all categories
if(hideOutsideEU&&!!visitorCountry){let countriesToCheck=[...constants_countries__WEBPACK_IMPORTED_MODULE_2__/* .EU_COUNTRIES */ .h5,...bannerNonEuCountries];if(!!visitorRegion){countriesToCheck=[...countriesToCheck,...constants_countries__WEBPACK_IMPORTED_MODULE_2__/* .REGION_CHECK_COUNTRIES */ .ie];}if(!(0,helpers_includes__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(countriesToCheck,visitorCountry)){return constants_primitives__WEBPACK_IMPORTED_MODULE_1__/* .TRUE */ .uX;}if(!!visitorCountry&&!!visitorRegion&&(0,helpers_includes__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(constants_countries__WEBPACK_IMPORTED_MODULE_2__/* .REGION_CHECK_COUNTRIES */ .ie,visitorCountry)&&!(0,helpers_includes__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(bannerNonEuRegions,`${visitorCountry}-${visitorRegion}`)){return constants_primitives__WEBPACK_IMPORTED_MODULE_1__/* .TRUE */ .uX;}}return constants_primitives__WEBPACK_IMPORTED_MODULE_1__/* .FALSE */ .Dv;};/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (shouldUseFullConsent);

/***/ }),

/***/ 9356:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  getAutoblockInstance: () => (/* binding */ getAutoblockInstance)
});

;// CONCATENATED MODULE: ./src/helpers/content-execution/autoblock/constants.ts
const BLOCKED_TYPE_ATTRIBUTE="javascript/blocked";const SCRIPT_TYPE_ATTRIBUTE="application/javascript";
// EXTERNAL MODULE: ./src/constants/primitives.ts
var primitives = __webpack_require__(9083);
// EXTERNAL MODULE: ./src/constants/dom.ts
var dom = __webpack_require__(4327);
// EXTERNAL MODULE: ./src/core/config.ts
var config = __webpack_require__(2353);
// EXTERNAL MODULE: ./src/helpers/dom/addEventListener.ts
var addEventListener = __webpack_require__(6048);
// EXTERNAL MODULE: ./src/helpers/logger.ts
var logger = __webpack_require__(6639);
// EXTERNAL MODULE: ./src/helpers/dom/removeEventListener.ts
var removeEventListener = __webpack_require__(6828);
// EXTERNAL MODULE: ./src/helpers/isString.ts
var isString = __webpack_require__(8060);
// EXTERNAL MODULE: ./src/helpers/includes.ts
var includes = __webpack_require__(8217);
// EXTERNAL MODULE: ./src/helpers/dom/createElement.ts
var createElement = __webpack_require__(5992);
// EXTERNAL MODULE: ./src/helpers/stopEvent.ts
var stopEvent = __webpack_require__(5173);
;// CONCATENATED MODULE: ./src/helpers/content-execution/autoblock/Autoblock.ts
// https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType
const NODE_TYPE_ELEMENT=1;const BEFORE_SCRIPT_EXECUTE_EVENT='beforescriptexecute';const originalCreateElement=document.createElement.bind(document);const getScriptPropertyDescriptor=type=>{return Object.getOwnPropertyDescriptor(HTMLScriptElement.prototype,type);};const oSrcDescriptor=getScriptPropertyDescriptor("src");const oTypeDescriptor=getScriptPropertyDescriptor("type");// Use this link to check for updates:
// https://github.com/elbywan/yett/compare/2f714fae7f7267d1412c8e6c6ebcbc41bba1db9e...master
// after applying updates, replace commit SHA in the link above with the latest commit
let __instance=primitives/* NULL */.QV;const getAutoblockInstance=function(){let scriptUrlsOrRegexes=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];if(__instance){return __instance;}const backupScripts=[];let blacklist=[];let observer=null;scriptUrlsOrRegexes.forEach(scriptUrlsOrRegex=>{if((0,isString/* default */.Z)(scriptUrlsOrRegex)){blacklist.push(new RegExp(scriptUrlsOrRegex));}else{blacklist.push(scriptUrlsOrRegex);}});const observeMutations=()=>{observer=new MutationObserver(mutations=>{for(const mutation of mutations){for(const node of mutation.addedNodes){// For each added script tag
if(node.nodeType!==NODE_TYPE_ELEMENT||node.tagName!=="SCRIPT"||!(node instanceof HTMLScriptElement)){continue;}(0,logger/* autoblockLogger */.f1)("observer check");const src=node.src;const type=node.type;// If the src is inside the blacklist
if(isBlocked(src,type)){// We backup the node
backupScripts.push([node,node.type]);// Blocks inline script execution in Safari & Chrome
node.type=BLOCKED_TYPE_ATTRIBUTE;// Firefox has this additional event which prevents scripts from beeing executed
const beforeScriptExecuteListener=function(event){// Prevent only marked scripts from executing
if(node.getAttribute("type")===BLOCKED_TYPE_ATTRIBUTE){(0,logger/* autoblockLogger */.f1)("prevent execution");(0,stopEvent/* default */.Z)(event,primitives/* TRUE */.uX);}(0,removeEventListener/* default */.Z)(node,BEFORE_SCRIPT_EXECUTE_EVENT,beforeScriptExecuteListener);};(0,addEventListener/* default */.Z)(node,BEFORE_SCRIPT_EXECUTE_EVENT,beforeScriptExecuteListener);// Remove the node from the DOM
if(node.parentElement){(0,logger/* autoblockLogger */.f1)("remove node");node.parentElement.removeChild(node);}}}}});observer.observe(document.documentElement,{childList:primitives/* TRUE */.uX,subtree:primitives/* TRUE */.uX});};const unblock=scriptUrlsOrRegexes=>{(0,logger/* autoblockLogger */.f1)("unblock",scriptUrlsOrRegexes);// remove unblockable scripts from blacklist
if(blacklist.length){blacklist=blacklist.filter(pattern=>{return scriptUrlsOrRegexes.every(urlOrRegexp=>{if((0,isString/* default */.Z)(urlOrRegexp)){return!pattern.test(urlOrRegexp);}else if(urlOrRegexp instanceof RegExp){return pattern.toString()!==urlOrRegexp.toString();}return primitives/* FALSE */.Dv;});});}// Parse existing script tags with a blocked type
const tags=document.querySelectorAll(`script[type="${BLOCKED_TYPE_ATTRIBUTE}"]`);for(const script of tags){if(notOnBlacklist(script)){backupScripts.push([script,SCRIPT_TYPE_ATTRIBUTE]);if(script.parentElement){script.parentElement.removeChild(script);}}}// Exclude 'whitelisted' scripts from the blacklist and append them to <head>
let indexOffset=0;[...backupScripts].forEach((_ref,index)=>{let[script,type]=_ref;if(notOnBlacklist(script)){const scriptNode=(0,createElement/* default */.Z)("script");for(let i=0;i<script.attributes.length;i++){let attribute=script.attributes[i];if(!(0,includes/* default */.Z)(["src","type"],attribute.name)){scriptNode.setAttribute(attribute.name,script.attributes[i].value);}}scriptNode.setAttribute("src",script.src);scriptNode.setAttribute("type",type||SCRIPT_TYPE_ATTRIBUTE);dom/* _HEAD_ */.BK.appendChild(scriptNode);backupScripts.splice(index-indexOffset,1);indexOffset++;}});// Disconnect the observer if the blacklist is empty for performance reasons
if(!blacklist.length&&observer){(0,logger/* autoblockLogger */.f1)("unobserve");observer.disconnect();}};const isBlocked=(src,type)=>{// script is blocked if:
const isBlocked=// has src
!!src&&(// doesn't have type attribute or type attribute is not javascript/blocked
!type||type!==BLOCKED_TYPE_ATTRIBUTE)&&// is on the blacklist
blacklist.some(pattern=>pattern.test(src));(0,logger/* autoblockLogger */.f1)("isBlocked",isBlocked,{src,type});return isBlocked;};const notOnBlacklist=script=>{const src=script.src;const isNotOnBlacklist=!!src&&blacklist.every(entry=>!entry.test(src));(0,logger/* autoblockLogger */.f1)("notOnBlacklist",isNotOnBlacklist,{src});return isNotOnBlacklist;};const monkeyPatch=()=>{// Monkey patch the createElement method to prevent dynamic scripts from executing
document.createElement=function(){for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}// If this is not a script tag, bypass
if(!(0,isString/* default */.Z)(args[0])||args[0].toLowerCase()!=="script"){return originalCreateElement(...args);}// at this point it's safe to assume scriptElt is a script tag;
const scriptElt=originalCreateElement(...args);// Define getters / setters to ensure that the script type is properly set
try{Object.defineProperties(scriptElt,{src:{...oSrcDescriptor,set(value){(0,logger/* autoblockLogger */.f1)("monkey set src",value);if(isBlocked(value,scriptElt.type)){if(oTypeDescriptor.set){oTypeDescriptor.set.call(this,BLOCKED_TYPE_ATTRIBUTE);}}if(oSrcDescriptor.set){oSrcDescriptor.set.call(this,value);}}},type:{...oTypeDescriptor,get(){let typeValue=null;if(oTypeDescriptor.get){typeValue=oTypeDescriptor.get.call(this);}if(typeValue===BLOCKED_TYPE_ATTRIBUTE||isBlocked(this.src,typeValue)){// Prevent script execution.
return primitives/* NULL */.QV;}return typeValue;},set(value){(0,logger/* autoblockLogger */.f1)("monkey set type",value);const typeValue=isBlocked(scriptElt.src,scriptElt.type)?BLOCKED_TYPE_ATTRIBUTE:value;if(oTypeDescriptor.set){oTypeDescriptor.set.call(this,typeValue);}}}});// Monkey patch the setAttribute function so that the setter is called instead
scriptElt.setAttribute=function(name,value){if(name==="type"||name==="src"){scriptElt[name]=value;}else{HTMLScriptElement.prototype.setAttribute.call(scriptElt,name,value);}};}catch(error){console.warn(config/* LOGS_PREFIX */.f2,"can't prevent execution of script ",scriptElt.src||"[empty]",".\n",'Probably someone else monkey patches document.createElement');}return scriptElt;};};__instance={init:()=>{(0,logger/* autoblockLogger */.f1)("init");// initialize document.createElement monkey-patching
monkeyPatch();// Start the mutation observing
observeMutations();},unblock};return __instance;};

/***/ }),

/***/ 5982:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getAutoblockInstance: () => (/* reexport safe */ _Autoblock__WEBPACK_IMPORTED_MODULE_0__.getAutoblockInstance)
/* harmony export */ });
/* harmony import */ var _Autoblock__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9356);


/***/ }),

/***/ 7299:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var helpers_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6639);
/* harmony import */ var _autoblock__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5982);
const executeAutoblockedScript=script=>{const autoblock=(0,_autoblock__WEBPACK_IMPORTED_MODULE_1__.getAutoblockInstance)();const scriptAutoblockSettings=script.autoblock;if(!scriptAutoblockSettings){return;}(0,helpers_logger__WEBPACK_IMPORTED_MODULE_0__/* .autoblockLogger */ .f1)("execute",script);autoblock.unblock(scriptAutoblockSettings.urls);};/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (executeAutoblockedScript);

/***/ }),

/***/ 2662:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const createPromise=executor=>{return new Promise(executor);};/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createPromise);

/***/ }),

/***/ 5426:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var constants_numbers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5545);
/* harmony import */ var _saveLocalCookie__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7234);
const deleteLocalCookie=(cookieName,bulkConfig)=>{return (0,_saveLocalCookie__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(cookieName,"",constants_numbers__WEBPACK_IMPORTED_MODULE_1__/* .NUMBER_0 */ .N,bulkConfig);};/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (deleteLocalCookie);

/***/ }),

/***/ 63:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getLocalStorage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6225);
const deleteLocalStorageItem=key=>{const storage=(0,_getLocalStorage__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)();if(!key||!storage){return;}storage.removeItem(key);};/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (deleteLocalStorageItem);

/***/ }),

/***/ 3392:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* unused harmony export EVENT_NAME */
/* harmony import */ var core_config__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(2353);
/* harmony import */ var constants_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4327);
/* harmony import */ var helpers_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6639);
/* harmony import */ var _dispatchJSEvent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7179);
/* harmony import */ var core_integrationSettings__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7108);
/* harmony import */ var _isArray__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(9264);
const EVENT_NAME=`${core_config__WEBPACK_IMPORTED_MODULE_4__/* .EVENTS_PREFIX */ .OH}_init`;const dispatchAppInitializedEvent=()=>{(0,helpers_logger__WEBPACK_IMPORTED_MODULE_1__/* .coreLogger */ .cl)("Init");// dispach custom JS event
(0,_dispatchJSEvent__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(EVENT_NAME);// dispatch event to TagManager
const{dataLayer}=core_integrationSettings__WEBPACK_IMPORTED_MODULE_3__["default"];const dl=constants_dom__WEBPACK_IMPORTED_MODULE_0__/* ._WINDOW_ */ .X6[dataLayer];if((0,_isArray__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(dl)){dl.push({event:EVENT_NAME});}};/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dispatchAppInitializedEvent);

/***/ }),

/***/ 5383:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   W1: () => (/* binding */ EVENT_NAME),
/* harmony export */   ZP: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* unused harmony export SERVICES_EVENT_NAME */
/* harmony import */ var core_config__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(2353);
/* harmony import */ var constants_primitives__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(9083);
/* harmony import */ var _dispatchGTMConsentEvents__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4853);
/* harmony import */ var _dispatchJSEvent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7179);
/* harmony import */ var _consent_makeCategoryConsentObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1394);
/* harmony import */ var _consent_makeGranularConsentObject__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3018);
const EVENT_NAME=`${core_config__WEBPACK_IMPORTED_MODULE_4__/* .EVENTS_PREFIX */ .OH}_consent`;const SERVICES_EVENT_NAME=`${core_config__WEBPACK_IMPORTED_MODULE_4__/* .EVENTS_PREFIX */ .OH}_services_consent`;const dispatchConsentEvent=function(consent){let hasConsented=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;let widgetConfig=arguments.length>2?arguments[2]:undefined;const jsEventData=hasConsented?(0,_consent_makeCategoryConsentObject__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(consent,widgetConfig):constants_primitives__WEBPACK_IMPORTED_MODULE_5__/* .NULL */ .QV;const granularEventData=hasConsented?(0,_consent_makeGranularConsentObject__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(consent,widgetConfig):constants_primitives__WEBPACK_IMPORTED_MODULE_5__/* .NULL */ .QV;(0,_dispatchJSEvent__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(EVENT_NAME,jsEventData);(0,_dispatchJSEvent__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(SERVICES_EVENT_NAME,granularEventData);(0,_dispatchGTMConsentEvents__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .ZP)(consent,hasConsented,widgetConfig);};/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dispatchConsentEvent);

/***/ }),

/***/ 3116:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  ZP: () => (/* binding */ helpers_dispatchConsentLoadedEvent)
});

// UNUSED EXPORTS: EVENT_NAME, SERVICES_EVENT_NAME

// EXTERNAL MODULE: ./src/constants/primitives.ts
var primitives = __webpack_require__(9083);
// EXTERNAL MODULE: ./src/core/config.ts
var config = __webpack_require__(2353);
// EXTERNAL MODULE: ./src/helpers/dispatchGTMConsentEvents.ts
var dispatchGTMConsentEvents = __webpack_require__(4853);
// EXTERNAL MODULE: ./src/helpers/dispatchJSEvent.ts
var dispatchJSEvent = __webpack_require__(7179);
// EXTERNAL MODULE: ./src/helpers/consent/makeCategoryConsentObject.ts
var makeCategoryConsentObject = __webpack_require__(1394);
// EXTERNAL MODULE: ./src/helpers/consent/makeGranularConsentObject.ts
var makeGranularConsentObject = __webpack_require__(3018);
// EXTERNAL MODULE: ./src/constants/dom.ts
var dom = __webpack_require__(4327);
// EXTERNAL MODULE: ./src/core/integrationSettings.ts
var integrationSettings = __webpack_require__(7108);
// EXTERNAL MODULE: ./src/helpers/isArray.ts
var isArray = __webpack_require__(9264);
;// CONCATENATED MODULE: ./src/helpers/consent/isConsentModeInitProperly.ts
/**
 * Function to check if google consent mode has been initialized properly
 */const isConsentModeInitProperly=()=>{// Check if consent mode has been initialized at all
if(!dom/* _WINDOW_ */.X6["google_tag_data"]){console.warn("No Consent Mode data found");return;}// Set styles for console log, to make information look clear
const statusText=status=>status===undefined?"":status?"granted":"denied";const statusColor=status=>status==="granted"?"color: #0C0":"color: #C00";const tagData=dom/* _WINDOW_ */.X6["google_tag_data"];// Check entries in google tag
const consentEntries="ics"in tagData?tagData.ics.entries:null;let defaultStatus="",updateStatus="";for(const entry in consentEntries){defaultStatus=statusText(consentEntries[entry]['default']);updateStatus=statusText(consentEntries[entry]['update']);if(defaultStatus===""&&updateStatus==="")continue;const message=`\t${entry}:
        ${defaultStatus!==""?"\n\t\tDefault: %c"+defaultStatus:"%c"}%c
        ${updateStatus!==""?"\n\t\tUpdate: %c"+updateStatus:"%c"}`;console.log(message,defaultStatus!==""?statusColor(defaultStatus):"","",updateStatus!==""?statusColor(updateStatus):"","");}if(defaultStatus===""){console.log("No default Consent settings found");}const wasSetLate=tagData.ics.wasSetLate;if(wasSetLate){console.error("%cYour Consent Mode issue: %cA tag read consent before a Default was set. At least one of your Google Tags fired before the Consent Mode defaults were set. Read more: https://developers.google.com/tag-platform/security/guides/consent-debugging#default-consent or issue a support ticket to CookieFirst.","color: red; font-weight: bold;","color: red;");}else{console.log("%cConsent Mode defaults are correctly set in time.","color: green;");}};/* harmony default export */ const consent_isConsentModeInitProperly = (isConsentModeInitProperly);
;// CONCATENATED MODULE: ./src/helpers/dispatchConsentLoadedEvent.ts
const EVENT_NAME=`${config/* EVENTS_PREFIX */.OH}_consent_loaded`;const SERVICES_EVENT_NAME=`${config/* EVENTS_PREFIX */.OH}_services_consent_loaded`;const dispatchConsentLoadedEvent=function(consent){let hasConsented=arguments.length>1&&arguments[1]!==undefined?arguments[1]:primitives/* FALSE */.Dv;let widgetConfig=arguments.length>2?arguments[2]:undefined;const categoryEventData=hasConsented?(0,makeCategoryConsentObject/* default */.Z)(consent,widgetConfig):primitives/* NULL */.QV;const granularEventData=hasConsented?(0,makeGranularConsentObject/* default */.Z)(consent,widgetConfig):primitives/* NULL */.QV;(0,dispatchJSEvent/* default */.Z)(EVENT_NAME,categoryEventData);(0,dispatchJSEvent/* default */.Z)(SERVICES_EVENT_NAME,granularEventData);// Don't dispatch gtm consent right now if tcf is enabled and not initialized because tcf can initialize after normal consent
const{dataLayer,debugMode}=integrationSettings["default"];const dl=dom/* _WINDOW_ */.X6[dataLayer];if(!widgetConfig.tcfEnabled||(0,isArray/* default */.Z)(dl)&&dl.some(element=>element.event===`${config/* EVENTS_PREFIX */.OH}_tcf_init`)){(0,dispatchGTMConsentEvents/* default */.ZP)(consent,hasConsented,widgetConfig);if(debugMode){consent_isConsentModeInitProperly();}}else{dom/* _WINDOW_ */.X6.addEventListener(`${config/* EVENTS_PREFIX */.OH}_tcf_init`,()=>{(0,dispatchGTMConsentEvents/* default */.ZP)(consent,hasConsented,widgetConfig);if(debugMode){consent_isConsentModeInitProperly();}});}};/* harmony default export */ const helpers_dispatchConsentLoadedEvent = (dispatchConsentLoadedEvent);

/***/ }),

/***/ 4853:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ZP: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* unused harmony exports GRANTED, DENIED, AFTER_CONSENT_UPDATE_EVENT */
/* harmony import */ var constants_categories__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2157);
/* harmony import */ var core_config__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(2353);
/* harmony import */ var _dispatchConsentEvent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5383);
/* harmony import */ var constants_primitives__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(9083);
/* harmony import */ var types_scriptIntegrationMethods__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(1873);
/* harmony import */ var constants_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4327);
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6639);
/* harmony import */ var core_integrationSettings__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(7108);
/* harmony import */ var _consent_makeCategoryConsentObject__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(1394);
/* harmony import */ var _consent_makeGranularConsentObject__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(3018);
/* harmony import */ var _isScannerApp__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(5006);
// custom order of categories necessary for GTM integration
const CATEGORIES=[constants_categories__WEBPACK_IMPORTED_MODULE_0__/* .NECESSARY */ .a3,constants_categories__WEBPACK_IMPORTED_MODULE_0__/* .ADVERTISING */ .rO,constants_categories__WEBPACK_IMPORTED_MODULE_0__/* .PERFORMANCE */ .KS,constants_categories__WEBPACK_IMPORTED_MODULE_0__/* .FUNCTIONAL */ .Lp];const GTM_CALLBACKS=[];const GRANTED="granted";const DENIED="denied";const AFTER_CONSENT_UPDATE_EVENT=`${core_config__WEBPACK_IMPORTED_MODULE_8__/* .EVENTS_PREFIX */ .OH}_after_consent_update`;/**
* Called from GTM template to set callback to be executed when user consent is provided.
* @param {function} callback to execute on user consent
*/constants_dom__WEBPACK_IMPORTED_MODULE_2__/* ._WINDOW_ */ .X6.addCFGTMConsentListener=callback=>{GTM_CALLBACKS.push(callback);};const dispatchGTMConsentEvents=function(consent){let hasConsented=arguments.length>1&&arguments[1]!==undefined?arguments[1]:constants_primitives__WEBPACK_IMPORTED_MODULE_9__/* .FALSE */ .Dv;let widgetConfig=arguments.length>2?arguments[2]:undefined;// create dataLayer and gtag if not available
const{dataLayer}=core_integrationSettings__WEBPACK_IMPORTED_MODULE_4__["default"];if(true){(0,_logger__WEBPACK_IMPORTED_MODULE_3__/* .coreLogger */ .cl)({dl:constants_dom__WEBPACK_IMPORTED_MODULE_2__/* ._WINDOW_ */ .X6[dataLayer],gtag:constants_dom__WEBPACK_IMPORTED_MODULE_2__/* ._WINDOW_ */ .X6.gtag});}constants_dom__WEBPACK_IMPORTED_MODULE_2__/* ._WINDOW_ */ .X6[dataLayer]=constants_dom__WEBPACK_IMPORTED_MODULE_2__/* ._WINDOW_ */ .X6[dataLayer]||[];if(typeof constants_dom__WEBPACK_IMPORTED_MODULE_2__/* ._WINDOW_ */ .X6.gtag!=="function"){constants_dom__WEBPACK_IMPORTED_MODULE_2__/* ._WINDOW_ */ .X6.gtag=function(){constants_dom__WEBPACK_IMPORTED_MODULE_2__/* ._WINDOW_ */ .X6[dataLayer].push(arguments);};}const dl=constants_dom__WEBPACK_IMPORTED_MODULE_2__/* ._WINDOW_ */ .X6[dataLayer];const gtag=constants_dom__WEBPACK_IMPORTED_MODULE_2__/* ._WINDOW_ */ .X6.gtag;// calculate which categories are accepted
const categoryConsent=(0,_consent_makeCategoryConsentObject__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(consent,widgetConfig);// calculate which services are accepted
const granularConsent=(0,_consent_makeGranularConsentObject__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(consent,widgetConfig);/**
   * CONSENT MODE INTEGRATION
   */if(widgetConfig.googleConsentModeEnabled){if(GTM_CALLBACKS.length===0){if(hasConsented&&!widgetConfig.disableGCMUpdateEvents||(0,_isScannerApp__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)()){const consentMode={security_storage:GRANTED,// always granted because depends on "necessary" category
analytics_storage:categoryConsent[constants_categories__WEBPACK_IMPORTED_MODULE_0__/* .PERFORMANCE */ .KS]?GRANTED:DENIED,functionality_storage:categoryConsent[constants_categories__WEBPACK_IMPORTED_MODULE_0__/* .FUNCTIONAL */ .Lp]?GRANTED:DENIED,ad_storage:categoryConsent[constants_categories__WEBPACK_IMPORTED_MODULE_0__/* .ADVERTISING */ .rO]?GRANTED:DENIED,ad_personalization:categoryConsent[constants_categories__WEBPACK_IMPORTED_MODULE_0__/* .ADVERTISING */ .rO]?GRANTED:DENIED,ad_user_data:categoryConsent[constants_categories__WEBPACK_IMPORTED_MODULE_0__/* .ADVERTISING */ .rO]?GRANTED:DENIED,personalization_storage:categoryConsent[constants_categories__WEBPACK_IMPORTED_MODULE_0__/* .FUNCTIONAL */ .Lp]?GRANTED:DENIED};gtag("consent","update",consentMode);}// further reduce advertising data sent when advertising is disabled
// or enable sending of advertising data when advertising is enabled
if(hasConsented||categoryConsent[constants_categories__WEBPACK_IMPORTED_MODULE_0__/* .ADVERTISING */ .rO]){gtag("set","ads_data_redaction",!categoryConsent[constants_categories__WEBPACK_IMPORTED_MODULE_0__/* .ADVERTISING */ .rO]);}}else{GTM_CALLBACKS.forEach(callback=>{callback(categoryConsent);});}}// merge all events in data layer into one object of data
const data=dl.reduce((prev,curr)=>({...prev,...curr}),{});// send an event to GTM about acceptance of a given consent key
const sendToGTM=(key,value)=>{const variable=`${core_config__WEBPACK_IMPORTED_MODULE_8__/* .EVENTS_PREFIX */ .OH}_${key}_enabled`;// don't send consent change event if state is the same
if(data[variable]===value){return;}dl.push({event:`${_dispatchConsentEvent__WEBPACK_IMPORTED_MODULE_1__/* .EVENT_NAME */ .W1}_${key}`,[variable]:value});};// send events about acceptance status of individual services
widgetConfig.scripts.filter(script=>script.integration===types_scriptIntegrationMethods__WEBPACK_IMPORTED_MODULE_10__/* .SCRIPT_INTEGRATION_METHOD_GTM_LOAD */ .I$).forEach(script=>{const key=script.consent_key;sendToGTM(key,!!granularConsent[key]);});// send events about acceptance status of categories
CATEGORIES.forEach(cat=>sendToGTM(cat,!!categoryConsent[cat]));dl.push({event:AFTER_CONSENT_UPDATE_EVENT});};/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dispatchGTMConsentEvents);

/***/ }),

/***/ 7179:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var constants_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4327);
const dispatchJSEvent=(event,detail)=>{constants_dom__WEBPACK_IMPORTED_MODULE_0__/* ._WINDOW_ */ .X6.dispatchEvent(new CustomEvent(event,{detail}));};/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dispatchJSEvent);

/***/ }),

/***/ 3825:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   W: () => (/* binding */ EVENT_NAME),
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var core_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2353);
/* harmony import */ var _dispatchJSEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7179);
const EVENT_NAME=`${core_config__WEBPACK_IMPORTED_MODULE_1__/* .EVENTS_PREFIX */ .OH}_render_embeds`;const dispatchRenderEmbedsEvent=()=>{// dispach custom JS event
(0,_dispatchJSEvent__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(EVENT_NAME);};/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dispatchRenderEmbedsEvent);

/***/ }),

/***/ 6048:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function addEventListener(target,event,callback,options){target.addEventListener(event,callback,options);}/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (addEventListener);

/***/ }),

/***/ 5992:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var constants_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4327);
function createElement(tagName,options){return constants_dom__WEBPACK_IMPORTED_MODULE_0__/* ._DOCUMENT_ */ .uI.createElement(tagName,options);}/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createElement);

/***/ }),

/***/ 6828:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function removeEventListener(target,event,callback,options){target.removeEventListener(event,callback,options);}/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (removeEventListener);

/***/ }),

/***/ 7657:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* unused harmony export cachedData */
/* harmony import */ var constants_errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6525);
/* harmony import */ var _api_getJson__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(8576);
/* harmony import */ var core_integrationSettings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7108);
/* harmony import */ var core_config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(2353);
/* harmony import */ var helpers_makeUrlQuery__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(9806);
/* harmony import */ var _createPromise__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2662);
const cachedData={};const fetchSiteCookies=(userLang,version)=>{const{apiKey}=core_integrationSettings__WEBPACK_IMPORTED_MODULE_1__["default"];return (0,_createPromise__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)((resolve,reject)=>{if(!userLang){return reject(new Error(constants_errors__WEBPACK_IMPORTED_MODULE_0__/* .COOKIE_LOADING_FAILED */ .qx));}if(cachedData[userLang]){return resolve(cachedData[userLang]);}const query=(0,helpers_makeUrlQuery__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)({api_key:apiKey,lang:userLang,version:version||Date.now().toString(),origin:window.location.hostname});(0,_api_getJson__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(`${core_config__WEBPACK_IMPORTED_MODULE_5__/* .EDGE_API_URL */ .AV}/site-cookies?${query}`).then(_ref=>{let[body]=_ref;// if there were two concurrent requests and one already finished, use it's response
if(cachedData[userLang]){return resolve(cachedData[userLang]);}cachedData[userLang]={...body,cookies:body.cookies||[],cookie_policy_updated_at:body.cookie_policy_updated_at||"",cookie_list_updated_at:body.cookie_list_updated_at||""};return resolve(cachedData[userLang]);}).catch(reject);});};/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (fetchSiteCookies);

/***/ }),

/***/ 4948:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var constants_primitives__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9083);
/* harmony import */ var _isObject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7067);
const getByPath=function(object,path){let fallback=arguments.length>2&&arguments[2]!==undefined?arguments[2]:constants_primitives__WEBPACK_IMPORTED_MODULE_0__/* .NULL */ .QV;let currentObject=object;const pathParts=path.split(".");for(let i=0;i<pathParts.length;i++){const key=pathParts[i];const nextObject=currentObject[key];// last key
if(i===pathParts.length-1){return typeof nextObject==='undefined'?fallback:nextObject;}if(!nextObject||!(0,_isObject__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(nextObject)){return fallback;}currentObject=nextObject;}return fallback;};/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getByPath);

/***/ }),

/***/ 9368:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var constants_primitives__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9083);
/* harmony import */ var constants_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4327);
/* harmony import */ var _report__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7432);
// code from https://www.w3schools.com/js/js_cookies.asp
const getCookie=cookieName=>{const name=cookieName+"=";try{const cookieArray=constants_dom__WEBPACK_IMPORTED_MODULE_0__/* ._DOCUMENT_ */ .uI.cookie.split(";");for(let i=0;i<cookieArray.length;i++){let c=cookieArray[i];while(c.charAt(0)===" "){c=c.substring(1);}if(c.indexOf(name)===0){return decodeURIComponent(c.substring(name.length,c.length));}}}catch(e){(0,_report__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(e);return constants_primitives__WEBPACK_IMPORTED_MODULE_2__/* .NULL */ .QV;}return constants_primitives__WEBPACK_IMPORTED_MODULE_2__/* .NULL */ .QV;};/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getCookie);

/***/ }),

/***/ 6225:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const TEST_STRING="__storage_test__";const getLocalStorage=()=>{try{const storage=window.localStorage;if(!storage){return null;}storage.setItem(TEST_STRING,TEST_STRING);storage.removeItem(TEST_STRING);return storage;}catch(e){return null;}};/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getLocalStorage);

/***/ }),

/***/ 8915:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var constants_primitives__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9083);
/* harmony import */ var _getLocalStorage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6225);
/* harmony import */ var _report__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7432);
function getLocalStorageItem(key,fallback){const storage=(0,_getLocalStorage__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)();try{if(!storage){return fallback;}const value=storage.getItem(key);if(value===constants_primitives__WEBPACK_IMPORTED_MODULE_1__/* .NULL */ .QV){return fallback;}try{return JSON.parse(value);}catch(e){(0,_report__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(e);return fallback;}}catch(e){(0,_report__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(e);return fallback;}}/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getLocalStorageItem);

/***/ }),

/***/ 2446:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var constants_primitives__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9083);
/* harmony import */ var core_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2353);
/* harmony import */ var _trim__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1511);
const getStaticFileUrl=function(filename){let version=arguments.length>1&&arguments[1]!==undefined?arguments[1]:constants_primitives__WEBPACK_IMPORTED_MODULE_1__/* .NULL */ .QV;const filePath=(0,_trim__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(filename,"/").replace("//","/");// fix double // which may appear in some urls if path isn't concatenated correctly
return`${core_config__WEBPACK_IMPORTED_MODULE_2__/* .STATIC_URL */ .ud}/${filePath}${version?`?v=${version}`:""}`;};/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getStaticFileUrl);

/***/ }),

/***/ 5491:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Nq: () => (/* binding */ LTR),
/* harmony export */   ZP: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* unused harmony export RTL */
/* harmony import */ var _includes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8217);
const RTL='rtl';const LTR='ltr';const getTextDirection=lang=>{return (0,_includes__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(["ar","he"],lang)?RTL:LTR;};/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getTextDirection);

/***/ }),

/***/ 6007:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const getTimestamp=()=>Math.round(Date.now()/1000);/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getTimestamp);

/***/ }),

/***/ 8217:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var constants_primitives__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9083);
/* harmony import */ var _isArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9264);
/* harmony import */ var _isString__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8060);
const includes=(haystack,needle)=>{if(!(0,_isArray__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(haystack)&&!(0,_isString__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(haystack)){return constants_primitives__WEBPACK_IMPORTED_MODULE_2__/* .FALSE */ .Dv;}return haystack.includes(needle);};/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (includes);

/***/ }),

/***/ 9969:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  B: () => (/* binding */ createWidgetConfig)
});

// EXTERNAL MODULE: ./src/constants/categories.ts
var categories = __webpack_require__(2157);
// EXTERNAL MODULE: ./src/types/config-files/mainConfig.ts
var mainConfig = __webpack_require__(7086);
// EXTERNAL MODULE: ./src/types/consent.ts
var consent = __webpack_require__(5304);
// EXTERNAL MODULE: ./src/constants/primitives.ts
var primitives = __webpack_require__(9083);
// EXTERNAL MODULE: ./src/constants/countries.ts
var countries = __webpack_require__(3867);
// EXTERNAL MODULE: ./src/types/scriptIntegrationMethods.ts
var scriptIntegrationMethods = __webpack_require__(1873);
// EXTERNAL MODULE: ./src/constants/time.ts
var time = __webpack_require__(544);
// EXTERNAL MODULE: ./src/helpers/getByPath.ts
var getByPath = __webpack_require__(4948);
// EXTERNAL MODULE: ./src/helpers/isArray.ts
var isArray = __webpack_require__(9264);
// EXTERNAL MODULE: ./src/helpers/isString.ts
var isString = __webpack_require__(8060);
// EXTERNAL MODULE: ./src/helpers/isObject.ts
var isObject = __webpack_require__(7067);
// EXTERNAL MODULE: ./src/helpers/includes.ts
var includes = __webpack_require__(8217);
;// CONCATENATED MODULE: ./src/constants/regions.ts
const DEFAULT_NON_EU_BANNER_REGIONS=["CA",// California
"QC"// Quebec
];
;// CONCATENATED MODULE: ./src/helpers/init/WidgetConfig.ts
const createWidgetConfig=config=>{let _config=(0,isObject/* default */.Z)(config)?config:{};const get=function(path){let fallback=arguments.length>1&&arguments[1]!==undefined?arguments[1]:primitives/* NULL */.QV;return (0,getByPath/* default */.Z)(_config,path,fallback);};const getArray=function(path){let fallback=arguments.length>1&&arguments[1]!==undefined?arguments[1]:[];const list=get(path)||fallback;return (0,isArray/* default */.Z)(list)?list:fallback;};const getBool=path=>!!get(path,primitives/* FALSE */.Dv);const consentPolicy=get("consentPolicy")||consent/* CONSENT_POLICY_CATEGORY_OPTIN */.hs;const isGranularPolicy=consentPolicy===consent/* CONSENT_POLICY_GRANULAR_OPTIN */.Gc;const scripts=getArray("scripts").map(script=>({...script,integration:script.integration||scriptIntegrationMethods/* SCRIPT_INTEGRATION_METHOD_BANNER_LOAD */.yj}));const widgetConfig={lastConsentReset:get("lastConsentReset",primitives/* NULL */.QV)||primitives/* NULL */.QV,additionalLink:get("additionalLink","")||"",type:get("widget.type",mainConfig/* WIDGET_TYPE_BANNER */.nv)||mainConfig/* WIDGET_TYPE_BANNER */.nv,buttonsOrder:getArray("widget.buttonsOrder"),version:get("version"),get location(){const loc=get("widget.location");const locations=mainConfig/* WidgetLocations */.gK[this.type];return (0,includes/* default */.Z)(locations,loc)?loc:locations[0];},get bulkConsent(){const bulkConfig=get("bulkConsent")||{};return{id:(0,getByPath/* default */.Z)(bulkConfig,"id"),group:(0,getByPath/* default */.Z)(bulkConfig,"group",""),domains:(0,getByPath/* default */.Z)(bulkConfig,"domains",[])||[],iframeUrl:(0,getByPath/* default */.Z)(bulkConfig,"iframeUrl"),baseDomain:(0,getByPath/* default */.Z)(bulkConfig,"baseDomain")};},consentPolicy:consentPolicy,isGranularPolicy:isGranularPolicy,privacyPolicyUrl:get("privacyPolicyUrl"),showPrivacyUrlInBanner:getBool("showPrivacyUrlInBanner"),hideOutsideEU:getBool("hideOutsideEU"),showSuffixOnFirstLayer:getBool("showSuffixOnFirstLayer"),showNumberOfScriptsInBanner:getBool("showNumberOfScriptsInBanner"),loadCssWithLink:getBool("loadCssWithLink"),get tabsOnSettingsPanel(){const key="tabsOnSettingsPanel";const tabsConfig=getArray(key);let tabs=[];// handle sites without tabs config
if(!tabsConfig){tabs=[mainConfig/* PANEL_SETTINGS_TAB */.bl,mainConfig/* PANEL_COOKIES_TAB */.Y4,get("hideCookiePolicy")?"":mainConfig/* PANEL_POLICY_TAB */.YI];}else{tabs=tabsConfig;}if(!(0,includes/* default */.Z)(tabs,mainConfig/* PANEL_SETTINGS_TAB */.bl)){tabs.unshift(mainConfig/* PANEL_SETTINGS_TAB */.bl);}return tabs.filter(t=>!!t&&(0,isString/* default */.Z)(t));},languages:getArray("languages"),showLanguageSwitcher:getBool("showLanguageSwitcher"),banner_continue_button_type:get("banner_continue_button_type")||mainConfig/* CONTINUE_BTN_STYLE_DISABLED */.mY,baseConsent:get("baseConsent"),/**
     * Pre-consent is the consent object used before any consent is given
     */preConsent:{...categories/* EMPTY_CATEGORY_CONSENT */.Li,...(get("preConsent")||{})},scripts:scripts,// from all available categories
cookieCategories:categories/* categories */.bd.filter(cat=>{const configuredCats=getArray("cookieCategories");// reject those which are not configured for this domain
if(!(0,includes/* default */.Z)(configuredCats,cat)){return primitives/* FALSE */.Dv;}// and if we use granular consent, reject those which don't have at least one service assigned
if(isGranularPolicy){return!!scripts.find(script=>(0,includes/* default */.Z)(script.categories,cat));}return primitives/* TRUE */.uX;}),whitelabel:{banner:getBool("whitelabel.banner"),panel:getBool("whitelabel.panel"),logoUrl:get("whitelabel.logoUrl",primitives/* NULL */.QV),linkUrl:get("whitelabel.linkUrl",primitives/* NULL */.QV)},loadInlineScripts:getBool("loadInlineScripts"),okAcceptsAll:getBool("okAcceptsAll"),googleConsentModeEnabled:getBool("googleConsentModeEnabled"),disableGCMUpdateEvents:getBool("disableGCMUpdateEvents"),denyBtn:get("denyBtn","visible"),denyBtnSecond:get("denyBtnSecond")||get("denyBtn","visible"),get bannerToggles(){const showToggles=getBool("bannerToggles");return showToggles&&this.cookieCategories.length>1;},backdropEnabled:getBool("backdropEnabled"),backdropColor:get("backdropColor"),floatingBtn:{// if floatingBtn.isEnabled is not set, use enableFloatingButton as a fallback
isEnabled:getBool("floatingBtn.isEnabled"),icon:get("floatingBtn.icon"),location:get("floatingBtn.location")},fontFamily:get("widget.fontFamily",""),widget:get("widget",{type:mainConfig/* WIDGET_TYPE_BANNER */.nv,location:mainConfig/* BANNER_WIDGET_LOCATION_BOTTOM */.O8,fontFamily:"",buttonsOrder:[]}),reconsent:{after:get("reconsent.after"),check:get("reconsent.check"),categories:getArray("reconsent.categories")},get branding(){const hasBrandingConfig=!!get("branding");return{panel:{show:hasBrandingConfig?get("branding.panel.show",primitives/* TRUE */.uX):!this.whitelabel.panel,url:get("branding.panel.url"),logo:get("branding.panel.logo"),label:get("branding.panel.label"),showLabel:getBool("branding.panel.showLabel")},banner:{show:hasBrandingConfig?get("branding.banner.show",primitives/* TRUE */.uX):!this.whitelabel.banner,url:get("branding.banner.url"),logo:get("branding.banner.logo"),label:get("branding.banner.label"),showLabel:getBool("branding.banner.showLabel")}};},increaseLocationPrecision:getBool("increaseLocationPrecision"),/**
     * consentLifetime - number of seconds after which consent is considered expired
     */get consentLifetime(){const lifetime=get("consentLifetime");if(!lifetime||typeof lifetime!=="number"){return time/* YEAR_IN_SECONDS */.z;}return lifetime;},consentType:isGranularPolicy?consent/* CONSENT_TYPE_GRANULAR */.an:consent/* CONSENT_TYPE_CATEGORY */.LV,bannerNonEuCountries:getArray("bannerNonEuCountries",countries/* DEFAULT_NON_EU_BANNER_COUNTRIES */.np),tcfEnabled:get("tcfEnabled",primitives/* FALSE */.Dv),tcfLanguages:getArray("tcfLanguages"),tcfCountry:get("tcfCountry",""),tcfVendors:get("tcfVendors",[]),tcfGdprApplies:get("tcfGdprApplies",primitives/* FALSE */.Dv),acEnabled:get("acEnabled",primitives/* FALSE */.Dv),acVendors:get("acVendors",[]),gpcAndDntEnabled:getBool("gpcAndDntEnabled"),bannerNonEuRegions:getArray("bannerNonEuRegions",DEFAULT_NON_EU_BANNER_REGIONS),isUsingWildcard:get("isUsingWildcard",primitives/* FALSE */.Dv),wildcardUrls:get("wildcardUrls",[])};return widgetConfig;};

/***/ }),

/***/ 9264:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const isArray=input=>Array.isArray(input);/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isArray);

/***/ }),

/***/ 8987:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const isFunction=input=>{return typeof input==="function";};/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isFunction);

/***/ }),

/***/ 7067:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const isObject=input=>{return!!input&&typeof input==="object";};/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isObject);

/***/ }),

/***/ 5006:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* unused harmony export USER_AGENT */
/* harmony import */ var helpers_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6639);
/* harmony import */ var _isString__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8060);
/* harmony import */ var _includes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(8217);
const USER_AGENT="CookieCheck";const isScannerApp=()=>{const ua=navigator.userAgent;const result=(0,_isString__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(ua)&&(0,_includes__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(ua,USER_AGENT);if(result){(0,helpers_logger__WEBPACK_IMPORTED_MODULE_0__/* .coreLogger */ .cl)("is Scanner.");}return result;};/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isScannerApp);

/***/ }),

/***/ 8060:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const isString=input=>{return typeof input==="string";};/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isString);

/***/ }),

/***/ 5726:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Z: () => (/* binding */ helpers_logUserConsent)
});

// EXTERNAL MODULE: ./src/constants/primitives.ts
var primitives = __webpack_require__(9083);
// EXTERNAL MODULE: ./src/core/config.ts
var config = __webpack_require__(2353);
// EXTERNAL MODULE: ./src/core/integrationSettings.ts
var integrationSettings = __webpack_require__(7108);
// EXTERNAL MODULE: ./src/helpers/report.ts
var report = __webpack_require__(7432);
// EXTERNAL MODULE: ./src/helpers/createPromise.ts
var createPromise = __webpack_require__(2662);
// EXTERNAL MODULE: ./src/helpers/api/getJson.ts
var getJson = __webpack_require__(8576);
;// CONCATENATED MODULE: ./src/helpers/api/post.ts
const post=(url,body)=>{return (0,createPromise/* default */.Z)((resolve,reject)=>{(0,getJson/* default */.Z)(url,{method:'POST',body:JSON.stringify(body),headers:{'Content-Type':'application/json','Accept':'application/json'}}).then(resolve,reject);});};/* harmony default export */ const api_post = (post);
;// CONCATENATED MODULE: ./src/helpers/logUserConsent.ts
/**
 * Log user consent in the audit trail on backend and
 * return the visitor id
 */const logUserConsent=function(consent,action,visitorId){let configVersion=arguments.length>3&&arguments[3]!==undefined?arguments[3]:primitives/* NULL */.QV;let visitorCountry=arguments.length>4&&arguments[4]!==undefined?arguments[4]:primitives/* NULL */.QV;let visitorRegion=arguments.length>5&&arguments[5]!==undefined?arguments[5]:primitives/* NULL */.QV;let consentPolicy=arguments.length>6&&arguments[6]!==undefined?arguments[6]:primitives/* NULL */.QV;let granularMetadata=arguments.length>7&&arguments[7]!==undefined?arguments[7]:primitives/* NULL */.QV;let tcstring=arguments.length>8&&arguments[8]!==undefined?arguments[8]:primitives/* NULL */.QV;let acstring=arguments.length>9&&arguments[9]!==undefined?arguments[9]:primitives/* NULL */.QV;const{apiKey}=integrationSettings["default"];return (0,createPromise/* default */.Z)((resolve,reject)=>{if(!config/* API_URL */.T5||!apiKey){return resolve(primitives/* NULL */.QV);}api_post(`${config/* API_URL */.T5}/consent`,{preferences:consent,apiKey,action,visitor_id:visitorId||"",config_version:configVersion,visitor_country:visitorCountry||primitives/* NULL */.QV,visitor_region:visitorRegion||primitives/* NULL */.QV,consent_policy:consentPolicy||primitives/* NULL */.QV,granular_metadata:granularMetadata||primitives/* NULL */.QV,url:window.location.href,tcstring:tcstring,acstring:acstring}).then(_ref=>{let[body]=_ref;resolve(body.visitor_id||primitives/* NULL */.QV);},e=>{(0,report/* default */.Z)("Error logging user consent. Data:",{error:e});reject(e);});});};/* harmony default export */ const helpers_logUserConsent = (logUserConsent);

/***/ }),

/***/ 6639:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   G6: () => (/* binding */ bulkLogger),
/* harmony export */   OM: () => (/* binding */ consentLogger),
/* harmony export */   cl: () => (/* binding */ coreLogger),
/* harmony export */   f1: () => (/* binding */ autoblockLogger)
/* harmony export */ });
/* unused harmony export cookieLogger */
/* harmony import */ var core_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2353);
/* harmony import */ var core_integrationSettings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7108);
const getModuleTimerLabel=module=>`${core_config__WEBPACK_IMPORTED_MODULE_1__/* .LOGS_PREFIX */ .f2} [${module}]`;const originalLogger=console;const timedLog=function(module){const{silentMode}=core_integrationSettings__WEBPACK_IMPORTED_MODULE_0__["default"];if(silentMode){return;}// outputs for example "[CF] [core]: 365.335ms message"
for(var _len=arguments.length,args=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){args[_key-1]=arguments[_key];}originalLogger.timeLog(getModuleTimerLabel(module),...args);// restart the timer so that next log shows time since this log
originalLogger.timeEnd(getModuleTimerLabel(module));originalLogger.time(getModuleTimerLabel(module));};const makeModuleLogger=module=>{originalLogger.time(getModuleTimerLabel(module));return function(){for(var _len2=arguments.length,args=new Array(_len2),_key2=0;_key2<_len2;_key2++){args[_key2]=arguments[_key2];}return timedLog(module,...args);};};const coreLogger=makeModuleLogger("core");const bulkLogger=makeModuleLogger("bulk");const autoblockLogger=makeModuleLogger("autoblock");const consentLogger=makeModuleLogger("consent");const cookieLogger=makeModuleLogger("cookie");

/***/ }),

/***/ 9806:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _objectKeys__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1733);
const makeUrlQuery=parts=>{const query=new URLSearchParams();(0,_objectKeys__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(parts).forEach(key=>{query.set(key,encodeURIComponent(parts[key]));});return query.toString();};/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (makeUrlQuery);

/***/ }),

/***/ 1733:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const objectKeys=o=>{return Object.keys(o);};/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (objectKeys);

/***/ }),

/***/ 2475:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const randomString=()=>{return Math.random().toString();};/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (randomString);

/***/ }),

/***/ 7432:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const report=function(){for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}args.forEach(console.error);};/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (report);

/***/ }),

/***/ 7234:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var constants_primitives__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(9083);
/* harmony import */ var constants_time__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(544);
/* harmony import */ var constants_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4327);
/* harmony import */ var _getTimestamp__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6007);
/* harmony import */ var _objectKeys__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(1733);
/**
 * Converts timestamp in seconds into a cookie expiration string expected by browser
 *
 * @param {number} expiration cookie expiration timestamp in seconds
 * @returns {string} cookie expiration string
 */const calculateCookieExpiration=expiration=>{const date=new Date();date.setTime(expiration*1000);return date.toUTCString();};const saveLocalCookie=function(name,value){let expiration=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;let bulkConfig=arguments.length>3?arguments[3]:undefined;const cookieExpiration=expiration!==null?expiration:(0,_getTimestamp__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)()+constants_time__WEBPACK_IMPORTED_MODULE_0__/* .YEAR_IN_SECONDS */ .z;const cookie={[name]:encodeURIComponent(value),expires:calculateCookieExpiration(cookieExpiration),path:"/",SameSite:"Lax",secure:window.location.protocol==="https:"};if(bulkConfig&&bulkConfig.id&&bulkConfig.baseDomain){cookie.domain=bulkConfig.baseDomain;}const cookieString=(0,_objectKeys__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)(cookie).map(key=>{const value=cookie[key];if(typeof value==="boolean"){return value?key:constants_primitives__WEBPACK_IMPORTED_MODULE_4__/* .NULL */ .QV;}return`${key}=${value}`;},[]).filter(Boolean).join("; ");constants_dom__WEBPACK_IMPORTED_MODULE_1__/* ._DOCUMENT_ */ .uI.cookie=cookieString;return cookieString;};/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (saveLocalCookie);

/***/ }),

/***/ 5114:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getLocalStorage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6225);
const saveLocalStorageItem=(key,value)=>{const storage=(0,_getLocalStorage__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)();if(!storage){return;}storage.setItem(key,JSON.stringify(value));};/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (saveLocalStorageItem);

/***/ }),

/***/ 5173:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var constants_primitives__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9083);
const stopEvent=function(e){let preventDefault=arguments.length>1&&arguments[1]!==undefined?arguments[1]:constants_primitives__WEBPACK_IMPORTED_MODULE_0__/* .FALSE */ .Dv;e.stopPropagation();if(preventDefault){e.preventDefault();}};/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stopEvent);

/***/ }),

/***/ 7947:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Dl: () => (/* binding */ VendorTypes),
/* harmony export */   FL: () => (/* binding */ TCFCategoryTypes),
/* harmony export */   Gz: () => (/* binding */ TCF_CONSENT_STATE_ACTION_TOGGLE_VENDOR),
/* harmony export */   Hu: () => (/* binding */ TCF_CONSENT_STATE_ACTION_ACCEPT_ALL),
/* harmony export */   O7: () => (/* binding */ TCF_CONSENT_STATE_ACTION_CONSENT_SAVE_FINISHED),
/* harmony export */   QD: () => (/* binding */ TCF_CONSENT_STATE_ACTION_TOGGLE_GATP_VENDOR),
/* harmony export */   Tx: () => (/* binding */ TCF_CONSENT_STATE_ACTION_START_CONSENT_SAVE),
/* harmony export */   YP: () => (/* binding */ TCF_CONSENT_STATE_ACTION_TOGGLE_CATEGORY_LEGITIMATE_INTEREST),
/* harmony export */   Yo: () => (/* binding */ TCF_CONSENT_STATE_ACTION_ACCEPT_ALL_LEGITIMATE_INTEREST),
/* harmony export */   bn: () => (/* binding */ TCF_CONSENT_STATE_ACTION_LOG_TO_API),
/* harmony export */   dh: () => (/* binding */ TCF_CONSENT_STATE_ACTION_TOGGLE_VENDOR_LEGITIMATE_INTEREST),
/* harmony export */   eh: () => (/* binding */ TCF_CONSENT_STATE_ACTION_TOGGLE_CATEGORY),
/* harmony export */   fH: () => (/* binding */ TCF_CONSENT_STATE_ACTION_SET_CONSENT),
/* harmony export */   v$: () => (/* binding */ TCF_CONSENT_STATE_ACTION_DENY),
/* harmony export */   y7: () => (/* binding */ TCFEventStatus)
/* harmony export */ });
// Those are types that are necessary to run application even if tcf is disabled. They are separated in order to make bundle smaller, so not entire tcf and dependencies have to be downloaded by default
const TCF_CONSENT_STATE_ACTION_TOGGLE_CATEGORY=0;const TCF_CONSENT_STATE_ACTION_TOGGLE_VENDOR=1;const TCF_CONSENT_STATE_ACTION_START_CONSENT_SAVE=2;const TCF_CONSENT_STATE_ACTION_CONSENT_SAVE_FINISHED=3;const TCF_CONSENT_STATE_ACTION_ACCEPT_ALL=4;const TCF_CONSENT_STATE_ACTION_LOG_TO_API=5;const TCF_CONSENT_STATE_ACTION_DENY=6;const TCF_CONSENT_STATE_ACTION_TOGGLE_GATP_VENDOR=7;const TCF_CONSENT_STATE_ACTION_TOGGLE_VENDOR_LEGITIMATE_INTEREST=8;const TCF_CONSENT_STATE_ACTION_TOGGLE_CATEGORY_LEGITIMATE_INTEREST=9;const TCF_CONSENT_STATE_ACTION_ACCEPT_ALL_LEGITIMATE_INTEREST=10;const TCF_CONSENT_STATE_ACTION_SET_CONSENT=11;// Basic action type
// Individual action types
let VendorTypes=/*#__PURE__*/function(VendorTypes){VendorTypes["IAB"]="iab";VendorTypes["NON_IAB"]="non_iab";VendorTypes["GOOGLE"]="g";return VendorTypes;}({});let TCFCategoryTypes=/*#__PURE__*/function(TCFCategoryTypes){TCFCategoryTypes["PURPOSES"]="purposes";TCFCategoryTypes["SPECIAL_PURPOSES"]="specialPurposes";TCFCategoryTypes["FEATURES"]="features";TCFCategoryTypes["SPECIAL_FEATURES"]="specialFeatures";return TCFCategoryTypes;}({});;let TCFEventStatus=/*#__PURE__*/function(TCFEventStatus){TCFEventStatus["TCLOADED"]="tcloaded";TCFEventStatus["IS_SHOWN"]="cmpuishown";TCFEventStatus["INTERACTION_COMPLETE"]="useractioncomplete";return TCFEventStatus;}({});

/***/ }),

/***/ 9680:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var core_config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2353);
/* harmony import */ var helpers_deleteLocalCookie__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5426);
/* harmony import */ var helpers_deleteLocalStorageItem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(63);
/**
 * Remove TCString from localstorage and first-party cookie
 */const TCFdeleteLocalTCString=bulkConfig=>{(0,helpers_deleteLocalStorageItem__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(core_config__WEBPACK_IMPORTED_MODULE_2__/* .TCSTRING_COOKIE */ .sT);(0,helpers_deleteLocalCookie__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(core_config__WEBPACK_IMPORTED_MODULE_2__/* .TCSTRING_COOKIE */ .sT,bulkConfig);};/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TCFdeleteLocalTCString);

/***/ }),

/***/ 4594:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GQ: () => (/* binding */ TCF_POLICY_VERSION),
/* harmony export */   Ol: () => (/* binding */ TCF_SUPPORTED_API_VERSION),
/* harmony export */   QK: () => (/* binding */ TCF_CMP_ID),
/* harmony export */   Qo: () => (/* binding */ TCF_CONSENT_SCREEN),
/* harmony export */   dY: () => (/* binding */ TCF_AVAILABLE_FILTERS),
/* harmony export */   fG: () => (/* binding */ TCF_PURPOSES_DISABLED_LEGITIMATE_INTEREST),
/* harmony export */   fz: () => (/* binding */ TCF_AC_STRING_VERSION),
/* harmony export */   qT: () => (/* binding */ TCF_VENDOR_CATEGORIES_TYPES)
/* harmony export */ });
/* unused harmony export TCF_FORCE_ACCEPT_ALL_NAME */
/* harmony import */ var _TCFConsentProvider_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7947);
/* harmony import */ var constants_primitives__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9083);
const TCF_VENDOR_CATEGORIES_TYPES=[{key:_TCFConsentProvider_types__WEBPACK_IMPORTED_MODULE_0__/* .TCFCategoryTypes */ .FL.PURPOSES,hasSwitch:constants_primitives__WEBPACK_IMPORTED_MODULE_1__/* .TRUE */ .uX,IABLibName:'purposeConsents',hasLegitimateInterest:constants_primitives__WEBPACK_IMPORTED_MODULE_1__/* .TRUE */ .uX,legIntName:"legIntPurposes",IABLibLegitimateInterestName:'purposeLegitimateInterests'},{key:_TCFConsentProvider_types__WEBPACK_IMPORTED_MODULE_0__/* .TCFCategoryTypes */ .FL.SPECIAL_PURPOSES,hasSwitch:constants_primitives__WEBPACK_IMPORTED_MODULE_1__/* .FALSE */ .Dv,hasLegitimateInterest:constants_primitives__WEBPACK_IMPORTED_MODULE_1__/* .FALSE */ .Dv},{key:_TCFConsentProvider_types__WEBPACK_IMPORTED_MODULE_0__/* .TCFCategoryTypes */ .FL.FEATURES,hasSwitch:constants_primitives__WEBPACK_IMPORTED_MODULE_1__/* .FALSE */ .Dv,hasLegitimateInterest:constants_primitives__WEBPACK_IMPORTED_MODULE_1__/* .FALSE */ .Dv},{key:_TCFConsentProvider_types__WEBPACK_IMPORTED_MODULE_0__/* .TCFCategoryTypes */ .FL.SPECIAL_FEATURES,hasSwitch:constants_primitives__WEBPACK_IMPORTED_MODULE_1__/* .TRUE */ .uX,IABLibName:'specialFeatureOptins',hasLegitimateInterest:constants_primitives__WEBPACK_IMPORTED_MODULE_1__/* .FALSE */ .Dv}];const TCF_FORCE_ACCEPT_ALL_NAME='FORCEACCEPTALL';const TCF_CMP_ID=382;const TCF_POLICY_VERSION=4;const TCF_AC_STRING_VERSION='2';const TCF_SUPPORTED_API_VERSION="2.2";const TCF_CONSENT_SCREEN=1;const TCF_AVAILABLE_FILTERS=[_TCFConsentProvider_types__WEBPACK_IMPORTED_MODULE_0__/* .TCFCategoryTypes */ .FL.PURPOSES,_TCFConsentProvider_types__WEBPACK_IMPORTED_MODULE_0__/* .TCFCategoryTypes */ .FL.SPECIAL_PURPOSES,_TCFConsentProvider_types__WEBPACK_IMPORTED_MODULE_0__/* .TCFCategoryTypes */ .FL.FEATURES,_TCFConsentProvider_types__WEBPACK_IMPORTED_MODULE_0__/* .TCFCategoryTypes */ .FL.SPECIAL_FEATURES];const TCF_PURPOSES_DISABLED_LEGITIMATE_INTEREST=[1,3,4,5,6];

/***/ }),

/***/ 8075:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   o: () => (/* binding */ calculateTCFBaseConsent)
/* harmony export */ });
/**
 * Calculate accepted categories or scripts object
 * according to pre-selected categories.
 * @returns
 */const calculateTCFBaseConsent=()=>{const baseConsent={vendors:{},categories:{},vendorsLegitimateInterest:{},categoriesLegitimateInterest:{},gatp:{}};return Object.freeze(baseConsent);};

/***/ }),

/***/ 6667:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var core_config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(2353);
/* harmony import */ var constants_primitives__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(9083);
/* harmony import */ var helpers_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6639);
/* harmony import */ var helpers_getCookie__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9368);
/* harmony import */ var helpers_getLocalStorageItem__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(8915);
/* harmony import */ var helpers_report__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(7432);
/* harmony import */ var _iabtechlabtcf_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9553);
/* harmony import */ var _constantsTCF__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4594);
/* harmony import */ var _calculateTCFBaseConsent__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(8075);
/* harmony import */ var constants_errors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(6525);
const loadLocalTCFConsentCookie=()=>{const cookie=(0,helpers_getCookie__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(core_config__WEBPACK_IMPORTED_MODULE_5__/* .TCSTRING_COOKIE */ .sT);// cookie doesn't exist, no consent
if(!cookie){return constants_primitives__WEBPACK_IMPORTED_MODULE_6__/* .NULL */ .QV;}try{const decoded=JSON.parse(decodeURIComponent(cookie));return decoded;}catch(e){(0,helpers_logger__WEBPACK_IMPORTED_MODULE_0__/* .consentLogger */ .OM)("Failed to decode local consent cookie:");(0,helpers_report__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(e);// not valid JSON value in cookie
return constants_primitives__WEBPACK_IMPORTED_MODULE_6__/* .NULL */ .QV;}};const formatStoredValue=(storedValue,widgetConfig)=>{// Format stored tc string to get data from it
const decodedTCString=_iabtechlabtcf_core__WEBPACK_IMPORTED_MODULE_2__/* .TCString */ .E9.decode(storedValue.tcString);let consent=(0,_calculateTCFBaseConsent__WEBPACK_IMPORTED_MODULE_8__/* .calculateTCFBaseConsent */ .o)();// Update consent with every assigned category from created TCstring
decodedTCString.vendorConsents.forEach((hasConsent,vendorID)=>{consent={...consent,vendors:{...consent.vendors,[vendorID]:hasConsent}};});decodedTCString.vendorLegitimateInterests.forEach((hasConsent,vendorID)=>{consent={...consent,vendorsLegitimateInterest:{...consent.vendorsLegitimateInterest,[vendorID]:hasConsent}};});// Loop through all categories and add them
_constantsTCF__WEBPACK_IMPORTED_MODULE_3__/* .TCF_VENDOR_CATEGORIES_TYPES */ .qT.forEach(category=>{if(category.hasSwitch){if(!category.IABLibName){console.error(constants_errors__WEBPACK_IMPORTED_MODULE_4__/* .MISSING_IAB_LIB_NAME */ .aL);return;}decodedTCString[category.IABLibName].forEach((hasConsent,categoryID)=>{consent={...consent,categories:{...consent.categories,[category.key]:{...consent.categories[category.key],[categoryID]:hasConsent}}};});if(category.hasLegitimateInterest){if(!category.IABLibLegitimateInterestName){console.error(constants_errors__WEBPACK_IMPORTED_MODULE_4__/* .MISSING_IAB_LIB_LEGINT_NAME */ .Hf);return;}decodedTCString[category.IABLibLegitimateInterestName].forEach((hasConsent,categoryID)=>{consent={...consent,categoriesLegitimateInterest:{...consent.categoriesLegitimateInterest,[category.key]:{...consent.categoriesLegitimateInterest[category.key],[categoryID]:hasConsent}}};});}}});// Decode ac string into values if it's enabled
if(widgetConfig.acEnabled){// Convert ac string in format version~vendorID.VendorID.VendorID... to array of vendors
if(storedValue.acString){const decodedGatpVendors=storedValue.acString.split(`~`)[1].split('.');decodedGatpVendors.forEach(vendorID=>{consent.gatp[vendorID]=constants_primitives__WEBPACK_IMPORTED_MODULE_6__/* .TRUE */ .uX;});}}return[{...consent},parseInt(storedValue.timestamp||"0"),// use numeric timestamp here,
storedValue.tcString,storedValue.acString];};const loadLocalTCFConsent=widgetConfig=>{// try to load consent from localStorage
const localStorageItem=(0,helpers_getLocalStorageItem__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)(core_config__WEBPACK_IMPORTED_MODULE_5__/* .TCSTRING_COOKIE */ .sT,constants_primitives__WEBPACK_IMPORTED_MODULE_6__/* .NULL */ .QV);if(localStorageItem){return formatStoredValue(localStorageItem,widgetConfig);}// fall back to cookie if localstorage is not available
const cookie=loadLocalTCFConsentCookie();if(cookie){return formatStoredValue(cookie,widgetConfig);}// no consent
return constants_primitives__WEBPACK_IMPORTED_MODULE_6__/* .NULL */ .QV;};/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (loadLocalTCFConsent);

/***/ }),

/***/ 1511:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* unused harmony export WHITESPACE */
const WHITESPACE=[// Basic whitespace characters.
" ","\t","\x0b","\f","\xa0","\ufeff",// Line terminators.
"\n","\r","\u2028","\u2029"// Unicode category "Zs" space separators.
// "\u1680",
// "\u180e",
// "\u2000",
// "\u2001",
// "\u2002",
// "\u2003",
// "\u2004",
// "\u2005",
// "\u2006",
// "\u2007",
// "\u2008",
// "\u2009",
// "\u200a",
// "\u202f",
// "\u205f",
// "\u3000",
].join("");const trim=function(string){let char=arguments.length>1&&arguments[1]!==undefined?arguments[1]:"";let trimmed=(string||"").toString().trim();if(char){trimmed=trimmed.replace(new RegExp(`^${char}+`),'').replace(new RegExp(`${char}+$`),'');}return trimmed;};/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (trim);

/***/ }),

/***/ 8386:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var core_AppStateContext__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9424);
/* harmony import */ var constants_errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6525);
/* harmony import */ var preact_hooks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6075);
const useAppState=()=>{const ctx=(0,preact_hooks__WEBPACK_IMPORTED_MODULE_2__/* .useContext */ .qp)(core_AppStateContext__WEBPACK_IMPORTED_MODULE_0__/* .APP_STATE_CONTEXT */ .G);if(!ctx){throw new Error(constants_errors__WEBPACK_IMPORTED_MODULE_1__/* .CONTEXT_OUTSIDE_PROVIDER */ .ZG);}return ctx;};/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (useAppState);

/***/ }),

/***/ 639:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _useUserConsent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1322);
const useShouldShowBanner=()=>{const{hasConsented,isForcingReconsent}=(0,_useUserConsent__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)();return!hasConsented||isForcingReconsent;};/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (useShouldShowBanner);

/***/ }),

/***/ 9908:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var preact_hooks__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6075);
const useTCFDynamicImport=widgetConfig=>{const[TCFImportResult,setTCFImportResult]=(0,preact_hooks__WEBPACK_IMPORTED_MODULE_0__/* .useState */ .eJ)({});(0,preact_hooks__WEBPACK_IMPORTED_MODULE_0__/* .useEffect */ .d4)(()=>{// Import entire integrationTCF which is file that consist of all files important for tcf reexported 
if(widgetConfig.tcfEnabled){Promise.all(/* import() */[__webpack_require__.e(207), __webpack_require__.e(580)]).then(__webpack_require__.bind(__webpack_require__, 6580)).then(result=>{setTCFImportResult(()=>result);});}},[widgetConfig.tcfEnabled]);return TCFImportResult;};/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (useTCFDynamicImport);

/***/ }),

/***/ 3011:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var core_TranslationsContext__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3672);
/* harmony import */ var constants_errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6525);
/* harmony import */ var preact_hooks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6075);
const useTranslation=()=>{const ctx=(0,preact_hooks__WEBPACK_IMPORTED_MODULE_2__/* .useContext */ .qp)(core_TranslationsContext__WEBPACK_IMPORTED_MODULE_0__/* .TRANSLATIONS_CONTEXT */ .A);if(!ctx){throw new Error(constants_errors__WEBPACK_IMPORTED_MODULE_1__/* .CONTEXT_OUTSIDE_PROVIDER */ .ZG);}return ctx;};/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (useTranslation);

/***/ }),

/***/ 1322:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var core_UserConsentContext__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9475);
/* harmony import */ var constants_errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6525);
/* harmony import */ var preact_hooks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6075);
const useUserConsent=()=>{const ctx=(0,preact_hooks__WEBPACK_IMPORTED_MODULE_2__/* .useContext */ .qp)(core_UserConsentContext__WEBPACK_IMPORTED_MODULE_0__/* .USER_CONSENT_CONTEXT */ .$);if(!ctx){throw new Error(constants_errors__WEBPACK_IMPORTED_MODULE_1__/* .CONTEXT_OUTSIDE_PROVIDER */ .ZG);}return ctx;};/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (useUserConsent);

/***/ }),

/***/ 7086:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AU: () => (/* binding */ CONTINUE_BTN_STYLE_X_ONLY),
/* harmony export */   Bs: () => (/* binding */ CONTINUE_BTN_STYLE_LINK),
/* harmony export */   Ge: () => (/* binding */ BOX_WIDGET_LOCATION_BOTTOM_LEFT),
/* harmony export */   HI: () => (/* binding */ WIDGET_TYPE_BOX),
/* harmony export */   Mi: () => (/* binding */ BOX_WIDGET_LOCATION_BOTTOM_RIGHT),
/* harmony export */   O8: () => (/* binding */ BANNER_WIDGET_LOCATION_BOTTOM),
/* harmony export */   VA: () => (/* binding */ BOX_WIDGET_LOCATION_TOP_LEFT),
/* harmony export */   Vl: () => (/* binding */ ConsentTab),
/* harmony export */   Y4: () => (/* binding */ PANEL_COOKIES_TAB),
/* harmony export */   YI: () => (/* binding */ PANEL_POLICY_TAB),
/* harmony export */   ZJ: () => (/* binding */ CONTINUE_BTN_STYLE_X_BTN_SECONDARY),
/* harmony export */   bD: () => (/* binding */ CONTINUE_BTN_STYLE_X_BTN),
/* harmony export */   bl: () => (/* binding */ PANEL_SETTINGS_TAB),
/* harmony export */   cK: () => (/* binding */ CONTINUE_BTN_STYLE_BUTTON_SECONDARY),
/* harmony export */   gK: () => (/* binding */ WidgetLocations),
/* harmony export */   j9: () => (/* binding */ CONTINUE_BTN_STYLE_BUTTON_PRIMARY),
/* harmony export */   mY: () => (/* binding */ CONTINUE_BTN_STYLE_DISABLED),
/* harmony export */   nv: () => (/* binding */ WIDGET_TYPE_BANNER),
/* harmony export */   ow: () => (/* binding */ PANEL_DATA_TAB),
/* harmony export */   x_: () => (/* binding */ BOX_WIDGET_LOCATION_TOP_RIGHT)
/* harmony export */ });
/* unused harmony exports BOX_WIDGET_LOCATION_CENTER_CENTER, BOX_WIDGET_LOCATIONS, BANNER_WIDGET_LOCATION_TOP, PANEL_VENDORS_TAB */
const WIDGET_TYPE_BOX="box";const WIDGET_TYPE_BANNER="banner";const BOX_WIDGET_LOCATION_TOP_LEFT="top-left";const BOX_WIDGET_LOCATION_TOP_RIGHT="top-right";const BOX_WIDGET_LOCATION_BOTTOM_LEFT="bottom-left";const BOX_WIDGET_LOCATION_BOTTOM_RIGHT="bottom-right";const BOX_WIDGET_LOCATION_CENTER_CENTER="center-center";const BOX_WIDGET_LOCATIONS=[BOX_WIDGET_LOCATION_TOP_LEFT,BOX_WIDGET_LOCATION_TOP_RIGHT,BOX_WIDGET_LOCATION_BOTTOM_LEFT,BOX_WIDGET_LOCATION_BOTTOM_RIGHT,BOX_WIDGET_LOCATION_CENTER_CENTER];const BANNER_WIDGET_LOCATION_TOP="top";const BANNER_WIDGET_LOCATION_BOTTOM="bottom";const WidgetLocations={[WIDGET_TYPE_BOX]:BOX_WIDGET_LOCATIONS,[WIDGET_TYPE_BANNER]:[BANNER_WIDGET_LOCATION_TOP,BANNER_WIDGET_LOCATION_BOTTOM]};const PANEL_SETTINGS_TAB="settings";const PANEL_COOKIES_TAB="cookies";const PANEL_POLICY_TAB="policy";const PANEL_DATA_TAB="data";const PANEL_VENDORS_TAB="vendors";let ConsentTab=/*#__PURE__*/function(ConsentTab){ConsentTab["CATEGORIES"]="categories";ConsentTab["VENDORS"]="vendors";return ConsentTab;}({});const CONTINUE_BTN_STYLE_X_BTN="x_sign";const CONTINUE_BTN_STYLE_X_BTN_SECONDARY="x_sign_secondary";const CONTINUE_BTN_STYLE_X_ONLY="x_icon_only";const CONTINUE_BTN_STYLE_BUTTON_PRIMARY="button";const CONTINUE_BTN_STYLE_BUTTON_SECONDARY="button_secondary";const CONTINUE_BTN_STYLE_LINK="link";const CONTINUE_BTN_STYLE_DISABLED="disabled";

/***/ }),

/***/ 5304:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Gc: () => (/* binding */ CONSENT_POLICY_GRANULAR_OPTIN),
/* harmony export */   LV: () => (/* binding */ CONSENT_TYPE_CATEGORY),
/* harmony export */   an: () => (/* binding */ CONSENT_TYPE_GRANULAR),
/* harmony export */   gl: () => (/* binding */ CONSENT_ACTION_UPDATE),
/* harmony export */   hs: () => (/* binding */ CONSENT_POLICY_CATEGORY_OPTIN),
/* harmony export */   mX: () => (/* binding */ CONSENT_ACTION_STORE),
/* harmony export */   qD: () => (/* binding */ CONSENT_ACTION_WITHDRAW),
/* harmony export */   sD: () => (/* binding */ CONSENT_ACTION_RESET)
/* harmony export */ });
/* unused harmony export CONSENT_ACTION_DENY */
const CONSENT_TYPE_CATEGORY="category";const CONSENT_TYPE_GRANULAR="granular";const CONSENT_POLICY_CATEGORY_OPTIN=1;const CONSENT_POLICY_GRANULAR_OPTIN=2;const CONSENT_ACTION_DENY="deny";const CONSENT_ACTION_STORE="store";const CONSENT_ACTION_UPDATE="update";const CONSENT_ACTION_WITHDRAW="withdraw";const CONSENT_ACTION_RESET="reset";

/***/ }),

/***/ 1873:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   I$: () => (/* binding */ SCRIPT_INTEGRATION_METHOD_GTM_LOAD),
/* harmony export */   Ko: () => (/* binding */ SCRIPT_INTEGRATION_METHOD_MANUAL),
/* harmony export */   QE: () => (/* binding */ SCRIPT_INTEGRATION_METHOD_EDIT_CURRENT),
/* harmony export */   "if": () => (/* binding */ SCRIPT_INTEGRATION_METHOD_AUTOBLOCK),
/* harmony export */   yj: () => (/* binding */ SCRIPT_INTEGRATION_METHOD_BANNER_LOAD)
/* harmony export */ });
const SCRIPT_INTEGRATION_METHOD_BANNER_LOAD="banner_load";const SCRIPT_INTEGRATION_METHOD_EDIT_CURRENT="edit";const SCRIPT_INTEGRATION_METHOD_GTM_LOAD="gtm_load";const SCRIPT_INTEGRATION_METHOD_AUTOBLOCK="autoblock";const SCRIPT_INTEGRATION_METHOD_MANUAL="manual";

/***/ }),

/***/ 3987:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HY: () => (/* binding */ k),
/* harmony export */   Tm: () => (/* binding */ F),
/* harmony export */   Vf: () => (/* binding */ _),
/* harmony export */   YM: () => (/* binding */ l),
/* harmony export */   ZB: () => (/* binding */ E),
/* harmony export */   az: () => (/* binding */ y),
/* harmony export */   bR: () => (/* binding */ C),
/* harmony export */   kr: () => (/* binding */ G),
/* harmony export */   sY: () => (/* binding */ D),
/* harmony export */   wA: () => (/* binding */ b)
/* harmony export */ });
/* unused harmony exports h, isValidElement */
var n,
  l,
  u,
  t,
  i,
  o,
  r,
  f,
  e,
  c = {},
  s = [],
  a = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i,
  h = Array.isArray;
function v(n, l) {
  for (var u in l) n[u] = l[u];
  return n;
}
function p(n) {
  var l = n.parentNode;
  l && l.removeChild(n);
}
function y(l, u, t) {
  var i,
    o,
    r,
    f = {};
  for (r in u) "key" == r ? i = u[r] : "ref" == r ? o = u[r] : f[r] = u[r];
  if (arguments.length > 2 && (f.children = arguments.length > 3 ? n.call(arguments, 2) : t), "function" == typeof l && null != l.defaultProps) for (r in l.defaultProps) void 0 === f[r] && (f[r] = l.defaultProps[r]);
  return d(l, f, i, o, null);
}
function d(n, t, i, o, r) {
  var f = {
    type: n,
    props: t,
    key: i,
    ref: o,
    __k: null,
    __: null,
    __b: 0,
    __e: null,
    __d: void 0,
    __c: null,
    __h: null,
    constructor: void 0,
    __v: null == r ? ++u : r
  };
  return null == r && null != l.vnode && l.vnode(f), f;
}
function _() {
  return {
    current: null
  };
}
function k(n) {
  return n.children;
}
function b(n, l) {
  this.props = n, this.context = l;
}
function g(n, l) {
  if (null == l) return n.__ ? g(n.__, n.__.__k.indexOf(n) + 1) : null;
  for (var u; l < n.__k.length; l++) if (null != (u = n.__k[l]) && null != u.__e) return u.__e;
  return "function" == typeof n.type ? g(n) : null;
}
function m(n) {
  var l, u;
  if (null != (n = n.__) && null != n.__c) {
    for (n.__e = n.__c.base = null, l = 0; l < n.__k.length; l++) if (null != (u = n.__k[l]) && null != u.__e) {
      n.__e = n.__c.base = u.__e;
      break;
    }
    return m(n);
  }
}
function w(n) {
  (!n.__d && (n.__d = !0) && i.push(n) && !x.__r++ || o !== l.debounceRendering) && ((o = l.debounceRendering) || r)(x);
}
function x() {
  var n, l, u, t, o, r, e, c, s;
  for (i.sort(f); n = i.shift();) n.__d && (l = i.length, t = void 0, o = void 0, r = void 0, c = (e = (u = n).__v).__e, (s = u.__P) && (t = [], o = [], (r = v({}, e)).__v = e.__v + 1, L(s, e, r, u.__n, void 0 !== s.ownerSVGElement, null != e.__h ? [c] : null, t, null == c ? g(e) : c, e.__h, o), M(t, e, o), e.__e != c && m(e)), i.length > l && i.sort(f));
  x.__r = 0;
}
function P(n, l, u, t, i, o, r, f, e, a, v) {
  var p,
    y,
    _,
    b,
    m,
    w,
    x,
    P,
    C,
    H = 0,
    I = t && t.__k || s,
    T = I.length,
    j = T,
    z = l.length;
  for (u.__k = [], p = 0; p < z; p++) null != (b = u.__k[p] = null == (b = l[p]) || "boolean" == typeof b || "function" == typeof b ? null : "string" == typeof b || "number" == typeof b || "bigint" == typeof b ? d(null, b, null, null, b) : h(b) ? d(k, {
    children: b
  }, null, null, null) : b.__b > 0 ? d(b.type, b.props, b.key, b.ref ? b.ref : null, b.__v) : b) ? (b.__ = u, b.__b = u.__b + 1, -1 === (P = A(b, I, x = p + H, j)) ? _ = c : (_ = I[P] || c, I[P] = void 0, j--), L(n, b, _, i, o, r, f, e, a, v), m = b.__e, (y = b.ref) && _.ref != y && (_.ref && O(_.ref, null, b), v.push(y, b.__c || m, b)), null != m && (null == w && (w = m), (C = _ === c || null === _.__v) ? -1 == P && H-- : P !== x && (P === x + 1 ? H++ : P > x ? j > z - x ? H += P - x : H-- : H = P < x && P == x - 1 ? P - x : 0), x = p + H, "function" != typeof b.type || P === x && _.__k !== b.__k ? "function" == typeof b.type || P === x && !C ? void 0 !== b.__d ? (e = b.__d, b.__d = void 0) : e = m.nextSibling : e = S(n, m, e) : e = $(b, e, n), "function" == typeof u.type && (u.__d = e))) : (_ = I[p]) && null == _.key && _.__e && (_.__e == e && (e = g(_)), q(_, _, !1), I[p] = null);
  for (u.__e = w, p = T; p--;) null != I[p] && ("function" == typeof u.type && null != I[p].__e && I[p].__e == u.__d && (u.__d = I[p].__e.nextSibling), q(I[p], I[p]));
}
function $(n, l, u) {
  for (var t, i = n.__k, o = 0; i && o < i.length; o++) (t = i[o]) && (t.__ = n, l = "function" == typeof t.type ? $(t, l, u) : S(u, t.__e, l));
  return l;
}
function C(n, l) {
  return l = l || [], null == n || "boolean" == typeof n || (h(n) ? n.some(function (n) {
    C(n, l);
  }) : l.push(n)), l;
}
function S(n, l, u) {
  return null == u || u.parentNode !== n ? n.insertBefore(l, null) : l == u && null != l.parentNode || n.insertBefore(l, u), l.nextSibling;
}
function A(n, l, u, t) {
  var i = n.key,
    o = n.type,
    r = u - 1,
    f = u + 1,
    e = l[u];
  if (null === e || e && i == e.key && o === e.type) return u;
  if (t > (null != e ? 1 : 0)) for (; r >= 0 || f < l.length;) {
    if (r >= 0) {
      if ((e = l[r]) && i == e.key && o === e.type) return r;
      r--;
    }
    if (f < l.length) {
      if ((e = l[f]) && i == e.key && o === e.type) return f;
      f++;
    }
  }
  return -1;
}
function H(n, l, u, t, i) {
  var o;
  for (o in u) "children" === o || "key" === o || o in l || T(n, o, null, u[o], t);
  for (o in l) i && "function" != typeof l[o] || "children" === o || "key" === o || "value" === o || "checked" === o || u[o] === l[o] || T(n, o, l[o], u[o], t);
}
function I(n, l, u) {
  "-" === l[0] ? n.setProperty(l, null == u ? "" : u) : n[l] = null == u ? "" : "number" != typeof u || a.test(l) ? u : u + "px";
}
function T(n, l, u, t, i) {
  var o;
  n: if ("style" === l) {
    if ("string" == typeof u) n.style.cssText = u;else {
      if ("string" == typeof t && (n.style.cssText = t = ""), t) for (l in t) u && l in u || I(n.style, l, "");
      if (u) for (l in u) t && u[l] === t[l] || I(n.style, l, u[l]);
    }
  } else if ("o" === l[0] && "n" === l[1]) o = l !== (l = l.replace(/(PointerCapture)$|Capture$/, "$1")), l = l.toLowerCase() in n ? l.toLowerCase().slice(2) : l.slice(2), n.l || (n.l = {}), n.l[l + o] = u, u ? t || n.addEventListener(l, o ? z : j, o) : n.removeEventListener(l, o ? z : j, o);else if ("dangerouslySetInnerHTML" !== l) {
    if (i) l = l.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");else if ("width" !== l && "height" !== l && "href" !== l && "list" !== l && "form" !== l && "tabIndex" !== l && "download" !== l && "rowSpan" !== l && "colSpan" !== l && l in n) try {
      n[l] = null == u ? "" : u;
      break n;
    } catch (n) {}
    "function" == typeof u || (null == u || !1 === u && "-" !== l[4] ? n.removeAttribute(l) : n.setAttribute(l, u));
  }
}
function j(n) {
  return this.l[n.type + !1](l.event ? l.event(n) : n);
}
function z(n) {
  return this.l[n.type + !0](l.event ? l.event(n) : n);
}
function L(n, u, t, i, o, r, f, e, c, s) {
  var a,
    p,
    y,
    d,
    _,
    g,
    m,
    w,
    x,
    $,
    C,
    S,
    A,
    H,
    I,
    T = u.type;
  if (void 0 !== u.constructor) return null;
  null != t.__h && (c = t.__h, e = u.__e = t.__e, u.__h = null, r = [e]), (a = l.__b) && a(u);
  n: if ("function" == typeof T) try {
    if (w = u.props, x = (a = T.contextType) && i[a.__c], $ = a ? x ? x.props.value : a.__ : i, t.__c ? m = (p = u.__c = t.__c).__ = p.__E : ("prototype" in T && T.prototype.render ? u.__c = p = new T(w, $) : (u.__c = p = new b(w, $), p.constructor = T, p.render = B), x && x.sub(p), p.props = w, p.state || (p.state = {}), p.context = $, p.__n = i, y = p.__d = !0, p.__h = [], p._sb = []), null == p.__s && (p.__s = p.state), null != T.getDerivedStateFromProps && (p.__s == p.state && (p.__s = v({}, p.__s)), v(p.__s, T.getDerivedStateFromProps(w, p.__s))), d = p.props, _ = p.state, p.__v = u, y) null == T.getDerivedStateFromProps && null != p.componentWillMount && p.componentWillMount(), null != p.componentDidMount && p.__h.push(p.componentDidMount);else {
      if (null == T.getDerivedStateFromProps && w !== d && null != p.componentWillReceiveProps && p.componentWillReceiveProps(w, $), !p.__e && (null != p.shouldComponentUpdate && !1 === p.shouldComponentUpdate(w, p.__s, $) || u.__v === t.__v)) {
        for (u.__v !== t.__v && (p.props = w, p.state = p.__s, p.__d = !1), u.__e = t.__e, u.__k = t.__k, u.__k.forEach(function (n) {
          n && (n.__ = u);
        }), C = 0; C < p._sb.length; C++) p.__h.push(p._sb[C]);
        p._sb = [], p.__h.length && f.push(p);
        break n;
      }
      null != p.componentWillUpdate && p.componentWillUpdate(w, p.__s, $), null != p.componentDidUpdate && p.__h.push(function () {
        p.componentDidUpdate(d, _, g);
      });
    }
    if (p.context = $, p.props = w, p.__P = n, p.__e = !1, S = l.__r, A = 0, "prototype" in T && T.prototype.render) {
      for (p.state = p.__s, p.__d = !1, S && S(u), a = p.render(p.props, p.state, p.context), H = 0; H < p._sb.length; H++) p.__h.push(p._sb[H]);
      p._sb = [];
    } else do {
      p.__d = !1, S && S(u), a = p.render(p.props, p.state, p.context), p.state = p.__s;
    } while (p.__d && ++A < 25);
    p.state = p.__s, null != p.getChildContext && (i = v(v({}, i), p.getChildContext())), y || null == p.getSnapshotBeforeUpdate || (g = p.getSnapshotBeforeUpdate(d, _)), P(n, h(I = null != a && a.type === k && null == a.key ? a.props.children : a) ? I : [I], u, t, i, o, r, f, e, c, s), p.base = u.__e, u.__h = null, p.__h.length && f.push(p), m && (p.__E = p.__ = null);
  } catch (n) {
    u.__v = null, (c || null != r) && (u.__e = e, u.__h = !!c, r[r.indexOf(e)] = null), l.__e(n, u, t);
  } else null == r && u.__v === t.__v ? (u.__k = t.__k, u.__e = t.__e) : u.__e = N(t.__e, u, t, i, o, r, f, c, s);
  (a = l.diffed) && a(u);
}
function M(n, u, t) {
  for (var i = 0; i < t.length; i++) O(t[i], t[++i], t[++i]);
  l.__c && l.__c(u, n), n.some(function (u) {
    try {
      n = u.__h, u.__h = [], n.some(function (n) {
        n.call(u);
      });
    } catch (n) {
      l.__e(n, u.__v);
    }
  });
}
function N(l, u, t, i, o, r, f, e, s) {
  var a,
    v,
    y,
    d = t.props,
    _ = u.props,
    k = u.type,
    b = 0;
  if ("svg" === k && (o = !0), null != r) for (; b < r.length; b++) if ((a = r[b]) && "setAttribute" in a == !!k && (k ? a.localName === k : 3 === a.nodeType)) {
    l = a, r[b] = null;
    break;
  }
  if (null == l) {
    if (null === k) return document.createTextNode(_);
    l = o ? document.createElementNS("http://www.w3.org/2000/svg", k) : document.createElement(k, _.is && _), r = null, e = !1;
  }
  if (null === k) d === _ || e && l.data === _ || (l.data = _);else {
    if (r = r && n.call(l.childNodes), v = (d = t.props || c).dangerouslySetInnerHTML, y = _.dangerouslySetInnerHTML, !e) {
      if (null != r) for (d = {}, b = 0; b < l.attributes.length; b++) d[l.attributes[b].name] = l.attributes[b].value;
      (y || v) && (y && (v && y.__html == v.__html || y.__html === l.innerHTML) || (l.innerHTML = y && y.__html || ""));
    }
    if (H(l, _, d, o, e), y) u.__k = [];else if (P(l, h(b = u.props.children) ? b : [b], u, t, i, o && "foreignObject" !== k, r, f, r ? r[0] : t.__k && g(t, 0), e, s), null != r) for (b = r.length; b--;) null != r[b] && p(r[b]);
    e || ("value" in _ && void 0 !== (b = _.value) && (b !== l.value || "progress" === k && !b || "option" === k && b !== d.value) && T(l, "value", b, d.value, !1), "checked" in _ && void 0 !== (b = _.checked) && b !== l.checked && T(l, "checked", b, d.checked, !1));
  }
  return l;
}
function O(n, u, t) {
  try {
    "function" == typeof n ? n(u) : n.current = u;
  } catch (n) {
    l.__e(n, t);
  }
}
function q(n, u, t) {
  var i, o;
  if (l.unmount && l.unmount(n), (i = n.ref) && (i.current && i.current !== n.__e || O(i, null, u)), null != (i = n.__c)) {
    if (i.componentWillUnmount) try {
      i.componentWillUnmount();
    } catch (n) {
      l.__e(n, u);
    }
    i.base = i.__P = null, n.__c = void 0;
  }
  if (i = n.__k) for (o = 0; o < i.length; o++) i[o] && q(i[o], u, t || "function" != typeof n.type);
  t || null == n.__e || p(n.__e), n.__ = n.__e = n.__d = void 0;
}
function B(n, l, u) {
  return this.constructor(n, u);
}
function D(u, t, i) {
  var o, r, f, e;
  l.__ && l.__(u, t), r = (o = "function" == typeof i) ? null : i && i.__k || t.__k, f = [], e = [], L(t, u = (!o && i || t).__k = y(k, null, [u]), r || c, c, void 0 !== t.ownerSVGElement, !o && i ? [i] : r ? null : t.firstChild ? n.call(t.childNodes) : null, f, !o && i ? i : r ? r.__e : t.firstChild, o, e), M(f, u, e);
}
function E(n, l) {
  D(n, l, E);
}
function F(l, u, t) {
  var i,
    o,
    r,
    f,
    e = v({}, l.props);
  for (r in l.type && l.type.defaultProps && (f = l.type.defaultProps), u) "key" == r ? i = u[r] : "ref" == r ? o = u[r] : e[r] = void 0 === u[r] && void 0 !== f ? f[r] : u[r];
  return arguments.length > 2 && (e.children = arguments.length > 3 ? n.call(arguments, 2) : t), d(l.type, e, i || l.key, o || l.ref, null);
}
function G(n, l) {
  var u = {
    __c: l = "__cC" + e++,
    __: n,
    Consumer: function (n, l) {
      return n.children(l);
    },
    Provider: function (n) {
      var u, t;
      return this.getChildContext || (u = [], (t = {})[l] = this, this.getChildContext = function () {
        return t;
      }, this.shouldComponentUpdate = function (n) {
        this.props.value !== n.value && u.some(function (n) {
          n.__e = !0, w(n);
        });
      }, this.sub = function (n) {
        u.push(n);
        var l = n.componentWillUnmount;
        n.componentWillUnmount = function () {
          u.splice(u.indexOf(n), 1), l && l.call(n);
        };
      }), n.children;
    }
  };
  return u.Provider.__ = u.Consumer.contextType = u;
}
n = s.slice, l = {
  __e: function (n, l, u, t) {
    for (var i, o, r; l = l.__;) if ((i = l.__c) && !i.__) try {
      if ((o = i.constructor) && null != o.getDerivedStateFromError && (i.setState(o.getDerivedStateFromError(n)), r = i.__d), null != i.componentDidCatch && (i.componentDidCatch(n, t || {}), r = i.__d), r) return i.__E = i;
    } catch (l) {
      n = l;
    }
    throw n;
  }
}, u = 0, t = function (n) {
  return null != n && void 0 === n.constructor;
}, b.prototype.setState = function (n, l) {
  var u;
  u = null != this.__s && this.__s !== this.state ? this.__s : this.__s = v({}, this.state), "function" == typeof n && (n = n(v({}, u), this.props)), n && v(u, n), null != n && this.__v && (l && this._sb.push(l), w(this));
}, b.prototype.forceUpdate = function (n) {
  this.__v && (this.__e = !0, n && this.__h.push(n), w(this));
}, b.prototype.render = k, i = [], r = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, f = function (n, l) {
  return n.__v.__b - l.__v.__b;
}, x.__r = 0, e = 0;

//# sourceMappingURL=preact.module.js.map

/***/ }),

/***/ 6075:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   I4: () => (/* binding */ T),
/* harmony export */   Me: () => (/* binding */ V),
/* harmony export */   Qb: () => (/* binding */ x),
/* harmony export */   Ye: () => (/* binding */ F),
/* harmony export */   _Y: () => (/* binding */ s),
/* harmony export */   aP: () => (/* binding */ A),
/* harmony export */   bt: () => (/* binding */ y),
/* harmony export */   d4: () => (/* binding */ p),
/* harmony export */   eJ: () => (/* binding */ h),
/* harmony export */   qp: () => (/* binding */ q),
/* harmony export */   sO: () => (/* binding */ _)
/* harmony export */ });
/* unused harmony export useErrorBoundary */
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3987);

var t,
  r,
  u,
  i,
  o = 0,
  f = [],
  c = [],
  e = preact__WEBPACK_IMPORTED_MODULE_0__/* .options */ .YM.__b,
  a = preact__WEBPACK_IMPORTED_MODULE_0__/* .options */ .YM.__r,
  v = preact__WEBPACK_IMPORTED_MODULE_0__/* .options */ .YM.diffed,
  l = preact__WEBPACK_IMPORTED_MODULE_0__/* .options */ .YM.__c,
  m = preact__WEBPACK_IMPORTED_MODULE_0__/* .options */ .YM.unmount;
function d(t, u) {
  preact__WEBPACK_IMPORTED_MODULE_0__/* .options */ .YM.__h && preact__WEBPACK_IMPORTED_MODULE_0__/* .options */ .YM.__h(r, t, o || u), o = 0;
  var i = r.__H || (r.__H = {
    __: [],
    __h: []
  });
  return t >= i.__.length && i.__.push({
    __V: c
  }), i.__[t];
}
function h(n) {
  return o = 1, s(B, n);
}
function s(n, u, i) {
  var o = d(t++, 2);
  if (o.t = n, !o.__c && (o.__ = [i ? i(u) : B(void 0, u), function (n) {
    var t = o.__N ? o.__N[0] : o.__[0],
      r = o.t(t, n);
    t !== r && (o.__N = [r, o.__[1]], o.__c.setState({}));
  }], o.__c = r, !r.u)) {
    var f = function (n, t, r) {
      if (!o.__c.__H) return !0;
      var u = o.__c.__H.__.filter(function (n) {
        return n.__c;
      });
      if (u.every(function (n) {
        return !n.__N;
      })) return !c || c.call(this, n, t, r);
      var i = !1;
      return u.forEach(function (n) {
        if (n.__N) {
          var t = n.__[0];
          n.__ = n.__N, n.__N = void 0, t !== n.__[0] && (i = !0);
        }
      }), !(!i && o.__c.props === n) && (!c || c.call(this, n, t, r));
    };
    r.u = !0;
    var c = r.shouldComponentUpdate,
      e = r.componentWillUpdate;
    r.componentWillUpdate = function (n, t, r) {
      if (this.__e) {
        var u = c;
        c = void 0, f(n, t, r), c = u;
      }
      e && e.call(this, n, t, r);
    }, r.shouldComponentUpdate = f;
  }
  return o.__N || o.__;
}
function p(u, i) {
  var o = d(t++, 3);
  !preact__WEBPACK_IMPORTED_MODULE_0__/* .options */ .YM.__s && z(o.__H, i) && (o.__ = u, o.i = i, r.__H.__h.push(o));
}
function y(u, i) {
  var o = d(t++, 4);
  !preact__WEBPACK_IMPORTED_MODULE_0__/* .options */ .YM.__s && z(o.__H, i) && (o.__ = u, o.i = i, r.__h.push(o));
}
function _(n) {
  return o = 5, F(function () {
    return {
      current: n
    };
  }, []);
}
function A(n, t, r) {
  o = 6, y(function () {
    return "function" == typeof n ? (n(t()), function () {
      return n(null);
    }) : n ? (n.current = t(), function () {
      return n.current = null;
    }) : void 0;
  }, null == r ? r : r.concat(n));
}
function F(n, r) {
  var u = d(t++, 7);
  return z(u.__H, r) ? (u.__V = n(), u.i = r, u.__h = n, u.__V) : u.__;
}
function T(n, t) {
  return o = 8, F(function () {
    return n;
  }, t);
}
function q(n) {
  var u = r.context[n.__c],
    i = d(t++, 9);
  return i.c = n, u ? (null == i.__ && (i.__ = !0, u.sub(r)), u.props.value) : n.__;
}
function x(t, r) {
  preact__WEBPACK_IMPORTED_MODULE_0__/* .options */ .YM.useDebugValue && preact__WEBPACK_IMPORTED_MODULE_0__/* .options */ .YM.useDebugValue(r ? r(t) : t);
}
function P(n) {
  var u = d(t++, 10),
    i = h();
  return u.__ = n, r.componentDidCatch || (r.componentDidCatch = function (n, t) {
    u.__ && u.__(n, t), i[1](n);
  }), [i[0], function () {
    i[1](void 0);
  }];
}
function V() {
  var n = d(t++, 11);
  if (!n.__) {
    for (var u = r.__v; null !== u && !u.__m && null !== u.__;) u = u.__;
    var i = u.__m || (u.__m = [0, 0]);
    n.__ = "P" + i[0] + "-" + i[1]++;
  }
  return n.__;
}
function b() {
  for (var t; t = f.shift();) if (t.__P && t.__H) try {
    t.__H.__h.forEach(k), t.__H.__h.forEach(w), t.__H.__h = [];
  } catch (r) {
    t.__H.__h = [], preact__WEBPACK_IMPORTED_MODULE_0__/* .options */ .YM.__e(r, t.__v);
  }
}
preact__WEBPACK_IMPORTED_MODULE_0__/* .options */ .YM.__b = function (n) {
  r = null, e && e(n);
}, preact__WEBPACK_IMPORTED_MODULE_0__/* .options */ .YM.__r = function (n) {
  a && a(n), t = 0;
  var i = (r = n.__c).__H;
  i && (u === r ? (i.__h = [], r.__h = [], i.__.forEach(function (n) {
    n.__N && (n.__ = n.__N), n.__V = c, n.__N = n.i = void 0;
  })) : (i.__h.forEach(k), i.__h.forEach(w), i.__h = [], t = 0)), u = r;
}, preact__WEBPACK_IMPORTED_MODULE_0__/* .options */ .YM.diffed = function (t) {
  v && v(t);
  var o = t.__c;
  o && o.__H && (o.__H.__h.length && (1 !== f.push(o) && i === preact__WEBPACK_IMPORTED_MODULE_0__/* .options */ .YM.requestAnimationFrame || ((i = preact__WEBPACK_IMPORTED_MODULE_0__/* .options */ .YM.requestAnimationFrame) || j)(b)), o.__H.__.forEach(function (n) {
    n.i && (n.__H = n.i), n.__V !== c && (n.__ = n.__V), n.i = void 0, n.__V = c;
  })), u = r = null;
}, preact__WEBPACK_IMPORTED_MODULE_0__/* .options */ .YM.__c = function (t, r) {
  r.some(function (t) {
    try {
      t.__h.forEach(k), t.__h = t.__h.filter(function (n) {
        return !n.__ || w(n);
      });
    } catch (u) {
      r.some(function (n) {
        n.__h && (n.__h = []);
      }), r = [], preact__WEBPACK_IMPORTED_MODULE_0__/* .options */ .YM.__e(u, t.__v);
    }
  }), l && l(t, r);
}, preact__WEBPACK_IMPORTED_MODULE_0__/* .options */ .YM.unmount = function (t) {
  m && m(t);
  var r,
    u = t.__c;
  u && u.__H && (u.__H.__.forEach(function (n) {
    try {
      k(n);
    } catch (n) {
      r = n;
    }
  }), u.__H = void 0, r && preact__WEBPACK_IMPORTED_MODULE_0__/* .options */ .YM.__e(r, u.__v));
};
var g = "function" == typeof requestAnimationFrame;
function j(n) {
  var t,
    r = function () {
      clearTimeout(u), g && cancelAnimationFrame(t), setTimeout(n);
    },
    u = setTimeout(r, 100);
  g && (t = requestAnimationFrame(r));
}
function k(n) {
  var t = r,
    u = n.__c;
  "function" == typeof u && (n.__c = void 0, u()), r = t;
}
function w(n) {
  var t = r;
  n.__c = n.__(), r = t;
}
function z(n, t) {
  return !n || n.length !== t.length || t.some(function (t, r) {
    return t !== n[r];
  });
}
function B(n, t) {
  return "function" == typeof t ? t(n) : t;
}

//# sourceMappingURL=hooks.module.js.map

/***/ }),

/***/ 8089:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BX: () => (/* binding */ o),
/* harmony export */   HY: () => (/* reexport safe */ preact__WEBPACK_IMPORTED_MODULE_0__.HY),
/* harmony export */   tZ: () => (/* binding */ o)
/* harmony export */ });
/* unused harmony export jsxDEV */
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3987);


var _ = 0;
function o(o, e, n, t, f, l) {
  var s,
    u,
    a = {};
  for (u in e) "ref" == u ? s = e[u] : a[u] = e[u];
  var i = {
    type: o,
    props: a,
    key: n,
    ref: s,
    __k: null,
    __: null,
    __b: 0,
    __e: null,
    __d: void 0,
    __c: null,
    __h: null,
    constructor: void 0,
    __v: --_,
    __source: f,
    __self: l
  };
  if ("function" == typeof o && (s = o.defaultProps)) for (u in s) void 0 === a[u] && (a[u] = s[u]);
  return preact__WEBPACK_IMPORTED_MODULE_0__/* .options */ .YM.vnode && preact__WEBPACK_IMPORTED_MODULE_0__/* .options */ .YM.vnode(i), i;
}

//# sourceMappingURL=jsxRuntime.module.js.map

/***/ }),

/***/ 9553:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Ew: () => (/* reexport */ GVL),
  gI: () => (/* reexport */ TCModel),
  E9: () => (/* reexport */ TCString)
});

// UNUSED EXPORTS: Base64Url, BitLength, BooleanEncoder, Cloneable, ConsentLanguages, DateEncoder, DecodingError, DeviceDisclosureStorageAccessType, EncodingError, FieldEncoderMap, FieldSequence, Fields, FixedVectorEncoder, GVLError, IntEncoder, Json, LangEncoder, PurposeRestriction, PurposeRestrictionVector, PurposeRestrictionVectorEncoder, RestrictionType, Segment, SegmentEncoder, SegmentIDs, SegmentSequence, SemanticPreEncoder, TCModelError, Vector, VectorEncodingType, VendorVectorEncoder

;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toPrimitive.js

function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js


function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js

function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
;// CONCATENATED MODULE: ./node_modules/@iabtechlabtcf/core/lib/mjs/errors/EncodingError.js
/**
 * class for encoding errors
 *
 * @extends {Error}
 */
class EncodingError extends Error {
  /**
   * constructor - constructs an EncodingError
   *
   * @param {string} msg - Encoding Error Message
   * @return {undefined}
   */
  constructor(msg) {
    super(msg);
    this.name = 'EncodingError';
  }
}

;// CONCATENATED MODULE: ./node_modules/@iabtechlabtcf/core/lib/mjs/errors/DecodingError.js
/**
 * class for decoding errors
 *
 * @extends {Error}
 */
class DecodingError extends Error {
  /**
   * constructor - constructs an DecodingError
   *
   * @param {string} msg - Decoding Error Message
   * @return {undefined}
   */
  constructor(msg) {
    super(msg);
    this.name = 'DecodingError';
  }
}

;// CONCATENATED MODULE: ./node_modules/@iabtechlabtcf/core/lib/mjs/encoder/Base64Url.js


class Base64Url {
  /**
   * encodes an arbitrary-length bitfield string into base64url
   *
   * @static
   * @param {string} str - arbitrary-length bitfield string to be encoded to base64url
   * @return {string} - base64url encoded result
   */
  static encode(str) {
    /**
     * should only be 0 or 1
     */
    if (!/^[0-1]+$/.test(str)) {
      throw new EncodingError('Invalid bitField');
    }
    /**
     * Pad the end of the string to the least common mutliple of 6 (basis for
     * base64) and 8 (one byte)
     */
    const padding = str.length % this.LCM;
    str += padding ? '0'.repeat(this.LCM - padding) : '';
    let result = '';
    for (let i = 0; i < str.length; i += this.BASIS) {
      result += this.DICT[parseInt(str.substr(i, this.BASIS), 2)];
    }
    return result;
  }
  /**
   * decodes a base64url encoded bitfield string
   *
   * @static
   * @param {string} str - base64url encoded bitfield string to be decoded
   * @return {string} - bitfield string
   */
  static decode(str) {
    /**
     * should contain only characters from the base64url set
     */
    if (!/^[A-Za-z0-9\-_]+$/.test(str)) {
      throw new DecodingError('Invalidly encoded Base64URL string');
    }
    let result = '';
    for (let i = 0; i < str.length; i++) {
      /**
       * index the binary value of the character from out reverse map
       */
      const strBits = this.REVERSE_DICT.get(str[i]).toString(2);
      /**
       * Since a bit string converted to an integer on encoding will lose
       * leading zeros – pad to the left for those missing leading zeros
       */
      result += '0'.repeat(this.BASIS - strBits.length) + strBits;
    }
    return result;
  }
}
/**
 * Base 64 URL character set.  Different from standard Base64 char set
 * in that '+' and '/' are replaced with '-' and '_'.
 */
_defineProperty(Base64Url, "DICT", 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_');
_defineProperty(Base64Url, "REVERSE_DICT", new Map([['A', 0], ['B', 1], ['C', 2], ['D', 3], ['E', 4], ['F', 5], ['G', 6], ['H', 7], ['I', 8], ['J', 9], ['K', 10], ['L', 11], ['M', 12], ['N', 13], ['O', 14], ['P', 15], ['Q', 16], ['R', 17], ['S', 18], ['T', 19], ['U', 20], ['V', 21], ['W', 22], ['X', 23], ['Y', 24], ['Z', 25], ['a', 26], ['b', 27], ['c', 28], ['d', 29], ['e', 30], ['f', 31], ['g', 32], ['h', 33], ['i', 34], ['j', 35], ['k', 36], ['l', 37], ['m', 38], ['n', 39], ['o', 40], ['p', 41], ['q', 42], ['r', 43], ['s', 44], ['t', 45], ['u', 46], ['v', 47], ['w', 48], ['x', 49], ['y', 50], ['z', 51], ['0', 52], ['1', 53], ['2', 54], ['3', 55], ['4', 56], ['5', 57], ['6', 58], ['7', 59], ['8', 60], ['9', 61], ['-', 62], ['_', 63]]));
/**
 * log2(64) = 6
 */
_defineProperty(Base64Url, "BASIS", 6);
_defineProperty(Base64Url, "LCM", 24);
;// CONCATENATED MODULE: ./node_modules/@iabtechlabtcf/core/lib/mjs/model/ConsentLanguages.js

class ConsentLanguages {
  has(key) {
    return ConsentLanguages.langSet.has(key);
  }
  parseLanguage(lang) {
    lang = lang.toUpperCase();
    const primaryLanguage = lang.split('-')[0];
    if (lang.length >= 2 && primaryLanguage.length == 2) {
      if (ConsentLanguages.langSet.has(lang)) {
        return lang;
      } else if (ConsentLanguages.langSet.has(primaryLanguage)) {
        return primaryLanguage;
      }
      const fullPrimaryLang = primaryLanguage + '-' + primaryLanguage;
      if (ConsentLanguages.langSet.has(fullPrimaryLang)) {
        return fullPrimaryLang;
      }
      for (const supportedLang of ConsentLanguages.langSet) {
        if (supportedLang.indexOf(lang) !== -1 || supportedLang.indexOf(primaryLanguage) !== -1) {
          return supportedLang;
        }
      }
    }
    throw new Error(`unsupported language ${lang}`);
  }
  forEach(callback) {
    ConsentLanguages.langSet.forEach(callback);
  }
  get size() {
    return ConsentLanguages.langSet.size;
  }
}
_defineProperty(ConsentLanguages, "langSet", new Set(['AR', 'BG', 'BS', 'CA', 'CS', 'DA', 'DE', 'EL', 'EN', 'ES', 'ET', 'EU', 'FI', 'FR', 'GL', 'HR', 'HU', 'IT', 'JA', 'LT', 'LV', 'MT', 'NL', 'NO', 'PL', 'PT-BR', 'PT-PT', 'RO', 'RU', 'SK', 'SL', 'SR-LATN', 'SR-CYRL', 'SV', 'TR', 'ZH']));
;// CONCATENATED MODULE: ./node_modules/@iabtechlabtcf/core/lib/mjs/model/Fields.js

class Fields {}
_defineProperty(Fields, "cmpId", 'cmpId');
_defineProperty(Fields, "cmpVersion", 'cmpVersion');
_defineProperty(Fields, "consentLanguage", 'consentLanguage');
_defineProperty(Fields, "consentScreen", 'consentScreen');
_defineProperty(Fields, "created", 'created');
_defineProperty(Fields, "supportOOB", 'supportOOB');
_defineProperty(Fields, "isServiceSpecific", 'isServiceSpecific');
_defineProperty(Fields, "lastUpdated", 'lastUpdated');
_defineProperty(Fields, "numCustomPurposes", 'numCustomPurposes');
_defineProperty(Fields, "policyVersion", 'policyVersion');
_defineProperty(Fields, "publisherCountryCode", 'publisherCountryCode');
_defineProperty(Fields, "publisherCustomConsents", 'publisherCustomConsents');
_defineProperty(Fields, "publisherCustomLegitimateInterests", 'publisherCustomLegitimateInterests');
_defineProperty(Fields, "publisherLegitimateInterests", 'publisherLegitimateInterests');
_defineProperty(Fields, "publisherConsents", 'publisherConsents');
_defineProperty(Fields, "publisherRestrictions", 'publisherRestrictions');
_defineProperty(Fields, "purposeConsents", 'purposeConsents');
_defineProperty(Fields, "purposeLegitimateInterests", 'purposeLegitimateInterests');
_defineProperty(Fields, "purposeOneTreatment", 'purposeOneTreatment');
_defineProperty(Fields, "specialFeatureOptins", 'specialFeatureOptins');
_defineProperty(Fields, "useNonStandardTexts", 'useNonStandardTexts');
_defineProperty(Fields, "vendorConsents", 'vendorConsents');
_defineProperty(Fields, "vendorLegitimateInterests", 'vendorLegitimateInterests');
_defineProperty(Fields, "vendorListVersion", 'vendorListVersion');
_defineProperty(Fields, "vendorsAllowed", 'vendorsAllowed');
_defineProperty(Fields, "vendorsDisclosed", 'vendorsDisclosed');
_defineProperty(Fields, "version", 'version');
;// CONCATENATED MODULE: ./node_modules/@iabtechlabtcf/core/lib/mjs/Cloneable.js
/**
 * Abstract Class Cloneable<T> can be extended to give the child class the ability to clone its self.
 * The child class must pass its class to super. You can then pass any needed arguments to help build
 * the cloned class to the protected _clone() method.
 *
 * Example:
 *
 * class Example extends Cloneable<Example> {
 *
 * }
 * Todo: There must be more non primitive build in types to check. But for our current purposes, this works great.
 */
class Cloneable {
  /**
   * clone - returns a copy of the classes with new values and not references
   *
   * @return {T}
   */
  clone() {
    const myClone = new this.constructor();
    const keys = Object.keys(this);
    keys.forEach(key => {
      const value = this.deepClone(this[key]);
      if (value !== undefined) {
        myClone[key] = value;
      }
    });
    return myClone;
  }
  /**
   * deepClone - recursive function that makes copies of reference values
   *
   * @param {unknown} item
   * @return {unknown}
   */
  deepClone(item) {
    const itsType = typeof item;
    if (itsType === 'number' || itsType === 'string' || itsType === 'boolean') {
      return item;
    } else if (item !== null && itsType === 'object') {
      if (typeof item.clone === 'function') {
        return item.clone();
      } else if (item instanceof Date) {
        return new Date(item.getTime());
      } else if (item[Symbol.iterator] !== undefined) {
        const ar = [];
        for (const subItem of item) {
          ar.push(this.deepClone(subItem));
        }
        if (item instanceof Array) {
          return ar;
        } else {
          return new item.constructor(ar);
        }
      } else {
        const retr = {};
        for (const prop in item) {
          if (item.hasOwnProperty(prop)) {
            retr[prop] = this.deepClone(item[prop]);
          }
        }
        return retr;
      }
    }
    /**
     * ignore functions because those will be initialized with the cloning
     * process
     */
  }
}
;// CONCATENATED MODULE: ./node_modules/@iabtechlabtcf/core/lib/mjs/errors/TCModelError.js
/**
 * class for decoding errors
 *
 * @extends {Error}
 */
class TCModelError extends Error {
  /**
   * constructor - constructs an TCModelError
   *
   * @param {string} fieldName - the errored field
   * @param {string} passedValue - what was passed
   * @return {undefined}
   */
  constructor(fieldName, passedValue) {
    let msg = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
    super(`invalid value ${passedValue} passed for ${fieldName} ${msg}`);
    this.name = 'TCModelError';
  }
}

;// CONCATENATED MODULE: ./node_modules/@iabtechlabtcf/core/lib/mjs/model/RestrictionType.js
/**
 * if a Vendor has declared flexible purposes (see: [[Vendor]] under
 * `flexiblePurposeIds`) on the Global Vendor List ([[Declarations]]) a CMP may
 * change their legal basis for processing in the encoding.
 */
var RestrictionType;
(function (RestrictionType) {
  /**
   * under no circumstances is this purpose allowed.
   */
  RestrictionType[RestrictionType["NOT_ALLOWED"] = 0] = "NOT_ALLOWED";
  /**
   * if the default declaration is legitimate interest then this flips the purpose to consent in the encoding.
   */
  RestrictionType[RestrictionType["REQUIRE_CONSENT"] = 1] = "REQUIRE_CONSENT";
  /**
   * if the default declaration is consent then this flips the purpose to Legitimate Interest in the encoding.
   */
  RestrictionType[RestrictionType["REQUIRE_LI"] = 2] = "REQUIRE_LI";
})(RestrictionType || (RestrictionType = {}));
;// CONCATENATED MODULE: ./node_modules/@iabtechlabtcf/core/lib/mjs/model/PurposeRestriction.js




class PurposeRestriction extends Cloneable {
  /**
   * constructor
   *
   * @param {number} purposeId? - may optionally pass the purposeId into the
   * constructor
   * @param {RestrictionType} restrictionType? - may
   * optionally pass the restrictionType into the constructor
   * @return {undefined}
   */
  constructor(purposeId, restrictionType) {
    super();
    _defineProperty(this, "purposeId_", void 0);
    _defineProperty(this, "restrictionType", void 0);
    if (purposeId !== undefined) {
      this.purposeId = purposeId;
    }
    if (restrictionType !== undefined) {
      this.restrictionType = restrictionType;
    }
  }
  static unHash(hash) {
    const splitUp = hash.split(this.hashSeparator);
    const purpRestriction = new PurposeRestriction();
    if (splitUp.length !== 2) {
      throw new TCModelError('hash', hash);
    }
    purpRestriction.purposeId = parseInt(splitUp[0], 10);
    purpRestriction.restrictionType = parseInt(splitUp[1], 10);
    return purpRestriction;
  }
  get hash() {
    if (!this.isValid()) {
      throw new Error('cannot hash invalid PurposeRestriction');
    }
    return `${this.purposeId}${PurposeRestriction.hashSeparator}${this.restrictionType}`;
  }
  /**
   * @return {number} The purpose Id associated with a publisher
   * purpose-by-vendor restriction that resulted in a different consent or LI
   * status than the consent or LI purposes allowed lists.
   */
  get purposeId() {
    return this.purposeId_;
  }
  /**
   * @param {number} idNum - The purpose Id associated with a publisher
   * purpose-by-vendor restriction that resulted in a different consent or LI
   * status than the consent or LI purposes allowed lists.
   */
  set purposeId(idNum) {
    this.purposeId_ = idNum;
  }
  isValid() {
    return Number.isInteger(this.purposeId) && this.purposeId > 0 && (this.restrictionType === RestrictionType.NOT_ALLOWED || this.restrictionType === RestrictionType.REQUIRE_CONSENT || this.restrictionType === RestrictionType.REQUIRE_LI);
  }
  isSameAs(otherPR) {
    return this.purposeId === otherPR.purposeId && this.restrictionType === otherPR.restrictionType;
  }
}
_defineProperty(PurposeRestriction, "hashSeparator", '-');
;// CONCATENATED MODULE: ./node_modules/@iabtechlabtcf/core/lib/mjs/model/PurposeRestrictionVector.js




class PurposeRestrictionVector extends Cloneable {
  constructor() {
    super(...arguments);
    /**
     * if this originatd from an encoded string we'll need a place to store the
     * bit length; it can be set and got from here
     */
    _defineProperty(this, "bitLength", 0);
    /**
     * a map indexed by a string which will be a 'hash' of the purpose and
     * restriction type.
     */
    _defineProperty(this, "map", new Map());
    _defineProperty(this, "gvl_", void 0);
  }
  has(hash) {
    return this.map.has(hash);
  }
  isOkToHave(restrictionType, purposeId, vendorId) {
    var _this$gvl;
    let result = true;
    /**
     * without a gvl set, there's no way to know... in that case we'll return
     * true but once the GVL is set later we'll go through these and clean up
     * the mess.
     */
    if ((_this$gvl = this.gvl) !== null && _this$gvl !== void 0 && _this$gvl.vendors) {
      const vendor = this.gvl.vendors[vendorId];
      if (vendor) {
        if (restrictionType === RestrictionType.NOT_ALLOWED) {
          /**
           * if it's "not allowed" then flexible declaration is ignored but if
           * if it isn't even listed as one of the purposes the vendor uses,
           * then there is no reason to encode the value so check both arrays
           * to see if it exists.  If it does then we can restrict it.
           */
          result = vendor.legIntPurposes.includes(purposeId) || vendor.purposes.includes(purposeId);
        } else if (vendor.flexiblePurposes.length) {
          switch (restrictionType) {
            /**
               * If the vendor has the purposeId in flexiblePurposes and it is
               * listed as a legitimate interest purpose we can set the
               * override to require consent.
               */
            case RestrictionType.REQUIRE_CONSENT:
              result = vendor.flexiblePurposes.includes(purposeId) && vendor.legIntPurposes.includes(purposeId);
              break;
            /**
             * If the vendor has the purposeId in flexiblePurposes and it is
             * listed as a consent purpose we can set the
             * override to require legitimate interest.
             */
            case RestrictionType.REQUIRE_LI:
              result = vendor.flexiblePurposes.includes(purposeId) && vendor.purposes.includes(purposeId);
              break;
          }
        } else {
          result = false;
        }
      } else {
        // this vendor doesn't exist
        result = false;
      }
    }
    // if the gvl isn't defined, we can't do anything until later
    return result;
  }
  /**
   * add - adds a given Vendor ID under a given Purpose Restriction
   *
   * @param {number} vendorId
   * @param {PurposeRestriction} purposeRestriction
   * @return {void}
   */
  add(vendorId, purposeRestriction) {
    if (this.isOkToHave(purposeRestriction.restrictionType, purposeRestriction.purposeId, vendorId)) {
      const hash = purposeRestriction.hash;
      if (!this.has(hash)) {
        this.map.set(hash, new Set());
        this.bitLength = 0;
      }
      /**
       * Previously I had a check here to remove a duplicate value, but because
       * we're using a tree the value is guaranteed to be unique so there is no
       * need to add an additional de-duplication here.
       */
      this.map.get(hash).add(vendorId);
    }
  }
  /**
   * restrictPurposeToLegalBasis - adds all Vendors under a given Purpose Restriction
   *
   * @param {PurposeRestriction} purposeRestriction
   * @return {void}
   */
  restrictPurposeToLegalBasis(purposeRestriction) {
    const vendors = Array.from(this.gvl.vendorIds);
    const hash = purposeRestriction.hash;
    const lastEntry = vendors[vendors.length - 1];
    /**
     * Create an ordered array of vendor IDs from `1` (the minimum value for Vendor ID) to `lastEntry`
     */
    const values = [...Array(lastEntry).keys()].map(i => i + 1);
    if (!this.has(hash)) {
      this.map.set(hash, new Set(values)); // use static method `build` to create a `BST` from the ordered array of IDs
      this.bitLength = 0;
    } else {
      for (let i = 1; i <= lastEntry; i++) {
        /**
         * Previously I had a check here to remove a duplicate value, but because
         * we're using a tree the value is guaranteed to be unique so there is no
         * need to add an additional de-duplication here.
         */
        this.map.get(hash).add(i);
      }
    }
  }
  /**
   * getVendors - returns array of vendor ids optionally narrowed by a given
   * Purpose Restriction.  If no purpose restriction is passed then all vendor
   * ids will be returned.  One can expect this result to be a unique set of
   * ids no duplicates.
   *
   * @param {PurposeRestriction} [purposeRestriction] - optionally passed to
   * get only Vendor IDs restricted under the given Purpose Restriction
   * @return {number[]} - Unique ID set of vendors
   */
  getVendors(purposeRestriction) {
    let vendorIds = [];
    if (purposeRestriction) {
      const hash = purposeRestriction.hash;
      if (this.has(hash)) {
        vendorIds = Array.from(this.map.get(hash));
      }
    } else {
      const vendorSet = new Set();
      this.map.forEach(set => {
        set.forEach(vendorId => {
          vendorSet.add(vendorId);
        });
      });
      vendorIds = Array.from(vendorSet);
    }
    return vendorIds.sort((a, b) => a - b);
  }
  getRestrictionType(vendorId, purposeId) {
    let rType;
    this.getRestrictions(vendorId).forEach(purposeRestriction => {
      if (purposeRestriction.purposeId === purposeId) {
        if (rType === undefined || rType > purposeRestriction.restrictionType) {
          rType = purposeRestriction.restrictionType;
        }
      }
    });
    return rType;
  }
  /**
   * vendorHasRestriction - determines whether a given Vendor ID is under a
   * given Purpose Restriction
   *
   * @param {number} vendorId
   * @param {PurposeRestriction} purposeRestriction
   * @return {boolean} - true if the give Vendor ID is under the given Purpose
   * Restriction
   */
  vendorHasRestriction(vendorId, purposeRestriction) {
    let has = false;
    const restrictions = this.getRestrictions(vendorId);
    for (let i = 0; i < restrictions.length && !has; i++) {
      has = purposeRestriction.isSameAs(restrictions[i]);
    }
    return has;
  }
  /**
   * getMaxVendorId - gets the Maximum Vendor ID regardless of Purpose
   * Restriction
   *
   * @return {number} - maximum Vendor ID
   */
  getMaxVendorId() {
    let retr = 0;
    this.map.forEach(set => {
      retr = Math.max(Array.from(set)[set.size - 1], retr);
    });
    return retr;
  }
  getRestrictions(vendorId) {
    const retr = [];
    this.map.forEach((set, hash) => {
      if (vendorId) {
        if (set.has(vendorId)) {
          retr.push(PurposeRestriction.unHash(hash));
        }
      } else {
        retr.push(PurposeRestriction.unHash(hash));
      }
    });
    return retr;
  }
  getPurposes() {
    const purposeIds = new Set();
    this.map.forEach((set, hash) => {
      purposeIds.add(PurposeRestriction.unHash(hash).purposeId);
    });
    return Array.from(purposeIds);
  }
  /**
   * remove - removes Vendor ID from a Purpose Restriction
   *
   * @param {number} vendorId
   * @param {PurposeRestriction} purposeRestriction
   * @return {void}
   */
  remove(vendorId, purposeRestriction) {
    const hash = purposeRestriction.hash;
    const set = this.map.get(hash);
    if (set) {
      set.delete(vendorId);
      // if it's empty let's delete the key so it doesn't show up empty
      if (set.size == 0) {
        this.map.delete(hash);
        this.bitLength = 0;
      }
    }
  }
  /**
   * Essential for being able to determine whether we can actually set a
   * purpose restriction since they have to have a flexible legal basis
   *
   * @param {GVL} value - the GVL instance
   */
  set gvl(value) {
    if (!this.gvl_) {
      this.gvl_ = value;
      /**
       * if we have restrictions set before the gvl is set then we'll have to
       * go through and remove some if they're not valid
       */
      this.map.forEach((set, hash) => {
        const purposeRestriction = PurposeRestriction.unHash(hash);
        const vendors = Array.from(set);
        vendors.forEach(vendorId => {
          if (!this.isOkToHave(purposeRestriction.restrictionType, purposeRestriction.purposeId, vendorId)) {
            set.delete(vendorId);
          }
        });
      });
    }
  }
  /**
   * gvl returns local copy of the GVL these restrictions apply to
   *
   * @return {GVL}
   */
  get gvl() {
    return this.gvl_;
  }
  /**
   * isEmpty - whether or not this vector has any restrictions in it
   *
   * @return {boolean}
   */
  isEmpty() {
    return this.map.size === 0;
  }
  /**
   * numRestrictions - returns the number of Purpose Restrictions.
   *
   * @return {number}
   */
  get numRestrictions() {
    return this.map.size;
  }
}
;// CONCATENATED MODULE: ./node_modules/@iabtechlabtcf/core/lib/mjs/model/DeviceDisclosureStorageAccessType.js
var DeviceDisclosureStorageAccessType;
(function (DeviceDisclosureStorageAccessType) {
  DeviceDisclosureStorageAccessType["COOKIE"] = "cookie";
  DeviceDisclosureStorageAccessType["WEB"] = "web";
  DeviceDisclosureStorageAccessType["APP"] = "app";
})(DeviceDisclosureStorageAccessType || (DeviceDisclosureStorageAccessType = {}));
;// CONCATENATED MODULE: ./node_modules/@iabtechlabtcf/core/lib/mjs/model/Segment.js
var Segment;
(function (Segment) {
  Segment["CORE"] = "core";
  Segment["VENDORS_DISCLOSED"] = "vendorsDisclosed";
  Segment["VENDORS_ALLOWED"] = "vendorsAllowed";
  Segment["PUBLISHER_TC"] = "publisherTC";
})(Segment || (Segment = {}));
;// CONCATENATED MODULE: ./node_modules/@iabtechlabtcf/core/lib/mjs/model/SegmentIDs.js


class SegmentIDs {}
/**
 * 0 = default - reserved for core string (does not need to be present in the core string)
 * 1 = OOB vendors disclosed
 * 2 = OOB vendors allowed
 * 3 = PublisherTC
 */
_defineProperty(SegmentIDs, "ID_TO_KEY", [Segment.CORE, Segment.VENDORS_DISCLOSED, Segment.VENDORS_ALLOWED, Segment.PUBLISHER_TC]);
_defineProperty(SegmentIDs, "KEY_TO_ID", {
  [Segment.CORE]: 0,
  [Segment.VENDORS_DISCLOSED]: 1,
  [Segment.VENDORS_ALLOWED]: 2,
  [Segment.PUBLISHER_TC]: 3
});
;// CONCATENATED MODULE: ./node_modules/@iabtechlabtcf/core/lib/mjs/model/Vector.js

let _Symbol$iterator;


/**
 * Vector class is like a Set except it keeps track of a max id
 */
_Symbol$iterator = Symbol.iterator;
class Vector extends Cloneable {
  constructor() {
    super(...arguments);
    /**
     * if this originatd from an encoded string we'll need a place to store the
     * bit length; it can be set and got from here
     */
    _defineProperty(this, "bitLength", 0);
    _defineProperty(this, "maxId_", 0);
    _defineProperty(this, "set_", new Set());
  }
  *[_Symbol$iterator]() {
    for (let i = 1; i <= this.maxId; i++) {
      yield [i, this.has(i)];
    }
  }
  /**
   * values()
   *
   * @return {IterableIterator<number>} - returns an iterator of the positive
   * values in the set
   */
  values() {
    return this.set_.values();
  }
  /**
   * maxId
   *
   * @return {number} - the highest id in this Vector
   */
  get maxId() {
    return this.maxId_;
  }
  /**
   * get
   *
   * @param {number} id - key for value to check
   * @return {boolean} - value of that key, if never set it will be false
   */
  has(id) {
    /**
     * if it exists in the set we'll return true
     */
    return this.set_.has(id);
  }
  /**
   * unset
   *
   * @param {SingleIDOrCollection} id - id or ids to unset
   * @return {void}
   */
  unset(id) {
    if (Array.isArray(id)) {
      id.forEach(id => this.unset(id));
    } else if (typeof id === 'object') {
      this.unset(Object.keys(id).map(strId => Number(strId)));
    } else {
      this.set_.delete(Number(id));
      /**
       * if bitLength was set before, it must now be unset
       */
      this.bitLength = 0;
      if (id === this.maxId) {
        /**
         * aww bummer we lost our maxId... now we've got to search through
         * all the ids and find the biggest one.
         */
        this.maxId_ = 0;
        this.set_.forEach(id => {
          this.maxId_ = Math.max(this.maxId, id);
        });
      }
    }
  }
  isIntMap(item) {
    let result = typeof item === 'object';
    result = result && Object.keys(item).every(key => {
      let itemResult = Number.isInteger(parseInt(key, 10));
      itemResult = itemResult && this.isValidNumber(item[key].id);
      itemResult = itemResult && item[key].name !== undefined;
      return itemResult;
    });
    return result;
  }
  isValidNumber(item) {
    return parseInt(item, 10) > 0;
  }
  isSet(item) {
    let result = false;
    if (item instanceof Set) {
      result = Array.from(item).every(this.isValidNumber);
    }
    return result;
  }
  /**
   * set - sets an item assumed to be a truthy value by its presence
   *
   * @param {SingleIDOrCollection} item - May be a single id (positive integer)
   * or collection of ids in a set, GVL Int Map, or Array.
   *
   * @return {void}
   */
  set(item) {
    /**
     * strategy here is to just recursively call set if it's a collection until
     * we get to the final integer ID
     */
    if (Array.isArray(item)) {
      item.forEach(item => this.set(item));
    } else if (this.isSet(item)) {
      this.set(Array.from(item));
    } else if (this.isIntMap(item)) {
      this.set(Object.keys(item).map(strId => Number(strId)));
    } else if (this.isValidNumber(item)) {
      this.set_.add(item);
      this.maxId_ = Math.max(this.maxId, item);
      /**
       * if bitLength was set before, it must now be unset
       */
      this.bitLength = 0;
    } else {
      /**
       * Super not cool to try and set something that's not valid
       */
      throw new TCModelError('set()', item, 'must be positive integer array, positive integer, Set<number>, or IntMap');
    }
  }
  empty() {
    this.set_ = new Set();
  }
  /**
   * forEach - to traverse from id=1 to id=maxId in a sequential non-sparse manner
   *
   *
   * @param {forEachCallback} callback - callback to execute
   * @return {void}
   *
   * @callback forEachCallback
   * @param {boolean} value - whether or not this id exists in the vector
   * @param {number} id - the id number of the current iteration
   */
  forEach(callback) {
    for (let i = 1; i <= this.maxId; i++) {
      callback(this.has(i), i);
    }
  }
  get size() {
    return this.set_.size;
  }
  setAll(intMap) {
    this.set(intMap);
  }
}
;// CONCATENATED MODULE: ./node_modules/@iabtechlabtcf/core/lib/mjs/model/index.js













;// CONCATENATED MODULE: ./node_modules/@iabtechlabtcf/core/lib/mjs/encoder/BitLength.js

let _Fields$cmpId, _Fields$cmpVersion, _Fields$consentLangua, _Fields$consentScreen, _Fields$created, _Fields$isServiceSpec, _Fields$lastUpdated, _Fields$policyVersion, _Fields$publisherCoun, _Fields$publisherLegi, _Fields$publisherCons, _Fields$purposeConsen, _Fields$purposeLegiti, _Fields$purposeOneTre, _Fields$specialFeatur, _Fields$useNonStandar, _Fields$vendorListVer, _Fields$version;

_Fields$cmpId = Fields.cmpId;
_Fields$cmpVersion = Fields.cmpVersion;
_Fields$consentLangua = Fields.consentLanguage;
_Fields$consentScreen = Fields.consentScreen;
_Fields$created = Fields.created;
_Fields$isServiceSpec = Fields.isServiceSpecific;
_Fields$lastUpdated = Fields.lastUpdated;
_Fields$policyVersion = Fields.policyVersion;
_Fields$publisherCoun = Fields.publisherCountryCode;
_Fields$publisherLegi = Fields.publisherLegitimateInterests;
_Fields$publisherCons = Fields.publisherConsents;
_Fields$purposeConsen = Fields.purposeConsents;
_Fields$purposeLegiti = Fields.purposeLegitimateInterests;
_Fields$purposeOneTre = Fields.purposeOneTreatment;
_Fields$specialFeatur = Fields.specialFeatureOptins;
_Fields$useNonStandar = Fields.useNonStandardTexts;
_Fields$vendorListVer = Fields.vendorListVersion;
_Fields$version = Fields.version;
class BitLength {}
_defineProperty(BitLength, _Fields$cmpId, 12);
_defineProperty(BitLength, _Fields$cmpVersion, 12);
_defineProperty(BitLength, _Fields$consentLangua, 12);
_defineProperty(BitLength, _Fields$consentScreen, 6);
_defineProperty(BitLength, _Fields$created, 36);
_defineProperty(BitLength, _Fields$isServiceSpec, 1);
_defineProperty(BitLength, _Fields$lastUpdated, 36);
_defineProperty(BitLength, _Fields$policyVersion, 6);
_defineProperty(BitLength, _Fields$publisherCoun, 12);
_defineProperty(BitLength, _Fields$publisherLegi, 24);
_defineProperty(BitLength, _Fields$publisherCons, 24);
_defineProperty(BitLength, _Fields$purposeConsen, 24);
_defineProperty(BitLength, _Fields$purposeLegiti, 24);
_defineProperty(BitLength, _Fields$purposeOneTre, 1);
_defineProperty(BitLength, _Fields$specialFeatur, 12);
_defineProperty(BitLength, _Fields$useNonStandar, 1);
_defineProperty(BitLength, _Fields$vendorListVer, 12);
_defineProperty(BitLength, _Fields$version, 6);
_defineProperty(BitLength, "anyBoolean", 1);
_defineProperty(BitLength, "encodingType", 1);
_defineProperty(BitLength, "maxId", 16);
_defineProperty(BitLength, "numCustomPurposes", 6);
_defineProperty(BitLength, "numEntries", 12);
_defineProperty(BitLength, "numRestrictions", 12);
_defineProperty(BitLength, "purposeId", 6);
_defineProperty(BitLength, "restrictionType", 2);
_defineProperty(BitLength, "segmentType", 3);
_defineProperty(BitLength, "singleOrRange", 1);
_defineProperty(BitLength, "vendorId", 16);
;// CONCATENATED MODULE: ./node_modules/@iabtechlabtcf/core/lib/mjs/encoder/field/BooleanEncoder.js
class BooleanEncoder {
  static encode(value) {
    return String(Number(value));
  }
  static decode(value) {
    // less operations than !!parseInt(value, 2)
    return value === '1';
  }
}
;// CONCATENATED MODULE: ./node_modules/@iabtechlabtcf/core/lib/mjs/encoder/field/IntEncoder.js

class IntEncoder {
  static encode(value, numBits) {
    let bitString;
    if (typeof value === 'string') {
      value = parseInt(value, 10);
    }
    bitString = value.toString(2);
    if (bitString.length > numBits || value < 0) {
      throw new EncodingError(`${value} too large to encode into ${numBits}`);
    }
    // Pad the string if not filling all bits
    if (bitString.length < numBits) {
      // pad left
      bitString = '0'.repeat(numBits - bitString.length) + bitString;
    }
    return bitString;
  }
  static decode(value, numBits) {
    if (numBits !== value.length) {
      throw new DecodingError('invalid bit length');
    }
    return parseInt(value, 2);
  }
}
;// CONCATENATED MODULE: ./node_modules/@iabtechlabtcf/core/lib/mjs/encoder/field/DateEncoder.js


class DateEncoder {
  static encode(value, numBits) {
    return IntEncoder.encode(Math.round(value.getTime() / 100), numBits);
  }
  static decode(value, numBits) {
    if (numBits !== value.length) {
      throw new DecodingError('invalid bit length');
    }
    const date = new Date();
    date.setTime(IntEncoder.decode(value, numBits) * 100);
    return date;
  }
}
;// CONCATENATED MODULE: ./node_modules/@iabtechlabtcf/core/lib/mjs/encoder/field/FixedVectorEncoder.js



class FixedVectorEncoder {
  static encode(value, numBits) {
    let bitString = '';
    for (let i = 1; i <= numBits; i++) {
      bitString += BooleanEncoder.encode(value.has(i));
    }
    return bitString;
  }
  static decode(value, numBits) {
    if (value.length !== numBits) {
      throw new DecodingError('bitfield encoding length mismatch');
    }
    const vector = new Vector();
    for (let i = 1; i <= numBits; i++) {
      if (BooleanEncoder.decode(value[i - 1])) {
        vector.set(i);
      }
    }
    vector.bitLength = value.length;
    return vector;
  }
}
;// CONCATENATED MODULE: ./node_modules/@iabtechlabtcf/core/lib/mjs/encoder/field/LangEncoder.js


class LangEncoder {
  static encode(value, numBits) {
    value = value.toUpperCase();
    const ASCII_START = 65;
    const firstLetter = value.charCodeAt(0) - ASCII_START;
    const secondLetter = value.charCodeAt(1) - ASCII_START;
    // check some things to throw some good errors
    if (firstLetter < 0 || firstLetter > 25 || secondLetter < 0 || secondLetter > 25) {
      throw new EncodingError(`invalid language code: ${value}`);
    }
    if (numBits % 2 === 1) {
      throw new EncodingError(`numBits must be even, ${numBits} is not valid`);
    }
    numBits = numBits / 2;
    const firstLetterBString = IntEncoder.encode(firstLetter, numBits);
    const secondLetterBString = IntEncoder.encode(secondLetter, numBits);
    return firstLetterBString + secondLetterBString;
  }
  static decode(value, numBits) {
    let retr;
    // is it an even number of bits? we have to divide it
    if (numBits === value.length && !(value.length % 2)) {
      const ASCII_START = 65;
      const mid = value.length / 2;
      const firstLetter = IntEncoder.decode(value.slice(0, mid), mid) + ASCII_START;
      const secondLetter = IntEncoder.decode(value.slice(mid), mid) + ASCII_START;
      retr = String.fromCharCode(firstLetter) + String.fromCharCode(secondLetter);
    } else {
      throw new DecodingError('invalid bit length for language');
    }
    return retr;
  }
}
;// CONCATENATED MODULE: ./node_modules/@iabtechlabtcf/core/lib/mjs/encoder/field/PurposeRestrictionVectorEncoder.js





class PurposeRestrictionVectorEncoder {
  static encode(prVector) {
    // start with the number of restrictions
    let bitString = IntEncoder.encode(prVector.numRestrictions, BitLength.numRestrictions);
    // if the vector is empty we'll just return a string with just the numRestricitons being 0
    if (!prVector.isEmpty()) {
      const nextGvlVendor = (vendorId, lastVendorId) => {
        for (let nextId = vendorId + 1; nextId <= lastVendorId; nextId++) {
          if (prVector.gvl.vendorIds.has(nextId)) {
            return nextId;
          }
        }
        return vendorId;
      };
      // create each restriction group
      prVector.getRestrictions().forEach(purpRestriction => {
        // every restriction group has the purposeId and the restrictionType;
        bitString += IntEncoder.encode(purpRestriction.purposeId, BitLength.purposeId);
        bitString += IntEncoder.encode(purpRestriction.restrictionType, BitLength.restrictionType);
        // now get all the vendors under that restriction
        const vendors = prVector.getVendors(purpRestriction);
        const len = vendors.length;
        /**
         * numEntries comes first so we will have to keep a counter and the do
         * the encoding at the end
         */
        let numEntries = 0;
        let startId = 0;
        let rangeField = '';
        for (let i = 0; i < len; i++) {
          const vendorId = vendors[i];
          if (startId === 0) {
            numEntries++;
            startId = vendorId;
          }
          /**
           * either end of the loop or there are GVL vendor IDs before the next one
           */
          if (i === len - 1 || vendors[i + 1] > nextGvlVendor(vendorId, vendors[len - 1])) {
            /**
             * it's a range entry if we've got something other than the start
             * ID
             */
            const isRange = !(vendorId === startId);
            // 0 means single 1 means range
            rangeField += BooleanEncoder.encode(isRange);
            rangeField += IntEncoder.encode(startId, BitLength.vendorId);
            if (isRange) {
              rangeField += IntEncoder.encode(vendorId, BitLength.vendorId);
            }
            // reset the startId so we grab the next id in the list
            startId = 0;
          }
        }
        /**
         * now that  the range encoding is built, encode the number of ranges
         * and then append the range field to the bitString.
         */
        bitString += IntEncoder.encode(numEntries, BitLength.numEntries);
        bitString += rangeField;
      });
    }
    return bitString;
  }
  static decode(encodedString) {
    let index = 0;
    const vector = new PurposeRestrictionVector();
    const numRestrictions = IntEncoder.decode(encodedString.substr(index, BitLength.numRestrictions), BitLength.numRestrictions);
    index += BitLength.numRestrictions;
    for (let i = 0; i < numRestrictions; i++) {
      // First is purpose ID
      const purposeId = IntEncoder.decode(encodedString.substr(index, BitLength.purposeId), BitLength.purposeId);
      index += BitLength.purposeId;
      // Second Restriction Type
      const restrictionType = IntEncoder.decode(encodedString.substr(index, BitLength.restrictionType), BitLength.restrictionType);
      index += BitLength.restrictionType;
      const purposeRestriction = new PurposeRestriction(purposeId, restrictionType);
      // Num Entries (number of vendors)
      const numEntries = IntEncoder.decode(encodedString.substr(index, BitLength.numEntries), BitLength.numEntries);
      index += BitLength.numEntries;
      for (let j = 0; j < numEntries; j++) {
        const isARange = BooleanEncoder.decode(encodedString.substr(index, BitLength.anyBoolean));
        index += BitLength.anyBoolean;
        const startOrOnlyVendorId = IntEncoder.decode(encodedString.substr(index, BitLength.vendorId), BitLength.vendorId);
        index += BitLength.vendorId;
        if (isARange) {
          const endVendorId = IntEncoder.decode(encodedString.substr(index, BitLength.vendorId), BitLength.vendorId);
          index += BitLength.vendorId;
          if (endVendorId < startOrOnlyVendorId) {
            throw new DecodingError(`Invalid RangeEntry: endVendorId ${endVendorId} is less than ${startOrOnlyVendorId}`);
          }
          for (let k = startOrOnlyVendorId; k <= endVendorId; k++) {
            vector.add(k, purposeRestriction);
          }
        } else {
          vector.add(startOrOnlyVendorId, purposeRestriction);
        }
      }
    }
    vector.bitLength = index;
    return vector;
  }
}
;// CONCATENATED MODULE: ./node_modules/@iabtechlabtcf/core/lib/mjs/encoder/field/VectorEncodingType.js
var VectorEncodingType;
(function (VectorEncodingType) {
  VectorEncodingType[VectorEncodingType["FIELD"] = 0] = "FIELD";
  VectorEncodingType[VectorEncodingType["RANGE"] = 1] = "RANGE";
})(VectorEncodingType || (VectorEncodingType = {}));
;// CONCATENATED MODULE: ./node_modules/@iabtechlabtcf/core/lib/mjs/encoder/field/VendorVectorEncoder.js







class VendorVectorEncoder {
  static encode(value) {
    // collectors for range encoding
    const ranges = [];
    let range = [];
    // since both encodings need the maxId, start with that
    let retrString = IntEncoder.encode(value.maxId, BitLength.maxId);
    // bit field will be just the vendors as we walk through the vector
    let bitField = '';
    let rangeIsSmaller;
    // some math
    const headerLength = BitLength.maxId + BitLength.encodingType;
    const bitFieldLength = headerLength + value.maxId;
    const minRangeLength = BitLength.vendorId * 2 + BitLength.singleOrRange + BitLength.numEntries;
    // gets larger as we walk through the vector
    let rangeLength = headerLength + BitLength.numEntries;
    // walk through every value in the vector
    value.forEach((curValue, i) => {
      // build our bitfield no matter what
      bitField += BooleanEncoder.encode(curValue);
      /**
       * A range is a minimum of 45 bits, if the number of vendors in this
       * vector is less than 45 then we know that a bitfield encoding will be
       * shorter than any range encoding.
       *
       * The second check checks while we walk through the vector and abandons
       * building the ranges once it becomes larger
       */
      rangeIsSmaller = value.maxId > minRangeLength && rangeLength < bitFieldLength;
      /**
       * if the curValue is true and our rangeLength is less than the bitField
       * length, we'll continue to push these ranges into the array.  Once the
       * ranges become a larger encoding there is no reason to continue
       * building the structure because we will be choosing the bitfield
       * encoding
       */
      if (rangeIsSmaller && curValue) {
        /**
         * Look ahead to see if this is the last value in our range
         */
        const nextValue = value.has(i + 1);
        // if there isn't a next value, then we'll wrap up this range
        if (!nextValue) {
          /**
           * this is the last value of the range, so we'll push it on to the
           * end into position 1
           */
          range.push(i);
          // add to the range length the additional vendorId
          rangeLength += BitLength.vendorId;
          // store the array in our bigger array
          ranges.push(range);
          // clear the array for the next range
          range = [];
        } else if (range.length === 0) {
          // this is the first  value for this range
          range.push(i);
          // update our count with new range overhead
          rangeLength += BitLength.singleOrRange;
          rangeLength += BitLength.vendorId;
        }
      }
    });
    if (rangeIsSmaller) {
      retrString += String(VectorEncodingType.RANGE);
      retrString += this.buildRangeEncoding(ranges);
    } else {
      retrString += String(VectorEncodingType.FIELD);
      retrString += bitField;
    }
    return retrString;
  }
  static decode(value, version) {
    let vector;
    let index = 0;
    const maxId = IntEncoder.decode(value.substr(index, BitLength.maxId), BitLength.maxId);
    index += BitLength.maxId;
    const encodingType = IntEncoder.decode(value.charAt(index), BitLength.encodingType);
    index += BitLength.encodingType;
    /**
     * Range is handled in batches so we'll need a different decoding scheme
     */
    if (encodingType === VectorEncodingType.RANGE) {
      vector = new Vector();
      if (version === 1) {
        if (value.substr(index, 1) === '1') {
          throw new DecodingError('Unable to decode default consent=1');
        }
        // jump over the default encoding
        index++;
      }
      const numEntries = IntEncoder.decode(value.substr(index, BitLength.numEntries), BitLength.numEntries);
      index += BitLength.numEntries;
      // loop through each group of entries
      for (let i = 0; i < numEntries; i++) {
        // Ranges can represent a single id or a range of ids.
        const isIdRange = BooleanEncoder.decode(value.charAt(index));
        index += BitLength.singleOrRange;
        /**
         * regardless of whether or not it's a single entry or range, the next
         * set of bits is a vendor ID
         */
        const firstId = IntEncoder.decode(value.substr(index, BitLength.vendorId), BitLength.vendorId);
        index += BitLength.vendorId;
        // if it's a range, the next set of bits is the second id
        if (isIdRange) {
          const secondId = IntEncoder.decode(value.substr(index, BitLength.vendorId), BitLength.vendorId);
          index += BitLength.vendorId;
          // we'll need to set or unset all the vendor ids between the first and second
          for (let j = firstId; j <= secondId; j++) {
            vector.set(j);
          }
        } else {
          vector.set(firstId);
        }
      }
    } else {
      const bitField = value.substr(index, maxId);
      index += maxId;
      vector = FixedVectorEncoder.decode(bitField, maxId);
    }
    vector.bitLength = index;
    return vector;
  }
  static buildRangeEncoding(ranges) {
    // describe the number of entries to follow
    const numEntries = ranges.length;
    let rangeString = IntEncoder.encode(numEntries, BitLength.numEntries);
    // each range
    ranges.forEach(range => {
      // is this range a single?
      const single = range.length === 1;
      // first is the indicator of whether this is a single id or range (two)
      // 0 is single and range is 1
      rangeString += BooleanEncoder.encode(!single);
      // second is the first (or only) vendorId
      rangeString += IntEncoder.encode(range[0], BitLength.vendorId);
      if (!single) {
        // add the second id if it exists
        rangeString += IntEncoder.encode(range[1], BitLength.vendorId);
      }
    });
    return rangeString;
  }
}
;// CONCATENATED MODULE: ./node_modules/@iabtechlabtcf/core/lib/mjs/encoder/field/FieldEncoderMap.js








function FieldEncoderMap() {
  return {
    [Fields.version]: IntEncoder,
    [Fields.created]: DateEncoder,
    [Fields.lastUpdated]: DateEncoder,
    [Fields.cmpId]: IntEncoder,
    [Fields.cmpVersion]: IntEncoder,
    [Fields.consentScreen]: IntEncoder,
    [Fields.consentLanguage]: LangEncoder,
    [Fields.vendorListVersion]: IntEncoder,
    [Fields.policyVersion]: IntEncoder,
    [Fields.isServiceSpecific]: BooleanEncoder,
    [Fields.useNonStandardTexts]: BooleanEncoder,
    [Fields.specialFeatureOptins]: FixedVectorEncoder,
    [Fields.purposeConsents]: FixedVectorEncoder,
    [Fields.purposeLegitimateInterests]: FixedVectorEncoder,
    [Fields.purposeOneTreatment]: BooleanEncoder,
    [Fields.publisherCountryCode]: LangEncoder,
    [Fields.vendorConsents]: VendorVectorEncoder,
    [Fields.vendorLegitimateInterests]: VendorVectorEncoder,
    [Fields.publisherRestrictions]: PurposeRestrictionVectorEncoder,
    segmentType: IntEncoder,
    [Fields.vendorsDisclosed]: VendorVectorEncoder,
    [Fields.vendorsAllowed]: VendorVectorEncoder,
    [Fields.publisherConsents]: FixedVectorEncoder,
    [Fields.publisherLegitimateInterests]: FixedVectorEncoder,
    [Fields.numCustomPurposes]: IntEncoder,
    [Fields.publisherCustomConsents]: FixedVectorEncoder,
    [Fields.publisherCustomLegitimateInterests]: FixedVectorEncoder
  };
}
;// CONCATENATED MODULE: ./node_modules/@iabtechlabtcf/core/lib/mjs/encoder/field/index.js









;// CONCATENATED MODULE: ./node_modules/@iabtechlabtcf/core/lib/mjs/encoder/sequence/FieldSequence.js


class FieldSequence {
  constructor() {
    _defineProperty(this, '1', {
      [Segment.CORE]: [Fields.version, Fields.created, Fields.lastUpdated, Fields.cmpId, Fields.cmpVersion, Fields.consentScreen, Fields.consentLanguage, Fields.vendorListVersion, Fields.purposeConsents, Fields.vendorConsents]
    });
    _defineProperty(this, '2', {
      [Segment.CORE]: [Fields.version, Fields.created, Fields.lastUpdated, Fields.cmpId, Fields.cmpVersion, Fields.consentScreen, Fields.consentLanguage, Fields.vendorListVersion, Fields.policyVersion, Fields.isServiceSpecific, Fields.useNonStandardTexts, Fields.specialFeatureOptins, Fields.purposeConsents, Fields.purposeLegitimateInterests, Fields.purposeOneTreatment, Fields.publisherCountryCode, Fields.vendorConsents, Fields.vendorLegitimateInterests, Fields.publisherRestrictions],
      [Segment.PUBLISHER_TC]: [Fields.publisherConsents, Fields.publisherLegitimateInterests, Fields.numCustomPurposes, Fields.publisherCustomConsents, Fields.publisherCustomLegitimateInterests],
      [Segment.VENDORS_ALLOWED]: [Fields.vendorsAllowed],
      [Segment.VENDORS_DISCLOSED]: [Fields.vendorsDisclosed]
    });
  }
}
;// CONCATENATED MODULE: ./node_modules/@iabtechlabtcf/core/lib/mjs/encoder/sequence/SegmentSequence.js


class SegmentSequence {
  constructor(tcModel, options) {
    _defineProperty(this, '1', [Segment.CORE]);
    _defineProperty(this, '2', [Segment.CORE]);
    if (tcModel.version === 2) {
      if (tcModel.isServiceSpecific) {
        /**
         * If it's service specific only, then the publisher TC String can be
         * stored in the cookie and would be transmitted if it's not for
         * storage.  So it's included regardless of whether or not it's for
         * saving or the cmp api to surface.
         */
        this['2'].push(Segment.PUBLISHER_TC);
      } else {
        const isForVendors = !!(options && options.isForVendors);
        /**
         * including vendors disclosed only if it is for saving (to the global
         * scope and not for vendors through the CMP API) or supportOOB is
         * turned on (either or both).  The compliment of this being not for
         * saving (surfaced to CMP) and no support of OOB.
         */
        if (!isForVendors || tcModel[Fields.supportOOB] === true) {
          this['2'].push(Segment.VENDORS_DISCLOSED);
        }
        if (isForVendors) {
          /**
           * If a publisher does support OOB and they have narrowed the allowed
           * vendors to utilize it, then we should include the vendors allowed
           * segment.  If it is empty then there are no restrictions, if that
           * is intended to mean no support for OOB, then the flag should be
           * set for that instead.
           *
           */
          if (tcModel[Fields.supportOOB] && tcModel[Fields.vendorsAllowed].size > 0) {
            this['2'].push(Segment.VENDORS_ALLOWED);
          }
          /**
           * Always include the publisher TC segment as long as this TC string
           * is not intended to be saved in the global scope.
           */
          this['2'].push(Segment.PUBLISHER_TC);
        }
      }
    }
  }
}
;// CONCATENATED MODULE: ./node_modules/@iabtechlabtcf/core/lib/mjs/encoder/sequence/index.js
// created from 'create-ts-index'



;// CONCATENATED MODULE: ./node_modules/@iabtechlabtcf/core/lib/mjs/encoder/SegmentEncoder.js








class SegmentEncoder {
  static encode(tcModel, segment) {
    let sequence;
    try {
      sequence = this.fieldSequence[String(tcModel.version)][segment];
    } catch (err) {
      throw new EncodingError(`Unable to encode version: ${tcModel.version}, segment: ${segment}`);
    }
    let bitField = '';
    /**
     * If this is anything other than the core segment we have a "segment id"
     * to append to the front of the string
     */
    if (segment !== Segment.CORE) {
      bitField = IntEncoder.encode(SegmentIDs.KEY_TO_ID[segment], BitLength.segmentType);
    }
    const fieldEncoderMap = FieldEncoderMap();
    sequence.forEach(key => {
      const value = tcModel[key];
      const encoder = fieldEncoderMap[key];
      let numBits = BitLength[key];
      if (numBits === undefined) {
        if (this.isPublisherCustom(key)) {
          /**
           * publisherCustom[Consents | LegitimateInterests] are an edge case
           * because they are of variable length. The length is defined in a
           * separate field named numCustomPurposes.
           */
          numBits = Number(tcModel[Fields.numCustomPurposes]);
        }
      }
      try {
        bitField += encoder.encode(value, numBits);
      } catch (err) {
        throw new EncodingError(`Error encoding ${segment}->${key}: ${err.message}`);
      }
    });
    // base64url encode the string and return
    return Base64Url.encode(bitField);
  }
  static decode(encodedString, tcModel, segment) {
    const bitField = Base64Url.decode(encodedString);
    let bStringIdx = 0;
    if (segment === Segment.CORE) {
      tcModel.version = IntEncoder.decode(bitField.substr(bStringIdx, BitLength[Fields.version]), BitLength[Fields.version]);
    }
    if (segment !== Segment.CORE) {
      bStringIdx += BitLength.segmentType;
    }
    const sequence = this.fieldSequence[String(tcModel.version)][segment];
    const fieldEncoderMap = FieldEncoderMap();
    sequence.forEach(key => {
      const encoder = fieldEncoderMap[key];
      let numBits = BitLength[key];
      if (numBits === undefined) {
        if (this.isPublisherCustom(key)) {
          /**
           * publisherCustom[Consents | LegitimateInterests] are an edge case
           * because they are of variable length. The length is defined in a
           * separate field named numCustomPurposes.
           */
          numBits = Number(tcModel[Fields.numCustomPurposes]);
        }
      }
      if (numBits !== 0) {
        /**
         * numBits could be 0 if this is a publisher custom purposes field and
         * no custom purposes are defined. If that is the case, we don't need
         * to gather no bits and we don't need to increment our bStringIdx
         * pointer because those would all be 0 increments and would mess up
         * the next logical if statement.
         */
        const bits = bitField.substr(bStringIdx, numBits);
        if (encoder === VendorVectorEncoder) {
          tcModel[key] = encoder.decode(bits, tcModel.version);
        } else {
          tcModel[key] = encoder.decode(bits, numBits);
        }
        if (Number.isInteger(numBits)) {
          bStringIdx += numBits;
        } else if (Number.isInteger(tcModel[key].bitLength)) {
          bStringIdx += tcModel[key].bitLength;
        } else {
          throw new DecodingError(key);
        }
      }
    });
    return tcModel;
  }
  static isPublisherCustom(key) {
    return key.indexOf('publisherCustom') === 0;
  }
}
_defineProperty(SegmentEncoder, "fieldSequence", new FieldSequence());
;// CONCATENATED MODULE: ./node_modules/@iabtechlabtcf/core/lib/mjs/encoder/SemanticPreEncoder.js



class SemanticPreEncoder {
  static process(tcModel, options) {
    const gvl = tcModel.gvl;
    if (!gvl) {
      throw new EncodingError('Unable to encode TCModel without a GVL');
    }
    if (!gvl.isReady) {
      throw new EncodingError('Unable to encode TCModel tcModel.gvl.readyPromise is not resolved');
    }
    tcModel = tcModel.clone();
    tcModel.consentLanguage = gvl.language.slice(0, 2).toUpperCase();
    if ((options === null || options === void 0 ? void 0 : options.version) > 0 && (options === null || options === void 0 ? void 0 : options.version) <= this.processor.length) {
      tcModel.version = options.version;
    } else {
      /**
       * this is equal to the latest or most current version
       */
      tcModel.version = this.processor.length;
    }
    const processorFunctionIndex = tcModel.version - 1;
    if (!this.processor[processorFunctionIndex]) {
      throw new EncodingError(`Invalid version: ${tcModel.version}`);
    }
    return this.processor[processorFunctionIndex](tcModel, gvl);
  }
}
_defineProperty(SemanticPreEncoder, "processor", [tcModel => tcModel, (tcModel, gvl) => {
  /**
   * in case this wasn't set previously.  This should filter out invalid
   * purpose restrictions.
   */
  tcModel.publisherRestrictions.gvl = gvl;
  /**
   * Purpose 1 is never allowed to be true for legitimate interest
   * As of TCF v2.2 purposes 3,4,5 & 6 are not allowed to be true for LI
   */
  tcModel.purposeLegitimateInterests.unset([1, 3, 4, 5, 6]);
  /**
   * If a Vendor does not declare a purpose for consent or legitimate
   * interest they should not have a positive signal for it. This code
   * removes positive signals created mistakingly.
   */
  const vectorToIntMap = new Map();
  vectorToIntMap.set('legIntPurposes', tcModel.vendorLegitimateInterests);
  vectorToIntMap.set('purposes', tcModel.vendorConsents);
  vectorToIntMap.forEach((vector, gvlVendorKey) => {
    vector.forEach((value, vendorId) => {
      if (value) {
        const vendor = gvl.vendors[vendorId];
        if (!vendor || vendor.deletedDate) {
          /**
           * If the vendor doesn't exist, then they should not receive a
           * positive signal
           */
          vector.unset(vendorId);
        } else if (vendor[gvlVendorKey].length === 0) {
          if (gvlVendorKey === 'legIntPurposes' && vendor['purposes'].length === 0 && vendor['legIntPurposes'].length === 0 && vendor['specialPurposes'].length > 0) {
            /**
             * Per June 2021 Policy change, Vendors declaring only Special Purposes must
             * have their legitimate interest Vendor bit set if they have been disclosed.
             * This empty block ensures their LI bit remains set
             */
          } else {
            /**
             * If the vendor does exist, but they haven't declared any
             * purposes for this legal basis, then we need to see if they can
             * possibly have the legal basis from their flexible purposes.
             */
            if (tcModel.isServiceSpecific) {
              if (vendor.flexiblePurposes.length === 0) {
                /**
                 * No flexible basis for any purposes, so we can safely remove
                 * this vendor from the legal basis.
                 */
                vector.unset(vendorId);
              } else {
                /**
                 * They have some flexible purposes, we should check for a
                 * publisher restriction value that would enable this vendor to
                 * have the override-preferred basis.
                 */
                const restrictions = tcModel.publisherRestrictions.getRestrictions(vendorId);
                let isValid = false;
                for (let i = 0, len = restrictions.length; i < len && !isValid; i++) {
                  /**
                   * If this condition is true the loop will break.  If we are
                   * dealing with the consent purposes ('purposes') and the
                   * publisher restriction overrides to consent then it is
                   * valid for the vendor to have a positive signal for
                   * consent.  Likewise for legitimate interest purposes
                   * ('legIntPurposes') and requiring legitimate interest.
                   */
                  isValid = restrictions[i].restrictionType === RestrictionType.REQUIRE_CONSENT && gvlVendorKey === 'purposes' || restrictions[i].restrictionType === RestrictionType.REQUIRE_LI && gvlVendorKey === 'legIntPurposes';
                }
                if (!isValid) {
                  /**
                   * if we came through the previous  loop without finding a
                   * valid reasing: no overriding restrictions (changes in
                   * legal basis) then it's not valid for this vendor to have
                   * this legal basis.
                   */
                  vector.unset(vendorId);
                }
              }
            } else {
              /**
               * This is a globally-scoped string so flexible purposes will not
               * be able to change this value because purposeRestrictions only
               * apply to service-specific strings.
               */
              vector.unset(vendorId);
            }
          }
        }
      }
    });
  });
  tcModel.vendorsDisclosed.set(gvl.vendors);
  return tcModel;
}]);
;// CONCATENATED MODULE: ./node_modules/@iabtechlabtcf/core/lib/mjs/encoder/index.js







;// CONCATENATED MODULE: ./node_modules/@iabtechlabtcf/core/lib/mjs/errors/GVLError.js
/**
 * class for General GVL Errors
 *
 * @extends {Error}
 */
class GVLError extends Error {
  /**
   * constructor - constructs a GVLError
   *
   * @param {string} msg - Error message to display
   * @return {undefined}
   */
  constructor(msg) {
    super(msg);
    this.name = 'GVLError';
  }
}

;// CONCATENATED MODULE: ./node_modules/@iabtechlabtcf/core/lib/mjs/Json.js
class Json {
  static absCall(url, body, sendCookies, timeout) {
    return new Promise((resolve, reject) => {
      const req = new XMLHttpRequest();
      const onLoad = () => {
        // is the response done
        if (req.readyState == XMLHttpRequest.DONE) {
          /**
           * For our purposes if it's not a 200 range response, then it's a
           * failure.
           */
          if (req.status >= 200 && req.status < 300) {
            let response = req.response;
            if (typeof response === 'string') {
              try {
                response = JSON.parse(response);
              } catch (e) {}
            }
            resolve(response);
          } else {
            reject(new Error(`HTTP Status: ${req.status} response type: ${req.responseType}`));
          }
        }
      };
      const onError = () => {
        reject(new Error('error'));
      };
      const onAbort = () => {
        reject(new Error('aborted'));
      };
      const onTimeout = () => {
        reject(new Error('Timeout ' + timeout + 'ms ' + url));
      };
      req.withCredentials = sendCookies;
      req.addEventListener('load', onLoad);
      req.addEventListener('error', onError);
      req.addEventListener('abort', onAbort);
      if (body === null) {
        req.open('GET', url, true);
      } else {
        req.open('POST', url, true);
      }
      req.responseType = 'json';
      // IE has a problem if this is before the open
      req.timeout = timeout;
      req.ontimeout = onTimeout;
      req.send(body);
    });
  }
  /**
   * @static
   * @param {string} url - full path to POST to
   * @param {object} body - JSON object to post
   * @param {boolean} sendCookies - Whether or not to send the XMLHttpRequest with credentials or not
   * @param {number} [timeout] - optional timeout in milliseconds
   * @return {Promise<object>} - if the server responds the response will be returned here
   */
  static post(url, body) {
    let sendCookies = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    let timeout = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    return this.absCall(url, JSON.stringify(body), sendCookies, timeout);
  }
  /**
   * @static
   * @param {string} url - full path to the json
   * @param {boolean} sendCookies - Whether or not to send the XMLHttpRequest with credentials or not
   * @param {number} [timeout] - optional timeout in milliseconds
   * @return {Promise<object>} - resolves with parsed JSON
   */
  static fetch(url) {
    let sendCookies = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    let timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    return this.absCall(url, null, sendCookies, timeout);
  }
}
;// CONCATENATED MODULE: ./node_modules/@iabtechlabtcf/core/lib/mjs/GVL.js





/**
 * class with utilities for managing the global vendor list.  Will use JSON to
 * fetch the vendor list from specified url and will serialize it into this
 * object and provide accessors.  Provides ways to group vendors on the list by
 * purpose and feature.
 */
class GVL extends Cloneable {
  /**
   * baseUrl - Entities using the vendor-list.json are required by the iab to
   * host their own copy of it to reduce the load on the iab's infrastructure
   * so a 'base' url must be set to be put together with the versioning scheme
   * of the filenames.
   *
   * @static
   * @param {string} url - the base url to load the vendor-list.json from.  This is
   * broken out from the filename because it follows a different scheme for
   * latest file vs versioned files.
   *
   * @throws {GVLError} - If the url is http[s]://vendorlist.consensu.org/...
   * this will throw an error.  IAB Europe requires that that CMPs and Vendors
   * cache their own copies of the GVL to minimize load on their
   * infrastructure.  For more information regarding caching of the
   * vendor-list.json, please see [the TCF documentation on 'Caching the Global
   * Vendor List'
   * ](https://github.com/InteractiveAdvertisingBureau/GDPR-Transparency-and-Consent-Framework/blob/master/TCFv2/IAB%20Tech%20Lab%20-%20Consent%20string%20and%20vendor%20list%20formats%20v2.md#caching-the-global-vendor-list)
   */
  static set baseUrl(url) {
    const notValid = /^https?:\/\/vendorlist\.consensu\.org\//;
    if (notValid.test(url)) {
      throw new GVLError('Invalid baseUrl!  You may not pull directly from vendorlist.consensu.org and must provide your own cache');
    }
    // if a trailing slash was forgotten
    if (url.length > 0 && url[url.length - 1] !== '/') {
      url += '/';
    }
    this.baseUrl_ = url;
  }
  /**
   * baseUrl - Entities using the vendor-list.json are required by the iab to
   * host their own copy of it to reduce the load on the iab's infrastructure
   * so a 'base' url must be set to be put together with the versioning scheme
   * of the filenames.
   *
   * @static
   * @return {string} - returns the previously set baseUrl, the default is
   * `undefined`
   */
  static get baseUrl() {
    return this.baseUrl_;
  }
  /**
   * @static
   * @param {string} - the latest is assumed to be vendor-list.json because
   * that is what the iab uses, but it could be different... if you want
   */

  /**
   * @param {VersionOrVendorList} [versionOrVendorList] - can be either a
   * [[VendorList]] object or a version number represented as a string or
   * number to download.  If nothing is passed the latest version of the GVL
   * will be loaded
   */
  constructor(versionOrVendorList) {
    super();
    /**
     * should have been configured before and instance was created and will
     * persist through the app
     */
    /**
     * @param {Promise} resolved when this GVL object is populated with the data
     * or rejected if there is an error.
     */
    _defineProperty(this, "readyPromise", void 0);
    /**
     * @param {number} gvlSpecificationVersion - schema version for the GVL that is used
     */
    _defineProperty(this, "gvlSpecificationVersion", void 0);
    /**
     * @param {number} incremented with each published file change
     */
    _defineProperty(this, "vendorListVersion", void 0);
    /**
     * @param {number} tcfPolicyVersion - The TCF MO will increment this value
     * whenever a GVL change (such as adding a new Purpose or Feature or a change
     * in Purpose wording) legally invalidates existing TC Strings and requires
     * CMPs to re-establish transparency and consent from users. If the policy
     * version number in the latest GVL is different from the value in your TC
     * String, then you need to re-establish transparency and consent for that
     * user. A version 1 format TC String is considered to have a version value
     * of 1.
     */
    _defineProperty(this, "tcfPolicyVersion", void 0);
    /**
     * @param {string | Date} lastUpdated - the date in which the vendor list
     * json file  was last updated.
     */
    _defineProperty(this, "lastUpdated", void 0);
    /**
     * @param {IntMap<Purpose>} a collection of [[Purpose]]s
     */
    _defineProperty(this, "purposes", void 0);
    /**
     * @param {IntMap<Purpose>} a collection of [[Purpose]]s
     */
    _defineProperty(this, "specialPurposes", void 0);
    /**
     * @param {IntMap<Feature>} a collection of [[Feature]]s
     */
    _defineProperty(this, "features", void 0);
    /**
     * @param {IntMap<Feature>} a collection of [[Feature]]s
     */
    _defineProperty(this, "specialFeatures", void 0);
    /**
     * @param {boolean} internal reference of when the GVL is ready to be used
     */
    _defineProperty(this, "isReady_", false);
    /**
     * @param {IntMap<Vendor>} a collection of [[Vendor]]s
     */
    _defineProperty(this, "vendors_", void 0);
    _defineProperty(this, "vendorIds", void 0);
    /**
     * @param {IntMap<Vendor>} a collection of [[Vendor]]. Used as a backup if a whitelist is sets
     */
    _defineProperty(this, "fullVendorList", void 0);
    /**
     * @param {ByPurposeVendorMap} vendors by purpose
     */
    _defineProperty(this, "byPurposeVendorMap", void 0);
    /**
     * @param {IDSetMap} vendors by special purpose
     */
    _defineProperty(this, "bySpecialPurposeVendorMap", void 0);
    /**
     * @param {IDSetMap} vendors by feature
     */
    _defineProperty(this, "byFeatureVendorMap", void 0);
    /**
     * @param {IDSetMap} vendors by special feature
     */
    _defineProperty(this, "bySpecialFeatureVendorMap", void 0);
    /**
     * @param {IntMap<Stack>} a collection of [[Stack]]s
     */
    _defineProperty(this, "stacks", void 0);
    /**
     * @param {IntMap<DataCategory>} a collection of [[DataCategory]]s
     */
    _defineProperty(this, "dataCategories", void 0);
    _defineProperty(this, "lang_", void 0);
    _defineProperty(this, "cacheLang_", void 0);
    _defineProperty(this, "isLatest", false);
    let url = GVL.baseUrl;
    this.lang_ = GVL.DEFAULT_LANGUAGE;
    this.cacheLang_ = GVL.DEFAULT_LANGUAGE;
    if (this.isVendorList(versionOrVendorList)) {
      this.populate(versionOrVendorList);
      this.readyPromise = Promise.resolve();
    } else {
      if (!url) {
        throw new GVLError('must specify GVL.baseUrl before loading GVL json');
      }
      if (versionOrVendorList > 0) {
        const version = versionOrVendorList;
        if (GVL.CACHE.has(version)) {
          this.populate(GVL.CACHE.get(version));
          this.readyPromise = Promise.resolve();
        } else {
          // load version specified
          url += GVL.versionedFilename.replace('[VERSION]', String(version));
          this.readyPromise = this.fetchJson(url);
        }
      } else {
        /**
         * whatever it is (or isn't)... it doesn't matter we'll just get the
         * latest. In this case we may have cached the latest version at key 0.
         * If we have then we'll just use that instead of making a request.
         * Otherwise we'll have to load it (and then we'll cache it for next
         * time)
         */
        if (GVL.CACHE.has(GVL.LATEST_CACHE_KEY)) {
          this.populate(GVL.CACHE.get(GVL.LATEST_CACHE_KEY));
          this.readyPromise = Promise.resolve();
        } else {
          this.isLatest = true;
          this.readyPromise = this.fetchJson(url + GVL.latestFilename);
        }
      }
    }
  }
  /**
   * emptyLanguageCache
   *
   * @param {string} [lang] - Optional language code to remove from
   * the cache.  Should be one of the languages in GVL.consentLanguages set.
   * If not then the whole cache will be deleted.
   * @return {boolean} - true if anything was deleted from the cache
   */
  static emptyLanguageCache(lang) {
    let result = false;
    if (lang == null && GVL.LANGUAGE_CACHE.size > 0) {
      GVL.LANGUAGE_CACHE = new Map();
      result = true;
    } else if (typeof lang === 'string' && this.consentLanguages.has(lang.toUpperCase())) {
      GVL.LANGUAGE_CACHE.delete(lang.toUpperCase());
      result = true;
    }
    return result;
  }
  /**
   * emptyCache
   *
   * @param {number} [vendorListVersion] - version of the vendor list to delete
   * from the cache.  If none is specified then the whole cache is deleted.
   * @return {boolean} - true if anything was deleted from the cache
   */
  static emptyCache(vendorListVersion) {
    let retr = false;
    if (Number.isInteger(vendorListVersion) && vendorListVersion >= 0) {
      GVL.CACHE.delete(vendorListVersion);
      retr = true;
    } else if (vendorListVersion === undefined) {
      GVL.CACHE = new Map();
      retr = true;
    }
    return retr;
  }
  cacheLanguage() {
    if (!GVL.LANGUAGE_CACHE.has(this.cacheLang_)) {
      GVL.LANGUAGE_CACHE.set(this.cacheLang_, {
        purposes: this.purposes,
        specialPurposes: this.specialPurposes,
        features: this.features,
        specialFeatures: this.specialFeatures,
        stacks: this.stacks,
        dataCategories: this.dataCategories
      });
    }
  }
  async fetchJson(url) {
    try {
      this.populate(await Json.fetch(url));
    } catch (err) {
      throw new GVLError(err.message);
    }
  }
  /**
   * getJson - Method for getting the JSON that was downloaded to created this
   * `GVL` object
   *
   * @return {VendorList} - The basic JSON structure without the extra
   * functionality and methods of this class.
   */
  getJson() {
    return JSON.parse(JSON.stringify({
      gvlSpecificationVersion: this.gvlSpecificationVersion,
      vendorListVersion: this.vendorListVersion,
      tcfPolicyVersion: this.tcfPolicyVersion,
      lastUpdated: this.lastUpdated,
      purposes: this.purposes,
      specialPurposes: this.specialPurposes,
      features: this.features,
      specialFeatures: this.specialFeatures,
      stacks: this.stacks,
      dataCategories: this.dataCategories,
      vendors: this.fullVendorList
    }));
  }
  /**
   * changeLanguage - retrieves the purpose language translation and sets the
   * internal language variable
   *
   * @param {string} lang - language code to change language to
   * @return {Promise<void | GVLError>} - returns the `readyPromise` and
   * resolves when this GVL is populated with the data from the language file.
   */
  async changeLanguage(lang) {
    let parsedLanguage = lang;
    try {
      parsedLanguage = GVL.consentLanguages.parseLanguage(lang);
    } catch (e) {
      throw new GVLError('Error during parsing the language: ' + e.message);
    }
    const cacheLang = lang.toUpperCase();
    // Default language EN can be loaded only by default GVL
    if (parsedLanguage.toLowerCase() === GVL.DEFAULT_LANGUAGE.toLowerCase() && !GVL.LANGUAGE_CACHE.has(cacheLang)) {
      return;
    }
    if (parsedLanguage !== this.lang_) {
      this.lang_ = parsedLanguage;
      if (GVL.LANGUAGE_CACHE.has(cacheLang)) {
        const cached = GVL.LANGUAGE_CACHE.get(cacheLang);
        for (const prop in cached) {
          if (cached.hasOwnProperty(prop)) {
            this[prop] = cached[prop];
          }
        }
      } else {
        // load Language specified
        const url = GVL.baseUrl + GVL.languageFilename.replace('[LANG]', this.lang_.toLowerCase());
        try {
          await this.fetchJson(url);
          this.cacheLang_ = cacheLang;
          this.cacheLanguage();
        } catch (err) {
          throw new GVLError('unable to load language: ' + err.message);
        }
      }
    }
  }
  get language() {
    return this.lang_;
  }
  isVendorList(gvlObject) {
    return gvlObject !== undefined && gvlObject.vendors !== undefined;
  }
  populate(gvlObject) {
    /**
     * these are populated regardless of whether it's a Declarations file or
     * a VendorList
     */
    this.purposes = gvlObject.purposes;
    this.specialPurposes = gvlObject.specialPurposes;
    this.features = gvlObject.features;
    this.specialFeatures = gvlObject.specialFeatures;
    this.stacks = gvlObject.stacks;
    this.dataCategories = gvlObject.dataCategories;
    if (this.isVendorList(gvlObject)) {
      this.gvlSpecificationVersion = gvlObject.gvlSpecificationVersion;
      this.tcfPolicyVersion = gvlObject.tcfPolicyVersion;
      this.vendorListVersion = gvlObject.vendorListVersion;
      this.lastUpdated = gvlObject.lastUpdated;
      if (typeof this.lastUpdated === 'string') {
        this.lastUpdated = new Date(this.lastUpdated);
      }
      this.vendors_ = gvlObject.vendors;
      this.fullVendorList = gvlObject.vendors;
      this.mapVendors();
      this.isReady_ = true;
      if (this.isLatest) {
        /**
         * If the "LATEST" was requested then this flag will be set to true.
         * In that case we'll cache the GVL at the special key
         */
        GVL.CACHE.set(GVL.LATEST_CACHE_KEY, this.getJson());
      }
      /**
       * Whether or not it's the "LATEST" we'll cache the gvl at the version it
       * is declared to be (if it's not already). to avoid downloading it again
       * in the future.
       */
      if (!GVL.CACHE.has(this.vendorListVersion)) {
        GVL.CACHE.set(this.vendorListVersion, this.getJson());
      }
    }
    this.cacheLanguage();
  }
  mapVendors(vendorIds) {
    // create new instances of the maps
    this.byPurposeVendorMap = {};
    this.bySpecialPurposeVendorMap = {};
    this.byFeatureVendorMap = {};
    this.bySpecialFeatureVendorMap = {};
    // initializes data structure for purpose map
    Object.keys(this.purposes).forEach(purposeId => {
      this.byPurposeVendorMap[purposeId] = {
        legInt: new Set(),
        consent: new Set(),
        flexible: new Set()
      };
    });
    // initializes data structure for special purpose map
    Object.keys(this.specialPurposes).forEach(purposeId => {
      this.bySpecialPurposeVendorMap[purposeId] = new Set();
    });
    // initializes data structure for feature map
    Object.keys(this.features).forEach(featureId => {
      this.byFeatureVendorMap[featureId] = new Set();
    });
    // initializes data structure for feature map
    Object.keys(this.specialFeatures).forEach(featureId => {
      this.bySpecialFeatureVendorMap[featureId] = new Set();
    });
    if (!Array.isArray(vendorIds)) {
      vendorIds = Object.keys(this.fullVendorList).map(vId => +vId);
    }
    this.vendorIds = new Set(vendorIds);
    // assigns vendor ids to their respective maps
    this.vendors_ = vendorIds.reduce((vendors, vendorId) => {
      const vendor = this.vendors_[String(vendorId)];
      if (vendor && vendor.deletedDate === undefined) {
        vendor.purposes.forEach(purposeId => {
          const purpGroup = this.byPurposeVendorMap[String(purposeId)];
          purpGroup.consent.add(vendorId);
        });
        vendor.specialPurposes.forEach(purposeId => {
          this.bySpecialPurposeVendorMap[String(purposeId)].add(vendorId);
        });
        vendor.legIntPurposes.forEach(purposeId => {
          this.byPurposeVendorMap[String(purposeId)].legInt.add(vendorId);
        });
        // could not be there
        if (vendor.flexiblePurposes) {
          vendor.flexiblePurposes.forEach(purposeId => {
            this.byPurposeVendorMap[String(purposeId)].flexible.add(vendorId);
          });
        }
        vendor.features.forEach(featureId => {
          this.byFeatureVendorMap[String(featureId)].add(vendorId);
        });
        vendor.specialFeatures.forEach(featureId => {
          this.bySpecialFeatureVendorMap[String(featureId)].add(vendorId);
        });
        vendors[vendorId] = vendor;
      }
      return vendors;
    }, {});
  }
  getFilteredVendors(purposeOrFeature, id, subType, special) {
    const properPurposeOrFeature = purposeOrFeature.charAt(0).toUpperCase() + purposeOrFeature.slice(1);
    let vendorSet;
    const retr = {};
    if (purposeOrFeature === 'purpose' && subType) {
      vendorSet = this['by' + properPurposeOrFeature + 'VendorMap'][String(id)][subType];
    } else {
      vendorSet = this['by' + (special ? 'Special' : '') + properPurposeOrFeature + 'VendorMap'][String(id)];
    }
    vendorSet.forEach(vendorId => {
      retr[String(vendorId)] = this.vendors[String(vendorId)];
    });
    return retr;
  }
  /**
   * getVendorsWithConsentPurpose
   *
   * @param {number} purposeId
   * @return {IntMap<Vendor>} - list of vendors that have declared the consent purpose id
   */
  getVendorsWithConsentPurpose(purposeId) {
    return this.getFilteredVendors('purpose', purposeId, 'consent');
  }
  /**
   * getVendorsWithLegIntPurpose
   *
   * @param {number} purposeId
   * @return {IntMap<Vendor>} - list of vendors that have declared the legInt (Legitimate Interest) purpose id
   */
  getVendorsWithLegIntPurpose(purposeId) {
    return this.getFilteredVendors('purpose', purposeId, 'legInt');
  }
  /**
   * getVendorsWithFlexiblePurpose
   *
   * @param {number} purposeId
   * @return {IntMap<Vendor>} - list of vendors that have declared the flexible purpose id
   */
  getVendorsWithFlexiblePurpose(purposeId) {
    return this.getFilteredVendors('purpose', purposeId, 'flexible');
  }
  /**
   * getVendorsWithSpecialPurpose
   *
   * @param {number} specialPurposeId
   * @return {IntMap<Vendor>} - list of vendors that have declared the special purpose id
   */
  getVendorsWithSpecialPurpose(specialPurposeId) {
    return this.getFilteredVendors('purpose', specialPurposeId, undefined, true);
  }
  /**
   * getVendorsWithFeature
   *
   * @param {number} featureId
   * @return {IntMap<Vendor>} - list of vendors that have declared the feature id
   */
  getVendorsWithFeature(featureId) {
    return this.getFilteredVendors('feature', featureId);
  }
  /**
   * getVendorsWithSpecialFeature
   *
   * @param {number} specialFeatureId
   * @return {IntMap<Vendor>} - list of vendors that have declared the special feature id
   */
  getVendorsWithSpecialFeature(specialFeatureId) {
    return this.getFilteredVendors('feature', specialFeatureId, undefined, true);
  }
  /**
   * vendors
   *
   * @return {IntMap<Vendor>} - the list of vendors as it would on the JSON file
   * except if `narrowVendorsTo` was called, it would be that narrowed list
   */
  get vendors() {
    return this.vendors_;
  }
  /**
   * narrowVendorsTo - narrows vendors represented in this GVL to the list of ids passed in
   *
   * @param {number[]} vendorIds - list of ids to narrow this GVL to
   * @return {void}
   */
  narrowVendorsTo(vendorIds) {
    this.mapVendors(vendorIds);
  }
  /**
   * isReady - Whether or not this instance is ready to be used.  This will be
   * immediately and synchronously true if a vendorlist object is passed into
   * the constructor or once the JSON vendorllist is retrieved.
   *
   * @return {boolean} whether or not the instance is ready to be interacted
   * with and all the data is populated
   */
  get isReady() {
    return this.isReady_;
  }
  /**
   * clone - overrides base `clone()` method since GVL is a special class that
   * represents a JSON structure with some additional functionality.
   *
   * @return {GVL}
   */
  clone() {
    const result = new GVL(this.getJson());
    /*
     * If the current language of the GVL is not the default language, we set the language of
     * the clone to the current language since a new GVL is always created with the default
     * language. */
    if (this.lang_ !== GVL.DEFAULT_LANGUAGE) {
      /*
       * Since the GVL language was changed, this means that an asynchronous changeLanguage
       * call was made prior to cloning the GVL.  The new language specified has been cached
       * by the GVL and this changeLanguage call made as a part of cloning the GVL will be
       * synchronous. The code will look for the language definitions in the cache instead
       * of creating a http request. */
      result.changeLanguage(this.lang_);
    }
    return result;
  }
  static isInstanceOf(questionableInstance) {
    const isSo = typeof questionableInstance === 'object';
    return isSo && typeof questionableInstance.narrowVendorsTo === 'function';
  }
}
_defineProperty(GVL, "LANGUAGE_CACHE", new Map());
_defineProperty(GVL, "CACHE", new Map());
_defineProperty(GVL, "LATEST_CACHE_KEY", 0);
_defineProperty(GVL, "DEFAULT_LANGUAGE", 'EN');
/**
 * Set of available consent languages published by the IAB
 */
_defineProperty(GVL, "consentLanguages", new ConsentLanguages());
_defineProperty(GVL, "baseUrl_", void 0);
_defineProperty(GVL, "latestFilename", 'vendor-list.json');
/**
 * @static
 * @param {string} - the versioned name is assumed to be
 * vendor-list-v[VERSION].json where [VERSION] will be replaced with the
 * specified version.  But it could be different... if you want just make
 * sure to include the [VERSION] macro if you have a numbering scheme, it's a
 * simple string substitution.
 *
 * eg.
 * ```javascript
 * GVL.baseUrl = "http://www.mydomain.com/iabcmp/";
 * GVL.versionedFilename = "vendorlist?getVersion=[VERSION]";
 * ```
 */
_defineProperty(GVL, "versionedFilename", 'archives/vendor-list-v[VERSION].json');
/**
 * @param {string} - Translations of the names and descriptions for Purposes,
 * Special Purposes, Features, and Special Features to non-English languages
 * are contained in a file where attributes containing English content
 * (except vendor declaration information) are translated.  The iab publishes
 * one following the scheme below where the LANG is the iso639-1 language
 * code.  For a list of available translations
 * [please go here](https://register.consensu.org/Translation).
 *
 * eg.
 * ```javascript
 * GVL.baseUrl = "http://www.mydomain.com/iabcmp/";
 * GVL.languageFilename = "purposes?getPurposes=[LANG]";
 * ```
 */
_defineProperty(GVL, "languageFilename", 'purposes-[LANG].json');
;// CONCATENATED MODULE: ./node_modules/@iabtechlabtcf/core/lib/mjs/TCModel.js





class TCModel extends Cloneable {
  /**
   * Constructs the TCModel. Passing a [[GVL]] is optional when constructing
   * as this TCModel may be constructed from decoding an existing encoded
   * TCString.
   *
   * @param {GVL} [gvl]
   */
  constructor(gvl) {
    super();
    _defineProperty(this, "isServiceSpecific_", false);
    _defineProperty(this, "supportOOB_", true);
    _defineProperty(this, "useNonStandardTexts_", false);
    _defineProperty(this, "purposeOneTreatment_", false);
    _defineProperty(this, "publisherCountryCode_", 'AA');
    _defineProperty(this, "version_", 2);
    _defineProperty(this, "consentScreen_", 0);
    _defineProperty(this, "policyVersion_", 4);
    _defineProperty(this, "consentLanguage_", 'EN');
    _defineProperty(this, "cmpId_", 0);
    _defineProperty(this, "cmpVersion_", 0);
    _defineProperty(this, "vendorListVersion_", 0);
    _defineProperty(this, "numCustomPurposes_", 0);
    // Member Variable for GVL
    _defineProperty(this, "gvl_", void 0);
    _defineProperty(this, "created", void 0);
    _defineProperty(this, "lastUpdated", void 0);
    /**
     * The TCF designates certain Features as special, that is, a CMP must afford
     * the user a means to opt in to their use. These Special Features are
     * published and numbered in the GVL separately from normal Features.
     * Provides for up to 12 special features.
     */
    _defineProperty(this, "specialFeatureOptins", new Vector());
    /**
     * Renamed from `PurposesAllowed` in TCF v1.1
     * The user’s consent value for each Purpose established on the legal basis
     * of consent. Purposes are published in the Global Vendor List (see. [[GVL]]).
     */
    _defineProperty(this, "purposeConsents", new Vector());
    /**
     * The user’s permission for each Purpose established on the legal basis of
     * legitimate interest. If the user has exercised right-to-object for a
     * purpose.
     */
    _defineProperty(this, "purposeLegitimateInterests", new Vector());
    /**
     * The user’s consent value for each Purpose established on the legal basis
     * of consent, for the publisher.  Purposes are published in the Global
     * Vendor List.
     */
    _defineProperty(this, "publisherConsents", new Vector());
    /**
     * The user’s permission for each Purpose established on the legal basis of
     * legitimate interest.  If the user has exercised right-to-object for a
     * purpose.
     */
    _defineProperty(this, "publisherLegitimateInterests", new Vector());
    /**
     * The user’s consent value for each Purpose established on the legal basis
     * of consent, for the publisher.  Purposes are published in the Global
     * Vendor List.
     */
    _defineProperty(this, "publisherCustomConsents", new Vector());
    /**
     * The user’s permission for each Purpose established on the legal basis of
     * legitimate interest.  If the user has exercised right-to-object for a
     * purpose that is established in the publisher's custom purposes.
     */
    _defineProperty(this, "publisherCustomLegitimateInterests", new Vector());
    /**
     * set by a publisher if they wish to collect consent and LI Transparency for
     * purposes outside of the TCF
     */
    _defineProperty(this, "customPurposes", void 0);
    /**
     * Each [[Vendor]] is keyed by id. Their consent value is true if it is in
     * the Vector
     */
    _defineProperty(this, "vendorConsents", new Vector());
    /**
     * Each [[Vendor]] is keyed by id. Whether their Legitimate Interests
     * Disclosures have been established is stored as boolean.
     * see: [[Vector]]
     */
    _defineProperty(this, "vendorLegitimateInterests", new Vector());
    /**
     * The value included for disclosed vendors signals which vendors have been
     * disclosed to the user in the interface surfaced by the CMP. This section
     * content is required when writing a TC string to the global (consensu)
     * scope. When a CMP has read from and is updating a TC string from the
     * global consensu.org storage, the CMP MUST retain the existing disclosure
     * information and only add information for vendors that it has disclosed
     * that had not been disclosed by other CMPs in prior interactions with this
     * device/user agent.
     */
    _defineProperty(this, "vendorsDisclosed", new Vector());
    /**
     * Signals which vendors the publisher permits to use OOB legal bases.
     */
    _defineProperty(this, "vendorsAllowed", new Vector());
    _defineProperty(this, "publisherRestrictions", new PurposeRestrictionVector());
    if (gvl) {
      this.gvl = gvl;
    }
    this.updated();
  }
  /**
   * sets the [[GVL]] with side effects of also setting the `vendorListVersion`, `policyVersion`, and `consentLanguage`
   * @param {GVL} gvl
   */
  set gvl(gvl) {
    /**
     * set the reference, but make sure it's our GVL wrapper class.
     */
    if (!GVL.isInstanceOf(gvl)) {
      gvl = new GVL(gvl);
    }
    this.gvl_ = gvl;
    this.publisherRestrictions.gvl = gvl;
  }
  /**
   * @return {GVL} the gvl instance set on this TCModel instance
   */
  get gvl() {
    return this.gvl_;
  }
  /**
   * @param {number} integer - A unique ID will be assigned to each Consent
   * Manager Provider (CMP) from the iab.
   *
   * @throws {TCModelError} if the value is not an integer greater than 1 as those are not valid.
   */
  set cmpId(integer) {
    integer = Number(integer);
    if (Number.isInteger(integer) && integer > 1) {
      this.cmpId_ = integer;
    } else {
      throw new TCModelError('cmpId', integer);
    }
  }
  get cmpId() {
    return this.cmpId_;
  }
  /**
   * Each change to an operating CMP should receive a
   * new version number, for logging proof of consent. CmpVersion defined by
   * each CMP.
   *
   * @param {number} integer
   *
   * @throws {TCModelError} if the value is not an integer greater than 1 as those are not valid.
   */
  set cmpVersion(integer) {
    integer = Number(integer);
    if (Number.isInteger(integer) && integer > -1) {
      this.cmpVersion_ = integer;
    } else {
      throw new TCModelError('cmpVersion', integer);
    }
  }
  get cmpVersion() {
    return this.cmpVersion_;
  }
  /**
   * The screen number is CMP and CmpVersion
   * specific, and is for logging proof of consent.(For example, a CMP could
   * keep records so that a publisher can request information about the context
   * in which consent was gathered.)
   *
   * @param {number} integer
   *
   * @throws {TCModelError} if the value is not an integer greater than 0 as those are not valid.
   */
  set consentScreen(integer) {
    integer = Number(integer);
    if (Number.isInteger(integer) && integer > -1) {
      this.consentScreen_ = integer;
    } else {
      throw new TCModelError('consentScreen', integer);
    }
  }
  get consentScreen() {
    return this.consentScreen_;
  }
  /**
   * @param {string} lang - [two-letter ISO 639-1 language
   * code](http://www.loc.gov/standards/iso639-2/php/code_list.php) in which
   * the CMP UI was presented
   *
   * @throws {TCModelError} if the value is not a length-2 string of alpha characters
   */
  set consentLanguage(lang) {
    this.consentLanguage_ = lang;
  }
  get consentLanguage() {
    return this.consentLanguage_;
  }
  /**
   * @param {string} countryCode - [two-letter ISO 3166-1 alpha-2 country
   * code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) of the publisher,
   * determined by the CMP-settings of the publisher.
   *
   * @throws {TCModelError} if the value is not a length-2 string of alpha characters
   */
  set publisherCountryCode(countryCode) {
    if (/^([A-z]){2}$/.test(countryCode)) {
      this.publisherCountryCode_ = countryCode.toUpperCase();
    } else {
      throw new TCModelError('publisherCountryCode', countryCode);
    }
  }
  get publisherCountryCode() {
    return this.publisherCountryCode_;
  }
  /**
   * Version of the GVL used to create this TCModel. Global
   * Vendor List versions will be released periodically.
   *
   * @param {number} integer
   *
   * @throws {TCModelError} if the value is not an integer greater than 0 as those are not valid.
   */
  set vendorListVersion(integer) {
    /**
     * first coerce to a number via leading '+' then take the integer value by
     * bitshifting to the right.  This works on all types in JavaScript and if
     * it's not valid then value will be 0.
     */
    integer = Number(integer) >> 0;
    if (integer < 0) {
      throw new TCModelError('vendorListVersion', integer);
    } else {
      this.vendorListVersion_ = integer;
    }
  }
  get vendorListVersion() {
    if (this.gvl) {
      return this.gvl.vendorListVersion;
    } else {
      return this.vendorListVersion_;
    }
  }
  /**
   * From the corresponding field in the GVL that was
   * used for obtaining consent. A new policy version invalidates existing
   * strings and requires CMPs to re-establish transparency and consent from
   * users.
   *
   * If a TCF policy version number is different from the one from the latest
   * GVL, the CMP must re-establish transparency and consent.
   *
   * @param {number} num - You do not need to set this.  This comes
   * directly from the [[GVL]].
   *
   */
  set policyVersion(num) {
    this.policyVersion_ = parseInt(num, 10);
    if (this.policyVersion_ < 0) {
      throw new TCModelError('policyVersion', num);
    }
  }
  get policyVersion() {
    if (this.gvl) {
      return this.gvl.tcfPolicyVersion;
    } else {
      return this.policyVersion_;
    }
  }
  set version(num) {
    this.version_ = parseInt(num, 10);
  }
  get version() {
    return this.version_;
  }
  /**
   * Whether the signals encoded in this TC String were from site-specific
   * storage `true` versus ‘global’ consensu.org shared storage `false`. A
   * string intended to be stored in global/shared scope but the CMP is unable
   * to store due to a user agent not accepting third-party cookies would be
   * considered site-specific `true`.
   *
   * @param {boolean} bool - value to set. Some changes to other fields in this
   * model will automatically change this value like adding publisher
   * restrictions.
   */
  set isServiceSpecific(bool) {
    this.isServiceSpecific_ = bool;
  }
  get isServiceSpecific() {
    return this.isServiceSpecific_;
  }
  /**
   * Non-standard stacks means that a CMP is using publisher-customized stack
   * descriptions. Stacks (in terms of purposes in a stack) are pre-set by the
   * IAB. As are titles. Descriptions are pre-set, but publishers can customize
   * them. If they do, they need to set this bit to indicate that they've
   * customized descriptions.
   *
   * @param {boolean} bool - value to set
   */
  set useNonStandardTexts(bool) {
    this.useNonStandardTexts_ = bool;
  }
  get useNonStandardTexts() {
    return this.useNonStandardTexts_;
  }
  /**
   * Whether or not this publisher supports OOB signaling.  On Global TC String
   * OOB Vendors Disclosed will be included if the publish wishes to no allow
   * these vendors they should set this to false.
   * @param {boolean} bool - value to set
   */
  set supportOOB(bool) {
    this.supportOOB_ = bool;
  }
  get supportOOB() {
    return this.supportOOB_;
  }
  /**
   * `false` There is no special Purpose 1 status.
   * Purpose 1 was disclosed normally (consent) as expected by Policy.  `true`
   * Purpose 1 not disclosed at all. CMPs use PublisherCC to indicate the
   * publisher’s country of establishment to help Vendors determine whether the
   * vendor requires Purpose 1 consent. In global scope TC strings, this field
   * must always have a value of `false`. When a CMP encounters a global scope
   * string with `purposeOneTreatment=true` then that string should be
   * considered invalid and the CMP must re-establish transparency and consent.
   *
   * @param {boolean} bool
   */
  set purposeOneTreatment(bool) {
    this.purposeOneTreatment_ = bool;
  }
  get purposeOneTreatment() {
    return this.purposeOneTreatment_;
  }
  /**
   * setAllVendorConsents - sets all vendors on the GVL Consent (true)
   *
   * @return {void}
   */
  setAllVendorConsents() {
    this.vendorConsents.set(this.gvl.vendors);
  }
  /**
   * unsetAllVendorConsents - unsets all vendors on the GVL Consent (false)
   *
   * @return {void}
   */
  unsetAllVendorConsents() {
    this.vendorConsents.empty();
  }
  /**
   * setAllVendorsDisclosed - sets all vendors on the GVL Vendors Disclosed (true)
   *
   * @return {void}
   */
  setAllVendorsDisclosed() {
    this.vendorsDisclosed.set(this.gvl.vendors);
  }
  /**
   * unsetAllVendorsDisclosed - unsets all vendors on the GVL Consent (false)
   *
   * @return {void}
   */
  unsetAllVendorsDisclosed() {
    this.vendorsDisclosed.empty();
  }
  /**
   * setAllVendorsAllowed - sets all vendors on the GVL Consent (true)
   *
   * @return {void}
   */
  setAllVendorsAllowed() {
    this.vendorsAllowed.set(this.gvl.vendors);
  }
  /**
   * unsetAllVendorsAllowed - unsets all vendors on the GVL Consent (false)
   *
   * @return {void}
   */
  unsetAllVendorsAllowed() {
    this.vendorsAllowed.empty();
  }
  /**
   * setAllVendorLegitimateInterests - sets all vendors on the GVL LegitimateInterests (true)
   *
   * @return {void}
   */
  setAllVendorLegitimateInterests() {
    this.vendorLegitimateInterests.set(this.gvl.vendors);
  }
  /**
   * unsetAllVendorLegitimateInterests - unsets all vendors on the GVL LegitimateInterests (false)
   *
   * @return {void}
   */
  unsetAllVendorLegitimateInterests() {
    this.vendorLegitimateInterests.empty();
  }
  /**
   * setAllPurposeConsents - sets all purposes on the GVL Consent (true)
   *
   * @return {void}
   */
  setAllPurposeConsents() {
    this.purposeConsents.set(this.gvl.purposes);
  }
  /**
   * unsetAllPurposeConsents - unsets all purposes on the GVL Consent (false)
   *
   * @return {void}
   */
  unsetAllPurposeConsents() {
    this.purposeConsents.empty();
  }
  /**
   * setAllPurposeLegitimateInterests - sets all purposes on the GVL LI Transparency (true)
   *
   * @return {void}
   */
  setAllPurposeLegitimateInterests() {
    this.purposeLegitimateInterests.set(this.gvl.purposes);
  }
  /**
   * unsetAllPurposeLegitimateInterests - unsets all purposes on the GVL LI Transparency (false)
   *
   * @return {void}
   */
  unsetAllPurposeLegitimateInterests() {
    this.purposeLegitimateInterests.empty();
  }
  /**
   * setAllSpecialFeatureOptins - sets all special featuresOptins on the GVL (true)
   *
   * @return {void}
   */
  setAllSpecialFeatureOptins() {
    this.specialFeatureOptins.set(this.gvl.specialFeatures);
  }
  /**
   * unsetAllSpecialFeatureOptins - unsets all special featuresOptins on the GVL (true)
   *
   * @return {void}
   */
  unsetAllSpecialFeatureOptins() {
    this.specialFeatureOptins.empty();
  }
  setAll() {
    this.setAllVendorConsents();
    this.setAllPurposeLegitimateInterests();
    this.setAllSpecialFeatureOptins();
    this.setAllPurposeConsents();
    this.setAllVendorLegitimateInterests();
  }
  unsetAll() {
    this.unsetAllVendorConsents();
    this.unsetAllPurposeLegitimateInterests();
    this.unsetAllSpecialFeatureOptins();
    this.unsetAllPurposeConsents();
    this.unsetAllVendorLegitimateInterests();
  }
  get numCustomPurposes() {
    let len = this.numCustomPurposes_;
    if (typeof this.customPurposes === 'object') {
      /**
       * Keys are not guaranteed to be in order and likewise there is no
       * requirement that the customPurposes be non-sparse.  So we have to sort
       * and take the highest value.  Even if the set only contains 3 purposes
       * but goes to ID 6 we need to set the number to 6 for the encoding to
       * work properly since it's positional.
       */
      const purposeIds = Object.keys(this.customPurposes).sort((a, b) => Number(a) - Number(b));
      len = parseInt(purposeIds.pop(), 10);
    }
    return len;
  }
  set numCustomPurposes(num) {
    this.numCustomPurposes_ = parseInt(num, 10);
    if (this.numCustomPurposes_ < 0) {
      throw new TCModelError('numCustomPurposes', num);
    }
  }
  /**
   * updated - updates the created and lastUpdated dates with a 'now' day-level UTC timestamp
   *
   * @return {void}
   */
  updated() {
    const date = new Date();
    const utcDate = new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate()));
    this.created = utcDate;
    this.lastUpdated = utcDate;
  }
}
/**
 * Set of available consent languages published by the IAB
 */
_defineProperty(TCModel, "consentLanguages", GVL.consentLanguages);
;// CONCATENATED MODULE: ./node_modules/@iabtechlabtcf/core/lib/mjs/TCString.js




/**
 * Main class for encoding and decoding a
 * TCF Transparency and Consent String
 */
class TCString {
  /**
   * encodes a model into a TCString
   *
   * @param {TCModel} tcModel - model to convert into encoded string
   * @param {EncodingOptions} options - for encoding options other than default
   * @return {string} - base64url encoded Transparency and Consent String
   */
  static encode(tcModel, options) {
    let out = '';
    let sequence;
    tcModel = SemanticPreEncoder.process(tcModel, options);
    /**
       * If they pass in a special segment sequence.
       */
    if (Array.isArray(options === null || options === void 0 ? void 0 : options.segments)) {
      sequence = options.segments;
    } else {
      sequence = new SegmentSequence(tcModel, options)['' + tcModel.version];
    }
    sequence.forEach((segment, idx) => {
      let dotMaybe = '';
      if (idx < sequence.length - 1) {
        dotMaybe = '.';
      }
      out += SegmentEncoder.encode(tcModel, segment) + dotMaybe;
    });
    return out;
  }
  /**
   * Decodes a string into a TCModel
   *
   * @param {string} encodedTCString - base64url encoded Transparency and
   * Consent String to decode - can also be a single or group of segments of
   * the string
   * @param {string} [tcModel] - model to enhance with the information.  If
   * none is passed a new instance of TCModel will be created.
   * @return {TCModel} - Returns populated TCModel
   */
  static decode(encodedTCString, tcModel) {
    const segments = encodedTCString.split('.');
    const len = segments.length;
    if (!tcModel) {
      tcModel = new TCModel();
    }
    for (let i = 0; i < len; i++) {
      const segString = segments[i];
      /**
       * first char will contain 6 bits, we only need the first 3. In version 1
       * and 2 of the TC string there is no segment type for the CORE string.
       * Instead the first 6 bits are reserved for the encoding version, but
       * because we're only on a maximum of encoding version 2 the first 3 bits
       * in the core segment will evaluate to 0.
       */
      const firstChar = Base64Url.decode(segString.charAt(0));
      const segTypeBits = firstChar.substr(0, BitLength.segmentType);
      const segment = SegmentIDs.ID_TO_KEY[IntEncoder.decode(segTypeBits, BitLength.segmentType).toString()];
      SegmentEncoder.decode(segString, tcModel, segment);
    }
    return tcModel;
  }
}
;// CONCATENATED MODULE: ./node_modules/@iabtechlabtcf/core/lib/mjs/index.js
// created from 'create-ts-index'









/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "static-main-no-minimization-eu/" + ({"522":"ui","735":"embeds"}[chunkId] || chunkId) + "." + {"207":"bb57","441":"0ffe","522":"a0bc","560":"7290","580":"f3b9","735":"d262","749":"1944"}[chunkId] + ".c.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get mini-css chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.miniCssF = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "static-main-no-minimization-eu/" + (chunkId === 522 ? "ui" : chunkId) + "." + {"441":"4a5f","522":"07cd","560":"dbf9","580":"a9d3"}[chunkId] + ".c.css";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "cookie-first-banner:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 		
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		__webpack_require__.p = "https://consent-eu.cookiefirst.com/banner/v2.15.3/";
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/css loading */
/******/ 	(() => {
/******/ 		if (typeof document === "undefined") return;
/******/ 		var createStylesheet = (chunkId, fullhref, oldTag, resolve, reject) => {
/******/ 			var linkTag = document.createElement("link");
/******/ 		
/******/ 			linkTag.rel = "stylesheet";
/******/ 			linkTag.type = "text/css";
/******/ 			var onLinkComplete = (event) => {
/******/ 				// avoid mem leaks.
/******/ 				linkTag.onerror = linkTag.onload = null;
/******/ 				if (event.type === 'load') {
/******/ 					resolve();
/******/ 				} else {
/******/ 					var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 					var realHref = event && event.target && event.target.href || fullhref;
/******/ 					var err = new Error("Loading CSS chunk " + chunkId + " failed.\n(" + realHref + ")");
/******/ 					err.code = "CSS_CHUNK_LOAD_FAILED";
/******/ 					err.type = errorType;
/******/ 					err.request = realHref;
/******/ 					if (linkTag.parentNode) linkTag.parentNode.removeChild(linkTag)
/******/ 					reject(err);
/******/ 				}
/******/ 			}
/******/ 			linkTag.onerror = linkTag.onload = onLinkComplete;
/******/ 			linkTag.href = fullhref;
/******/ 		
/******/ 			if (oldTag) {
/******/ 				oldTag.parentNode.insertBefore(linkTag, oldTag.nextSibling);
/******/ 			} else {
/******/ 				document.head.appendChild(linkTag);
/******/ 			}
/******/ 			return linkTag;
/******/ 		};
/******/ 		var findStylesheet = (href, fullhref) => {
/******/ 			var existingLinkTags = document.getElementsByTagName("link");
/******/ 			for(var i = 0; i < existingLinkTags.length; i++) {
/******/ 				var tag = existingLinkTags[i];
/******/ 				var dataHref = tag.getAttribute("data-href") || tag.getAttribute("href");
/******/ 				if(tag.rel === "stylesheet" && (dataHref === href || dataHref === fullhref)) return tag;
/******/ 			}
/******/ 			var existingStyleTags = document.getElementsByTagName("style");
/******/ 			for(var i = 0; i < existingStyleTags.length; i++) {
/******/ 				var tag = existingStyleTags[i];
/******/ 				var dataHref = tag.getAttribute("data-href");
/******/ 				if(dataHref === href || dataHref === fullhref) return tag;
/******/ 			}
/******/ 		};
/******/ 		var loadStylesheet = (chunkId) => {
/******/ 			return new Promise((resolve, reject) => {
/******/ 				var href = __webpack_require__.miniCssF(chunkId);
/******/ 				var fullhref = __webpack_require__.p + href;
/******/ 				if(findStylesheet(href, fullhref)) return resolve();
/******/ 				createStylesheet(chunkId, fullhref, null, resolve, reject);
/******/ 			});
/******/ 		}
/******/ 		// object to store loaded CSS chunks
/******/ 		var installedCssChunks = {
/******/ 			179: 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.miniCss = (chunkId, promises) => {
/******/ 			var cssChunks = {"441":1,"522":1,"560":1,"580":1};
/******/ 			if(installedCssChunks[chunkId]) promises.push(installedCssChunks[chunkId]);
/******/ 			else if(installedCssChunks[chunkId] !== 0 && cssChunks[chunkId]) {
/******/ 				promises.push(installedCssChunks[chunkId] = loadStylesheet(chunkId).then(() => {
/******/ 					installedCssChunks[chunkId] = 0;
/******/ 				}, (e) => {
/******/ 					delete installedCssChunks[chunkId];
/******/ 					throw e;
/******/ 				}));
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		// no hmr
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			179: 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.j = (chunkId, promises) => {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 		
/******/ 					// a Promise means "currently loading".
/******/ 					if(installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
/******/ 					} else {
/******/ 						if(true) { // all chunks have JS
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));
/******/ 							promises.push(installedChunkData[2] = promise);
/******/ 		
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = (event) => {
/******/ 								if(__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if(installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
/******/ 									}
/******/ 								}
/******/ 							};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 		};
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 		
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = globalThis["chunkCB"] = globalThis["chunkCB"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {

;// CONCATENATED MODULE: ./src/helpers/polyfills/promise-finally.ts
/* eslint-disable no-extend-native */if(!Promise.prototype.finally){// handle some old polyfills declaring Promise without "finally()"
// polyfill from https://learnersbucket.com/examples/interview/promise-finally-polyfill/
Promise.prototype.finally=function(callback){if(typeof callback!=='function'){return this.then(callback,callback);}// get the current promise or a new one
const P=this.constructor||Promise;// return the promise and call the callback function
// as soon as the promise is rejected or resolved with its value
return this.then(value=>P.resolve(callback()).then(()=>value),err=>P.resolve(callback()).then(()=>{throw err;}));};}
;// CONCATENATED MODULE: ./src/helpers/polyfills/polyfill-modern-browsers.ts

// EXTERNAL MODULE: ./src/helpers/logger.ts
var logger = __webpack_require__(6639);
// EXTERNAL MODULE: ./src/constants/errors.ts
var errors = __webpack_require__(6525);
// EXTERNAL MODULE: ./src/core/integrationSettings.ts
var integrationSettings = __webpack_require__(7108);
// EXTERNAL MODULE: ./src/constants/primitives.ts
var primitives = __webpack_require__(9083);
// EXTERNAL MODULE: ./src/helpers/api/getJson.ts
var getJson = __webpack_require__(8576);
// EXTERNAL MODULE: ./src/helpers/getStaticFileUrl.ts
var getStaticFileUrl = __webpack_require__(2446);
// EXTERNAL MODULE: ./src/helpers/report.ts
var report = __webpack_require__(7432);
// EXTERNAL MODULE: ./src/helpers/isArray.ts
var isArray = __webpack_require__(9264);
// EXTERNAL MODULE: ./src/helpers/createPromise.ts
var createPromise = __webpack_require__(2662);
// EXTERNAL MODULE: ./src/constants/dom.ts
var dom = __webpack_require__(4327);
;// CONCATENATED MODULE: ./src/helpers/getWildcardDomain.ts
const getWildcardDomain=()=>{const domain=dom/* _WINDOW_ */.X6.location.hostname.replace(/^www\./,"");// we need to define domainParts array here instead of
// using third argument passed to .map() callback because on magento websites
// prototype.js defines it's own .map() which doesn't pass it to callback
const domainParts=domain.split(".");const wildcardDomain=domainParts.map((part,index)=>{// don't edit main domain
if(index===0&&domainParts.length>2){return"*";}return part;}).filter(Boolean).join(".");return wildcardDomain;};/* harmony default export */ const helpers_getWildcardDomain = (getWildcardDomain);
;// CONCATENATED MODULE: ./src/helpers/init/getConfigFilesVersion.ts
const FILENAME='version.json';/**
 * Try to fetch version file from both main directory and wildcard version
 * Return fetched version and visitor country from file response header
 * and set the directory of successfull request as main dir for other files
 */const EMPTY_RESPONSE=[primitives/* NULL */.QV,primitives/* NULL */.QV,primitives/* NULL */.QV];const getConfigFilesVersion=preloadedSettings=>{const{dir,wildcardDir}=integrationSettings["default"];// use current time rounded to CACHE_SECONDS as version number for version file
const now=Date.now().toString();const URL=(0,getStaticFileUrl/* default */.Z)(`${dir}/${FILENAME}`,now);const WILDCARD_URL=(0,getStaticFileUrl/* default */.Z)(`${wildcardDir}/${FILENAME}`,now);return (0,createPromise/* default */.Z)(resolve=>{const getVersionJson=(url,dir)=>{(0,getJson/* default */.Z)(url).then(result=>resolve(prepareResponse(dir||'',result)),e=>{(0,report/* default */.Z)(e);resolve(EMPTY_RESPONSE);});};if(!dir&&!wildcardDir){return resolve(EMPTY_RESPONSE);}// Check if preloadedSettings has been properly downloaded (fallback for old embed that doesn't contain widgetConfig at this point)
if(preloadedSettings&&preloadedSettings.widgetConfig){const widgetConfig=preloadedSettings.widgetConfig;const wildcardDomain=helpers_getWildcardDomain();// Check if wildcard is enabled in settings and url is in dev urls
if(widgetConfig.isUsingWildcard&&widgetConfig.wildcardUrls.includes(wildcardDomain)){getVersionJson(WILDCARD_URL,wildcardDir);}else{getVersionJson(URL,dir);}}else{// Old way of getting version.js, in which we first try to get normal url, and then wildcard url because we don't know if wildcard has been enabled or not at this point
(0,getJson/* default */.Z)(URL).then(result=>{if((0,isArray/* default */.Z)(result)){resolve(prepareResponse(dir||"",result));}else{// throw error to advance to catch statement
throw new Error("");}},e=>{(0,report/* default */.Z)(e);if(!wildcardDir||wildcardDir===dir){return resolve(EMPTY_RESPONSE);}getVersionJson(WILDCARD_URL,wildcardDir);});}});};const prepareResponse=(dir,fetchResult)=>{const[res,headers]=fetchResult;const version=res.v||primitives/* NULL */.QV;const country=(headers["visitor-location"]||"").toUpperCase();const gpcValue=headers["Sec-GPC"]||"";// set this directory as main one
integrationSettings["default"].dir=dir;// return response
return[version,country||primitives/* NULL */.QV,gpcValue||null];};/* harmony default export */ const init_getConfigFilesVersion = (getConfigFilesVersion);
// EXTERNAL MODULE: ./src/helpers/isObject.ts
var isObject = __webpack_require__(7067);
;// CONCATENATED MODULE: ./src/helpers/init/getInitializationSettings.ts
const getInitializationSettings=()=>{const settings=window.__COOKIE_BANNER_SETTINGS__;if(!(0,isObject/* default */.Z)(settings)||(0,isArray/* default */.Z)(settings)){return primitives/* NULL */.QV;}return settings;};/* harmony default export */ const init_getInitializationSettings = (getInitializationSettings);
// EXTERNAL MODULE: ./src/core/config.ts
var core_config = __webpack_require__(2353);
;// CONCATENATED MODULE: ./src/helpers/init/getConfigFilesDirectory.ts
const getConfigFilesDirectory=apiKey=>{if(!apiKey){return[primitives/* NULL */.QV,primitives/* NULL */.QV];}const domain=dom/* _WINDOW_ */.X6.location.hostname.replace(/^www\./,"");const wildcardDomain=helpers_getWildcardDomain();return[`sites/${domain}-${apiKey}`,`sites/${wildcardDomain}-${apiKey}`];};/* harmony default export */ const init_getConfigFilesDirectory = (getConfigFilesDirectory);
// EXTERNAL MODULE: ./src/helpers/getLocalStorageItem.ts
var getLocalStorageItem = __webpack_require__(8915);
// EXTERNAL MODULE: ./src/helpers/objectKeys.ts
var objectKeys = __webpack_require__(1733);
// EXTERNAL MODULE: ./src/helpers/trim.ts
var trim = __webpack_require__(1511);
// EXTERNAL MODULE: ./src/helpers/includes.ts
var includes = __webpack_require__(8217);
;// CONCATENATED MODULE: ./src/helpers/init/getIntegrationSettings.ts
const API_KEY_ATTRIBUTE= false?0:'cookiefirst-key';const getTagAttribute=(tag,attr)=>{if((0,includes/* default */.Z)(tag.src,`${attr}=`)){return new URL(tag.src).searchParams.get(attr)||primitives/* NULL */.QV;}const value=tag.getAttribute(`data-${attr}`);if(value===""){// detect attribute added without value
return"";}return value||primitives/* NULL */.QV;};const getBooleanAttribute=(tag,attr)=>{const value=getTagAttribute(tag,attr);if(value===""){return primitives/* TRUE */.uX;}return (0,includes/* default */.Z)(["false","0"],value)?primitives/* FALSE */.Dv:!!value;};const getIntegrationSettings=preloadedSettings=>{if(preloadedSettings){for(const key of (0,objectKeys/* default */.Z)(preloadedSettings)){const val=preloadedSettings[key];if(typeof val!==primitives/* UNDEFINED_STRING */.qh){integrationSettings["default"].set(key,val);}}if(integrationSettings["default"].apiKey){const[dir,wildcardDir]=init_getConfigFilesDirectory(integrationSettings["default"].apiKey);integrationSettings["default"].dir=dir;integrationSettings["default"].wildcardDir=wildcardDir;}}const debugStorageKey=core_config/* GENERIC_PREFIX */.o$+"-debug";integrationSettings["default"].debugMode=(0,getLocalStorageItem/* default */.Z)(debugStorageKey,false)||(preloadedSettings&&preloadedSettings.debugMode)===true;if(integrationSettings["default"].debugMode){console.info(`debugMode: ${integrationSettings["default"].debugMode} `);integrationSettings["default"].silentMode=primitives/* FALSE */.Dv;}let tag=primitives/* NULL */.QV;if(true){if(false){}if(!tag){tag=dom/* _DOCUMENT_ */.uI.querySelector(`script[src*="${API_KEY_ATTRIBUTE}"],script[data-${API_KEY_ATTRIBUTE}]`);}}// in testing need to find the main script by attributes
// because current script will be the test execution script
if(!tag&&"production"==="test"){}// bail early if the script tag is not found
if(!tag){return;}// if this is a build for whitelabel clients, setup dynamic PUBLIC_URL and STATIC_FILES_URL
if(false){}// we have preloaded settings, don't read tag settings
if(preloadedSettings&&(0,objectKeys/* default */.Z)(preloadedSettings).length>0){return;}integrationSettings["default"].apiKey=getTagAttribute(tag,API_KEY_ATTRIBUTE)||"";// handle api keys with spaces around it
integrationSettings["default"].apiKey=(0,trim/* default */.Z)(integrationSettings["default"].apiKey||"");// detect dataLayer variable name
integrationSettings["default"].dataLayer=getTagAttribute(tag,"datalayer")||integrationSettings["default"].dataLayer;if(integrationSettings["default"].dataLayer==="true"){integrationSettings["default"].dataLayer="dataLayer";}integrationSettings["default"].stealthMode=getBooleanAttribute(tag,"stealth-mode");integrationSettings["default"].forcedLang=getTagAttribute(tag,"language");const[dir,wildcardDir]=init_getConfigFilesDirectory(integrationSettings["default"].apiKey);integrationSettings["default"].dir=dir;integrationSettings["default"].wildcardDir=wildcardDir;// enable verbose mode only when requested, default to silent mode
let silentMode=primitives/* TRUE */.uX;const silentModeAttr='silent-mode';if(integrationSettings["default"].debugMode){silentMode=primitives/* FALSE */.Dv;}else if(getTagAttribute(tag,silentModeAttr)!==null){silentMode=getBooleanAttribute(tag,silentModeAttr);}integrationSettings["default"].silentMode=silentMode;};/* harmony default export */ const init_getIntegrationSettings = (getIntegrationSettings);
// EXTERNAL MODULE: ./src/helpers/getCookie.ts
var getCookie = __webpack_require__(9368);
// EXTERNAL MODULE: ./src/helpers/saveLocalStorageItem.ts
var saveLocalStorageItem = __webpack_require__(5114);
;// CONCATENATED MODULE: ./src/helpers/consent/loadLocalVisitorId.ts
const loadLocalVisitorId=()=>{let id=(0,getLocalStorageItem/* default */.Z)(core_config/* VISITOR_ID_COOKIE */.MZ,null);if(!id){id=(0,getCookie/* default */.Z)(core_config/* VISITOR_ID_COOKIE */.MZ)||primitives/* NULL */.QV;(0,saveLocalStorageItem/* default */.Z)(core_config/* VISITOR_ID_COOKIE */.MZ,id);}return id;};/* harmony default export */ const consent_loadLocalVisitorId = (loadLocalVisitorId);
// EXTERNAL MODULE: ./src/helpers/init/WidgetConfig.ts + 1 modules
var WidgetConfig = __webpack_require__(9969);
;// CONCATENATED MODULE: ./src/helpers/init/loadSiteConfig.ts
const loadSiteConfig=(version,preloadConfig)=>{const{dir}=integrationSettings["default"];return (0,createPromise/* default */.Z)((resolve,reject)=>{if((0,isObject/* default */.Z)(preloadConfig)){(0,logger/* coreLogger */.cl)("preloaded config");const config=(0,WidgetConfig/* createWidgetConfig */.B)({...preloadConfig,version});return resolve(Object.freeze(config));}// load widget config for given site
const url=(0,getStaticFileUrl/* default */.Z)(`${dir}/config.json`,version);(0,logger/* coreLogger */.cl)(`load config from ${url}`);(0,getJson/* default */.Z)(url).then(_ref=>{let[res]=_ref;const config=(0,WidgetConfig/* createWidgetConfig */.B)({...res,version});resolve(Object.freeze(config));},e=>{(0,report/* default */.Z)(e);reject(e);});});};/* harmony default export */ const init_loadSiteConfig = (loadSiteConfig);
// EXTERNAL MODULE: ./src/constants/categories.ts
var constants_categories = __webpack_require__(2157);
// EXTERNAL MODULE: ./src/types/consent.ts
var types_consent = __webpack_require__(5304);
// EXTERNAL MODULE: ./src/helpers/consent/deleteLocalConsent.ts
var deleteLocalConsent = __webpack_require__(437);
// EXTERNAL MODULE: ./src/helpers/getTimestamp.ts
var getTimestamp = __webpack_require__(6007);
// EXTERNAL MODULE: ./src/helpers/dom/addEventListener.ts
var addEventListener = __webpack_require__(6048);
// EXTERNAL MODULE: ./src/helpers/dom/createElement.ts
var createElement = __webpack_require__(5992);
// EXTERNAL MODULE: ./src/helpers/dom/removeEventListener.ts
var removeEventListener = __webpack_require__(6828);
// EXTERNAL MODULE: ./src/helpers/randomString.ts
var randomString = __webpack_require__(2475);
// EXTERNAL MODULE: ./src/helpers/isString.ts
var isString = __webpack_require__(8060);
;// CONCATENATED MODULE: ./src/helpers/dom/getElementById.ts
const getElementById=id=>{return dom/* _DOCUMENT_ */.uI.getElementById(id);};/* harmony default export */ const dom_getElementById = (getElementById);
;// CONCATENATED MODULE: ./src/helpers/consent/BulkConsentManager.ts
const IFRAME_ID="bulk-consent";const TIMEOUT=9;// timeout in seconds to not wait infinitely for iframe response
/**
 * Creates a new iframe which loads code for cross-origin communication
 * And gives banner ability to read localstorage items from cookiefirst domain
 *
 * @param {string} iframeUrl - Iframe html file url
 * @return {HTMLIFrameElement}
 */const createIframe=(iframeUrl,loadCallback)=>{const iframe=(0,createElement/* default */.Z)("iframe");iframe.id=IFRAME_ID;iframe.setAttribute("tabindex","-1");iframe.setAttribute("role","presentation");iframe.setAttribute("aria-hidden","true");iframe.setAttribute("title","Bulk Consent");iframe.style.position="absolute";iframe.style.width="1px";iframe.style.height="1px";iframe.style.top="-9999px";iframe.onload=loadCallback;iframe.src=iframeUrl;// we need to insert the iframe into the <head> because at this point in time,
// <body> might not be available yet which would cause bulk to fail
dom/* _DOCUMENT_ */.uI.head.appendChild(iframe);return iframe;};/**
 * Returns the bulk consent iframe for cross-origin communication
 *
 * @param {string} id - Iframe ID
 * @return {HTMLIFrameElement}
 */const getIframe=function(){let id=arguments.length>0&&arguments[0]!==undefined?arguments[0]:"";const elem=dom_getElementById(id);if(!elem||elem.nodeName!=="IFRAME"){return primitives/* NULL */.QV;}return elem;};let __instance=null;const getBulkConsentManager=iframeUrl=>{if(__instance){return __instance;}let iframe=getIframe();let iframeLoaded=primitives/* FALSE */.Dv;const handledMessages=[];if(iframe){iframeLoaded=primitives/* TRUE */.uX;}__instance={sendMessage(message){return (0,createPromise/* default */.Z)((resolve,reject)=>{// bulk consent won't work in most browsers if iframe is on a different TLD than banner
// we should include a message for clients about it
// but so far we let it be, it still works in some browsers
// if (!includes(_WINDOW_.location.hostname, new URL(iframeUrl).hostname)) {
//   reject(new Error("Bulk iframe needs to be loaded from the same top level domain."));
//   return;
// }
let timeoutId=primitives/* NULL */.QV;const message_id=`bulk-msg-${(0,randomString/* default */.Z)()}`;if(!message){reject(new Error(errors/* BULK_SEND_FAILED */.XU));return;}// create iframe when sending first message to it
// don't create it in constructor as it will be called on all domains
// and we want iframe to init only on bulk-enabled domains
if(!iframe){if(!iframeUrl){reject(new Error(errors/* BULK_SEND_FAILED */.XU));return;}iframe=createIframe(iframeUrl,()=>{(0,logger/* bulkLogger */.G6)("iframe initialized");iframeLoaded=primitives/* TRUE */.uX;});}// handle postMessage response from iframe
const handleResponse=res=>{if(!iframe||res.source!==iframe.contentWindow){// res from some other window than our iframe, ignore it
(0,logger/* bulkLogger */.G6)("ignoring msg from another window",res);return;}try{const key=res.message?"message":"data";let data=res[key];if(!data){return;}if((0,isString/* default */.Z)(data)){data=JSON.parse(data);}if(!data.message_id||// weird message, not sure what to do with it
data.message_id!==message_id||// response for some other message than the one handled here
(0,includes/* default */.Z)(handledMessages,data.message_id)// message aready handled
){(0,logger/* bulkLogger */.G6)("ignoring msg:",data);return;}(0,logger/* bulkLogger */.G6)("received response");(0,removeEventListener/* default */.Z)(dom/* _WINDOW_ */.X6,"message",handleResponse,primitives/* FALSE */.Dv);handledMessages.push(message_id);timeoutId&&clearTimeout(timeoutId);if(!data.value){return resolve(primitives/* NULL */.QV);}if((0,isString/* default */.Z)(data.value)){try{const val=JSON.parse(data.value);return resolve(val);}catch(e){return resolve(primitives/* NULL */.QV);}}return resolve(data.value);}catch(e){(0,logger/* bulkLogger */.G6)(new Error("failed to read response"));(0,report/* default */.Z)(e);return reject();}};if(!iframe||!iframe.contentWindow){(0,logger/* bulkLogger */.G6)("failed to initialize.");return reject();}try{// listen for postMessage response from iframe
(0,addEventListener/* default */.Z)(dom/* _WINDOW_ */.X6,"message",handleResponse,primitives/* FALSE */.Dv);// send cookie get request to the iframe
const payload=JSON.stringify({...message,message_id});if(iframeLoaded){// send event now, if iframe is already loaded
iframe.contentWindow.postMessage(payload,"*");(0,logger/* bulkLogger */.G6)("send message");}else{(0,logger/* bulkLogger */.G6)("send message when ready");// send event on iframe load
iframe.onload=()=>{(0,logger/* bulkLogger */.G6)("iframe initialized");const frame=iframe;if(frame.contentWindow){iframeLoaded=primitives/* TRUE */.uX;frame.contentWindow.postMessage(payload,"*");(0,logger/* bulkLogger */.G6)("message sent");}};}// set timeout of TIMEOUT seconds to not wait indefinitely
timeoutId=setTimeout(()=>{(0,logger/* bulkLogger */.G6)(`reached timeout of ${TIMEOUT}s`);resolve(primitives/* NULL */.QV);},TIMEOUT*1000);}catch(e){(0,logger/* bulkLogger */.G6)("encountered an error",e);timeoutId&&clearTimeout(timeoutId);reject(e);return;}});}};return __instance;};
;// CONCATENATED MODULE: ./src/helpers/consent/loadBulkConsent.ts
const loadBulkConsent=bulkConfig=>{return (0,createPromise/* default */.Z)(resolve=>{const{id,iframeUrl}=bulkConfig;const msg={group_id:id,action:"get"};getBulkConsentManager(iframeUrl).sendMessage(msg).then(res=>{if(!res){return resolve(primitives/* NULL */.QV);}const timestamp=parseInt(res.timestamp||"0");resolve({action:(0,isString/* default */.Z)(res.action)?res.action||types_consent/* CONSENT_ACTION_STORE */.mX:types_consent/* CONSENT_ACTION_STORE */.mX,consent:res.consent||{},timestamp:isNaN(timestamp)?0:timestamp,type:res.type||types_consent/* CONSENT_TYPE_CATEGORY */.LV});},()=>resolve(primitives/* NULL */.QV));});};/* harmony default export */ const consent_loadBulkConsent = (loadBulkConsent);
// EXTERNAL MODULE: ./src/helpers/consent/loadLocalConsent.ts
var loadLocalConsent = __webpack_require__(9094);
;// CONCATENATED MODULE: ./src/helpers/consent/loadConsentFromStorage.ts
// this function loads consent from storage
const loadConsentFromStorage=widgetConfig=>{return (0,createPromise/* default */.Z)(resolve=>{const bulkConfig=widgetConfig.bulkConsent;if(!bulkConfig.id){return resolve((0,loadLocalConsent/* default */.Z)());}// try to load bulk consent
consent_loadBulkConsent(bulkConfig).then(res=>{if(res){const{action=types_consent/* CONSENT_ACTION_STORE */.mX,consent={},type=types_consent/* CONSENT_TYPE_CATEGORY */.LV,timestamp=(0,getTimestamp/* default */.Z)()}=res;// detected withdraw as last action in bulk consent, delete local consent data to start fresh
if(action===types_consent/* CONSENT_ACTION_RESET */.sD||action===types_consent/* CONSENT_ACTION_WITHDRAW */.qD){(0,logger/* bulkLogger */.G6)("detected ["+action+"] as last action");(0,deleteLocalConsent/* default */.Z)();return resolve(primitives/* NULL */.QV);}if(consent){(0,logger/* bulkLogger */.G6)("loaded");return resolve([consent,timestamp,type]);}}(0,logger/* bulkLogger */.G6)("no consent saved, trying local");return resolve((0,loadLocalConsent/* default */.Z)());},()=>resolve(primitives/* NULL */.QV));});};/* harmony default export */ const consent_loadConsentFromStorage = (loadConsentFromStorage);
;// CONCATENATED MODULE: ./src/helpers/consent/deleteBulkConsent.ts
const deleteBulkConsent=bulkConfig=>{const{id,iframeUrl}=bulkConfig;return (0,createPromise/* default */.Z)(resolve=>{const msg={group_id:id,action:"remove"};const manager=getBulkConsentManager(iframeUrl);manager.sendMessage(msg).then(res=>resolve(res),e=>{(0,logger/* bulkLogger */.G6)("Failed to delete bulk consent");(0,report/* default */.Z)(e);resolve(primitives/* NULL */.QV);});});};/* harmony default export */ const consent_deleteBulkConsent = (deleteBulkConsent);
;// CONCATENATED MODULE: ./src/helpers/consent/deleteConsent.ts
const deleteConsent=bulkConfig=>{return (0,createPromise/* default */.Z)(resolve=>{(0,deleteLocalConsent/* default */.Z)();if(bulkConfig.id){consent_deleteBulkConsent(bulkConfig).then(resolve);}else{resolve();}});};/* harmony default export */ const consent_deleteConsent = (deleteConsent);
// EXTERNAL MODULE: ./src/helpers/consent/hasConsentExpired.ts
var hasConsentExpired = __webpack_require__(5144);
// EXTERNAL MODULE: ./src/helpers/consent/isServiceAccepted.ts
var isServiceAccepted = __webpack_require__(5820);
// EXTERNAL MODULE: ./src/helpers/consent/makeGranularConsentObject.ts
var makeGranularConsentObject = __webpack_require__(3018);
;// CONCATENATED MODULE: ./src/helpers/consent/saveBulkConsent.ts
const saveBulkConsent=(bulkConfig,payload)=>{return (0,createPromise/* default */.Z)(resolve=>{const{id,iframeUrl}=bulkConfig;const msg={group_id:id,action:"set",consent:payload};const manager=getBulkConsentManager(iframeUrl);manager.sendMessage(msg).then(res=>resolve(),e=>{(0,logger/* bulkLogger */.G6)("Failed to save bulk consent",{error:e});resolve();});});};/* harmony default export */ const consent_saveBulkConsent = (saveBulkConsent);
;// CONCATENATED MODULE: ./src/helpers/consent/resetConsent.ts
const resetConsent=widgetConfig=>{return (0,createPromise/* default */.Z)(resolve=>{const{bulkConsent,consentType}=widgetConfig;(0,deleteLocalConsent/* default */.Z)();if(bulkConsent.id){consent_saveBulkConsent(bulkConsent,{action:types_consent/* CONSENT_ACTION_RESET */.sD,consent:{},timestamp:(0,getTimestamp/* default */.Z)(),type:consentType}).then(()=>resolve());}else{return resolve();}});};/* harmony default export */ const consent_resetConsent = (resetConsent);
// EXTERNAL MODULE: ./src/helpers/consent/shouldResetConsent.ts
var shouldResetConsent = __webpack_require__(4348);
;// CONCATENATED MODULE: ./src/helpers/consent/processConsentFromStorage.ts
// This function checks if consent should be reset/removed after being loaded
const processConsentFromStorage=function(consent){let consentTimestamp=arguments.length>1&&arguments[1]!==undefined?arguments[1]:primitives/* NULL */.QV;let consentType=arguments.length>2?arguments[2]:undefined;let widgetConfig=arguments.length>3&&arguments[3]!==undefined?arguments[3]:(0,WidgetConfig/* createWidgetConfig */.B)();return (0,createPromise/* default */.Z)(resolve=>{let storedConsent={...consent};const bulkConfig=widgetConfig.bulkConsent;const lastConsentReset=widgetConfig.lastConsentReset;const useGranularConsent=widgetConfig.isGranularPolicy;const scripts=widgetConfig.scripts;// check for expired consent
if(consentTimestamp&&(0,hasConsentExpired/* default */.Z)(consentTimestamp,widgetConfig.consentLifetime)){return consent_deleteConsent(bulkConfig).finally(()=>resolve(primitives/* NULL */.QV));}// check consent reset request
if(consentTimestamp&&(0,shouldResetConsent/* default */.Z)(consentTimestamp,lastConsentReset)){(0,logger/* consentLogger */.OM)("detected reset request, resetting...");return consent_resetConsent(widgetConfig).finally(()=>{(0,logger/* consentLogger */.OM)("reset success");resolve(primitives/* NULL */.QV);});}if(useGranularConsent){// convert category-based consent to script-based
if(!consentType||consentType===types_consent/* CONSENT_TYPE_CATEGORY */.LV){(0,logger/* consentLogger */.OM)("Convert category to granular");storedConsent=scripts.reduce((aggregate,script)=>{// script is accepted if every category is accepted
const isAccepted=(script.categories||[]).every(cat=>!!storedConsent[cat]);aggregate[script.consent_key]=isAccepted;return aggregate;},{...constants_categories/* EMPTY_CONSENT */.qc});}// from list of scripts and stored consent object,
// create final consent object
const finalConsent=(0,makeGranularConsentObject/* default */.Z)(storedConsent,widgetConfig);resolve({...finalConsent});return;}else{// convert script-based consent to category-based
if(consentType===types_consent/* CONSENT_TYPE_GRANULAR */.an){(0,logger/* consentLogger */.OM)("Convert granular to category");storedConsent=constants_categories/* categories */.bd.reduce((aggregate,cat)=>{if(cat===constants_categories/* NECESSARY */.a3){aggregate[cat]=true;return aggregate;}// find scripts with this category
const categoryScripts=scripts.filter(i=>{return (0,includes/* default */.Z)(i.categories,cat);});const acceptedScripts=categoryScripts.filter(script=>{return (0,isServiceAccepted/* default */.Z)(script,storedConsent,types_consent/* CONSENT_POLICY_GRANULAR_OPTIN */.Gc);});aggregate[cat]=acceptedScripts.length===categoryScripts.length;return aggregate;},{...constants_categories/* EMPTY_CONSENT */.qc});}const finalConsent=constants_categories/* categories */.bd.reduce((aggregate,cat)=>{aggregate[cat]=!!storedConsent[cat];return aggregate;},{...constants_categories/* EMPTY_CONSENT */.qc});resolve({...finalConsent});return;}});};/* harmony default export */ const consent_processConsentFromStorage = (processConsentFromStorage);
// EXTERNAL MODULE: ./src/constants/time.ts
var time = __webpack_require__(544);
// EXTERNAL MODULE: ./src/helpers/saveLocalCookie.ts
var saveLocalCookie = __webpack_require__(7234);
;// CONCATENATED MODULE: ./src/helpers/consent/saveLocalConsent.ts
/**
 * Saves consent in localstorage and first-party cookie
 *
 */const saveLocalConsent=function(consent){let timestamp=arguments.length>1&&arguments[1]!==undefined?arguments[1]:primitives/* NULL */.QV;let widgetConfig=arguments.length>2?arguments[2]:undefined;const cookieValue={...consent,timestamp,type:widgetConfig.consentType,version:widgetConfig.version};const lifetime=widgetConfig.consentLifetime||time/* YEAR_IN_SECONDS */.z;const cookieExpiry=(timestamp||(0,getTimestamp/* default */.Z)())+lifetime;(0,saveLocalStorageItem/* default */.Z)(core_config/* CONSENT_COOKIE */.Q8,cookieValue);(0,saveLocalCookie/* default */.Z)(core_config/* CONSENT_COOKIE */.Q8,JSON.stringify(cookieValue),cookieExpiry,widgetConfig.bulkConsent);};/* harmony default export */ const consent_saveLocalConsent = (saveLocalConsent);
// EXTERNAL MODULE: ./src/helpers/consent/shouldUseFullConsent.ts
var shouldUseFullConsent = __webpack_require__(1250);
;// CONCATENATED MODULE: ./src/helpers/consent/shouldUseEmptyConsent.ts
const shouldUseEmptyConsent=function(){let gpcValue=arguments.length>0&&arguments[0]!==undefined?arguments[0]:null;let isGpcAndDntEnabled=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;// when user has Do Not Track status or Global Privacy control set return true
const dnt=navigator.doNotTrack;if(isGpcAndDntEnabled&&(gpcValue==='1'||dnt==='1')){return primitives/* TRUE */.uX;}return primitives/* FALSE */.Dv;};/* harmony default export */ const consent_shouldUseEmptyConsent = (shouldUseEmptyConsent);
;// CONCATENATED MODULE: ./src/helpers/consent/loadUserConsent.ts
const NO_CONSENT_RESPONSE=[primitives/* NULL */.QV,primitives/* NULL */.QV];const loadUserConsent=function(widgetConfig){let visitorCountry=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;let visitorRegion=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;let gpcValue=arguments.length>3&&arguments[3]!==undefined?arguments[3]:null;return (0,createPromise/* default */.Z)(resolve=>{// if we should automatically act as if all categories were accepted, return full consent
const shouldUseFullConsentResponse=(0,shouldUseFullConsent/* default */.Z)(widgetConfig,visitorCountry,visitorRegion);// if we should automatically act as if user declined all categories, return empty consent
const shouldUsEmptyConsentResponse=consent_shouldUseEmptyConsent(gpcValue,widgetConfig.gpcAndDntEnabled);let consentResponse=NO_CONSENT_RESPONSE;if(shouldUsEmptyConsentResponse){(0,logger/* consentLogger */.OM)("use empty");consentResponse=[constants_categories/* EMPTY_CATEGORY_CONSENT */.Li,primitives/* NULL */.QV];}else if(shouldUseFullConsentResponse){(0,logger/* consentLogger */.OM)("use full");if(widgetConfig.isGranularPolicy){const fullConsent=widgetConfig.scripts.reduce((aggregate,script)=>({...aggregate,[script.consent_key]:primitives/* TRUE */.uX}),{});consentResponse=[fullConsent,primitives/* NULL */.QV];}else{const fullConsent=constants_categories/* categories */.bd.reduce((aggregate,cat)=>{aggregate[cat]=primitives/* TRUE */.uX;return aggregate;},{...constants_categories/* EMPTY_CONSENT */.qc});consentResponse=[fullConsent,primitives/* NULL */.QV];}}// load user consent from storage
consent_loadConsentFromStorage(widgetConfig).then(storedData=>{if(!(0,isArray/* default */.Z)(storedData)){(0,logger/* consentLogger */.OM)("no data stored");resolve(consentResponse);return;}// process user consent after loading it from storage
const[storedConsent,consentTimestamp,consentType]=storedData;if(!storedConsent){(0,logger/* consentLogger */.OM)("no data stored");resolve(consentResponse);return;}consent_processConsentFromStorage(storedConsent,consentTimestamp,consentType||null,widgetConfig).then(consent=>{// no consent, return null
if(!(0,isObject/* default */.Z)(consent)){(0,logger/* consentLogger */.OM)("loaded empty");resolve(consentResponse);return;}(0,logger/* consentLogger */.OM)("loaded",consent);// make sure consent is also saved in all first-party storage locations
consent_saveLocalConsent(consent,consentTimestamp,widgetConfig);resolve([consent,consentTimestamp]);return;},e=>{(0,logger/* consentLogger */.OM)("error",e);resolve(consentResponse);});},e=>{(0,report/* default */.Z)(e);(0,logger/* consentLogger */.OM)("error",e);resolve(consentResponse);});});};/* harmony default export */ const consent_loadUserConsent = (loadUserConsent);
// EXTERNAL MODULE: ./src/helpers/makeUrlQuery.ts
var makeUrlQuery = __webpack_require__(9806);
;// CONCATENATED MODULE: ./src/helpers/loadVisitorLocation.ts
const loadVisitorLocation=()=>{return (0,createPromise/* default */.Z)((resolve,reject)=>{const query=(0,makeUrlQuery/* default */.Z)({origin:window.location.hostname});(0,getJson/* default */.Z)(`${core_config/* REGION_CHECK_URL */.HB}?${query}`).then(_ref=>{let[res]=_ref;resolve([res.country||res.countryCode||primitives/* NULL */.QV,res.region||primitives/* NULL */.QV]);},e=>{(0,report/* default */.Z)(e);resolve([primitives/* NULL */.QV,primitives/* NULL */.QV]);});});};/* harmony default export */ const helpers_loadVisitorLocation = (loadVisitorLocation);
;// CONCATENATED MODULE: ./src/helpers/maybeLoadVisitorLocation.ts
const maybeLoadVisitorLocation=(widgetConfig,visitorCountry)=>{return (0,createPromise/* default */.Z)((resolve,reject)=>{if(!widgetConfig.increaseLocationPrecision){resolve([visitorCountry,primitives/* NULL */.QV]);return;}helpers_loadVisitorLocation().then(resolve,()=>resolve([visitorCountry,primitives/* NULL */.QV]));});};/* harmony default export */ const helpers_maybeLoadVisitorLocation = (maybeLoadVisitorLocation);
;// CONCATENATED MODULE: ./src/helpers/init/init.ts
const init=()=>{return (0,createPromise/* default */.Z)(resolve=>{const preloadSettings=init_getInitializationSettings();init_getIntegrationSettings(preloadSettings?preloadSettings.integration||{}:{});const{apiKey}=integrationSettings["default"];if(!(0,isString/* default */.Z)(apiKey)||!apiKey){throw new Error(errors/* MISSING_API_KEY */.Aw);}if(true){const autoblockUrls=[];if(preloadSettings&&(0,isArray/* default */.Z)(preloadSettings.autoblock)){preloadSettings.autoblock.forEach(item=>{autoblockUrls.push(...(item.urls||[]));});}const{getAutoblockInstance}=__webpack_require__(9356);const autoblock=getAutoblockInstance(autoblockUrls);// only initialize autobock when it's configured
if(preloadSettings&&preloadSettings.autoblock){autoblock.init();}}const visitorId=consent_loadLocalVisitorId();init_getConfigFilesVersion(preloadSettings).then(_ref=>{let[version,visitorCountry,gpcValue]=_ref;if(!version){throw new Error(errors/* PROBABLY_MISSING_API_KEY */.KL);}const preloadedConfig=preloadSettings?preloadSettings.widgetConfig||primitives/* NULL */.QV:primitives/* NULL */.QV;init_loadSiteConfig(version,preloadedConfig).then(widgetConfig=>{helpers_maybeLoadVisitorLocation(widgetConfig,visitorCountry).then(_ref2=>{let[visitorCountry,visitorRegion]=_ref2;const loadConsentsAndResolve=loadTCFUserConsent=>{// Array with promises, because if the tcf is enabled we need to wait for 2 promises
let loadConsentsArr;if(widgetConfig.tcfEnabled&&loadTCFUserConsent){loadConsentsArr=[consent_loadUserConsent(widgetConfig,visitorCountry,visitorRegion,gpcValue)];}else{loadConsentsArr=[consent_loadUserConsent(widgetConfig,visitorCountry,visitorRegion)];}if(widgetConfig.tcfEnabled){loadConsentsArr.push(loadTCFUserConsent(widgetConfig));}Promise.all(loadConsentsArr).then(_ref3=>{let[consentRes,tcfConsentRes]=_ref3;const[prevConsent,prevConsentTimestamp]=consentRes;let tcfPrevConsent=primitives/* NULL */.QV,tcfPrevConsentTimestamp=primitives/* NULL */.QV;if(tcfConsentRes){[tcfPrevConsent,tcfPrevConsentTimestamp]=tcfConsentRes;}resolve({preloadSettings,apiKey,widgetConfig,prevConsent,prevConsentTimestamp,visitorId,visitorCountry,visitorRegion,tcfPrevConsent,tcfPrevConsentTimestamp});});};// If tcf enabled, load tcf component to load tcf consent
if(widgetConfig.tcfEnabled){__webpack_require__.e(/* import() */ 749).then(__webpack_require__.bind(__webpack_require__, 8749)).then(result=>{const loadTCFUserConsent=result.loadTCFUserConsent;loadConsentsAndResolve(loadTCFUserConsent);});}else{loadConsentsAndResolve();}},report/* default */.Z);});});});};/* harmony default export */ const init_init = (init);
// EXTERNAL MODULE: ./src/core/AppStateContext.ts
var AppStateContext = __webpack_require__(9424);
// EXTERNAL MODULE: ./src/types/config-files/mainConfig.ts
var mainConfig = __webpack_require__(7086);
// EXTERNAL MODULE: ./node_modules/preact/hooks/dist/hooks.module.js
var hooks_module = __webpack_require__(6075);
// EXTERNAL MODULE: ./node_modules/preact/jsx-runtime/dist/jsxRuntime.module.js
var jsxRuntime_module = __webpack_require__(8089);
;// CONCATENATED MODULE: ./src/core/AppStateProvider/AppStateProvider.tsx
const AppStateProvider=_ref=>{let{config,children}=_ref;const{stealthMode}=integrationSettings["default"];const[activePanelTab,setActivePanelTab]=(0,hooks_module/* useState */.eJ)(primitives/* NULL */.QV);const[tcfVendorsList,setTcfVendorsList]=(0,hooks_module/* useState */.eJ)(config.widgetConfig.tcfVendors);const[activeConsentTab,setActiveConsentTab]=(0,hooks_module/* useState */.eJ)(primitives/* NULL */.QV);const[shouldBannerBeVisible,setShouldBannerBeVisible]=(0,hooks_module/* useState */.eJ)(primitives/* FALSE */.Dv);const[isTCFPublicEndpointInit,setIsTCFPublicEndpointInit]=(0,hooks_module/* useState */.eJ)(primitives/* FALSE */.Dv);const changePanelTab=function(){let newTab=arguments.length>0&&arguments[0]!==undefined?arguments[0]:mainConfig/* PANEL_SETTINGS_TAB */.bl;const availableTabs=config.widgetConfig.tabsOnSettingsPanel;if(newTab!==primitives/* NULL */.QV&&!(0,includes/* default */.Z)(availableTabs,newTab)){throw new Error(core_config/* LOGS_PREFIX */.f2+" New tab must be one of ["+availableTabs.join(", ")+"], passed: "+newTab);}setActivePanelTab(newTab);};const changeConsentTab=function(){let newTab=arguments.length>0&&arguments[0]!==undefined?arguments[0]:mainConfig/* ConsentTab */.Vl.CATEGORIES;const availableTabs=[mainConfig/* ConsentTab */.Vl.CATEGORIES,mainConfig/* ConsentTab */.Vl.VENDORS];if(newTab!==primitives/* NULL */.QV&&!(0,includes/* default */.Z)(availableTabs,newTab)){throw new Error(core_config/* LOGS_PREFIX */.f2+" New tab must be one of ["+availableTabs.join(", ")+"], passed: "+newTab);}setActiveConsentTab(newTab);};const appState=(0,hooks_module/* useMemo */.Ye)(()=>({...config,activePanelTab,changePanelTab,activeConsentTab,changeConsentTab,tcfVendorsList,setTcfVendorsList,shouldBannerBeVisible,setShouldBannerBeVisible,isTCFPublicEndpointInit,setIsTCFPublicEndpointInit}),// eslint-disable-next-line react-hooks/exhaustive-deps
[activePanelTab,changePanelTab,activeConsentTab,changeConsentTab]);const toggleSettingsPanel=(0,hooks_module/* useCallback */.I4)(shouldBeOpen=>{if(stealthMode){throw new Error(errors/* CANT_OPEN_PANEL_STEALTH_MODE */.Uz);}setActivePanelTab(shouldBeOpen?mainConfig/* PANEL_SETTINGS_TAB */.bl:primitives/* NULL */.QV);setActiveConsentTab(shouldBeOpen?mainConfig/* ConsentTab */.Vl.CATEGORIES:primitives/* NULL */.QV);},[stealthMode]);const[gvl,setGvl]=(0,hooks_module/* useState */.eJ)(primitives/* NULL */.QV);const[gatp,setGatp]=(0,hooks_module/* useState */.eJ)(primitives/* NULL */.QV);return (0,jsxRuntime_module/* jsx */.tZ)(AppStateContext/* APP_STATE_CONTEXT */.G.Provider,{value:{...appState,toggleSettingsPanel,isSettingsPanelOpen:!!activePanelTab,activePanelTab,changePanelTab,activeConsentTab,changeConsentTab,gvl,setGvl,gatp,setGatp,tcfVendorsList,setTcfVendorsList,isTCFPublicEndpointInit,setIsTCFPublicEndpointInit},children:children});};/* harmony default export */ const AppStateProvider_AppStateProvider = (AppStateProvider);
;// CONCATENATED MODULE: ./src/core/AppStateProvider/index.ts

;// CONCATENATED MODULE: ./src/helpers/createAsyncComponent.tsx
const EmptyComponent=props=>(0,jsxRuntime_module/* jsx */.tZ)(jsxRuntime_module/* Fragment */.HY,{});const createAsyncComponent=loader=>{const AsyncComponentLoader=props=>{const FinalComponentRef=(0,hooks_module/* useRef */.sO)(EmptyComponent);const[,setRenderId]=(0,hooks_module/* useState */.eJ)(primitives/* NULL */.QV);(0,hooks_module/* useEffect */.d4)(()=>{loader().then(resolved=>{FinalComponentRef.current=resolved.default||resolved;setRenderId((0,randomString/* default */.Z)());},e=>{throw e;});},[]);const FinalComponent=FinalComponentRef.current;return (0,jsxRuntime_module/* jsx */.tZ)(FinalComponent,{...props});};// @ts-ignore
// AsyncComponentLoader._forwarded = true;
return AsyncComponentLoader;};/* harmony default export */ const helpers_createAsyncComponent = (createAsyncComponent);
;// CONCATENATED MODULE: ./src/core/BannerUI/index.ts
/* harmony default export */ const BannerUI = (helpers_createAsyncComponent(()=>Promise.all(/* import() | ui */[__webpack_require__.e(207), __webpack_require__.e(441), __webpack_require__.e(522)]).then(__webpack_require__.bind(__webpack_require__, 3952))));
// EXTERNAL MODULE: ./src/hooks/useAppState.ts
var useAppState = __webpack_require__(8386);
// EXTERNAL MODULE: ./src/hooks/useShouldShowBanner.ts
var useShouldShowBanner = __webpack_require__(639);
// EXTERNAL MODULE: ./src/hooks/useUserConsent.ts
var useUserConsent = __webpack_require__(1322);
;// CONCATENATED MODULE: ./src/core/BannerUIManager/BannerUIManager.tsx
const BannerUIManager=()=>{const shouldShowBanner=(0,useShouldShowBanner/* default */.Z)();const{showWithdrawModal}=(0,useUserConsent/* default */.Z)();const{widgetConfig,activePanelTab,setShouldBannerBeVisible}=(0,useAppState/* default */.Z)();const{floatingBtn}=widgetConfig;const[shouldShowAnyUI,shouldBannerBeVisible]=(0,hooks_module/* useMemo */.Ye)(()=>{if(integrationSettings["default"].stealthMode){return[primitives/* FALSE */.Dv,primitives/* FALSE */.Dv];}const shouldBeVisible=!!(shouldShowBanner||showWithdrawModal||activePanelTab);setShouldBannerBeVisible(shouldBeVisible);return[shouldShowBanner||showWithdrawModal||activePanelTab||floatingBtn.isEnabled,shouldBeVisible];},[shouldShowBanner,activePanelTab,showWithdrawModal,floatingBtn.isEnabled,setShouldBannerBeVisible]);(0,hooks_module/* useEffect */.d4)(()=>{// Save to window information about visibility status of banner
dom/* _WINDOW_ */.X6.CF_visiblity=shouldBannerBeVisible;},[shouldBannerBeVisible]);if(shouldShowAnyUI){return (0,jsxRuntime_module/* jsx */.tZ)(BannerUI,{});}return primitives/* NULL */.QV;};/* harmony default export */ const BannerUIManager_BannerUIManager = (BannerUIManager);
;// CONCATENATED MODULE: ./src/core/BannerUIManager/index.tsx

// EXTERNAL MODULE: ./src/helpers/consent/isCategoryAccepted.ts
var isCategoryAccepted = __webpack_require__(2520);
;// CONCATENATED MODULE: ./src/helpers/getInlineElements.ts
const CAT_ATTRIBUTE=core_config/* CATEGORY_ATTR */.QO;function getInlineElements(tag,acceptedCategories){const nodes=Array.from(dom/* _DOCUMENT_ */.uI.querySelectorAll(`${tag}[${CAT_ATTRIBUTE}]`));return nodes.filter(node=>{const categories=(node.getAttribute(CAT_ATTRIBUTE)||"").split(",").map(c=>c.trim());// only keep node when can't find a not accepted category
return categories.every(cat=>(0,includes/* default */.Z)(acceptedCategories,cat));});}/* harmony default export */ const helpers_getInlineElements = (getInlineElements);
;// CONCATENATED MODULE: ./src/helpers/content-execution/loadInlineIframeForConsent.ts
const loadInlineIframes=acceptedCategories=>{const iframes=helpers_getInlineElements("iframe",acceptedCategories).filter(i=>!i.src);iframes.forEach(iframe=>{iframe.src=iframe.getAttribute("data-src")||"";iframe.removeAttribute("data-src");});};/* harmony default export */ const loadInlineIframeForConsent = (loadInlineIframes);
;// CONCATENATED MODULE: ./src/helpers/content-execution/constants.ts
const UNBLOCKED_SCRIPT_TYPES=["application/javascript","text/javascript"];
;// CONCATENATED MODULE: ./src/helpers/dom/replaceScriptTag.ts
const replaceScriptTag=script=>{const el=(0,createElement/* default */.Z)("script");Array.from(script.attributes).forEach(attr=>{if(attr.name==="data-src"){el.src=attr.value;}else{el.setAttribute(attr.name,attr.value);}});// assign those attributes after copying all the others
el.text=script.innerHTML;el.type=UNBLOCKED_SCRIPT_TYPES[0];try{script.parentNode.replaceChild(el,script);}catch(e){// catch any syntax errors from the new script and allow next scripts to be executed correctly
(0,logger/* coreLogger */.cl)(e);}};/* harmony default export */ const dom_replaceScriptTag = (replaceScriptTag);
;// CONCATENATED MODULE: ./src/helpers/content-execution/loadInlineScriptsForConsent.ts
const loadInlineScripts=acceptedCategories=>{const scripts=helpers_getInlineElements("script",acceptedCategories).filter(i=>i.type==="text/plain");scripts.forEach(dom_replaceScriptTag);};/* harmony default export */ const loadInlineScriptsForConsent = (loadInlineScripts);
// EXTERNAL MODULE: ./src/types/scriptIntegrationMethods.ts
var scriptIntegrationMethods = __webpack_require__(1873);
;// CONCATENATED MODULE: ./src/helpers/content-execution/executeCFLoadScript.ts
const SCRIPTS_CONTAINER_ID=`${core_config/* GENERIC_PREFIX */.o$}-scripts`;const SCRIPT_PREFIX=`${core_config/* GENERIC_PREFIX */.o$}-script-`;const executeCFLoadScript=script=>{// get container which will hold all scripts
let container=dom_getElementById(SCRIPTS_CONTAINER_ID);// create container if not exeists
if(!container){container=(0,createElement/* default */.Z)("div");container.id=SCRIPTS_CONTAINER_ID;dom/* _DOCUMENT_ */.uI.body.appendChild(container);}// make container invisible
container.style.display="none";const scriptContainerId=`${SCRIPT_PREFIX}${script.id}`;// script already loaded, don't execute it twice
if(container.querySelector("#"+scriptContainerId)){return;}// create a separate div for each script from admin
const scriptContainer=(0,createElement/* default */.Z)("div");scriptContainer.id=scriptContainerId;// add script's content as innerHTML of it's container
// adding a <script> tag as innerHTML doesn't make them executable
// but it allows us to accept any content added by clients in the admin panel
// for example multiple script tags for the same service
scriptContainer.innerHTML=script.content;container.appendChild(scriptContainer);// after the <script> tags are added to the DOM
// replace the nodes with their copies to execute them
const scriptTags=[...Array.from(scriptContainer.querySelectorAll("script"))];scriptTags.map(dom_replaceScriptTag);};/* harmony default export */ const content_execution_executeCFLoadScript = (executeCFLoadScript);
;// CONCATENATED MODULE: ./src/helpers/content-execution/executeEditedInlineScript.ts
const executeEditedInlineScript=script=>{const scriptTags=Array.from(dom/* _DOCUMENT_ */.uI.querySelectorAll(`[${core_config/* DATA_ATTRIBUTES_PREFIX */.xC}-script="${script.consent_key}"]`));if(!scriptTags.length){return;}for(let i=0;i<scriptTags.length;i++){const tag=scriptTags[i];// script attribute added to a non-script element
if(!(tag instanceof HTMLScriptElement)){continue;}// script has src and a correct type, it must have been already loaded
if(tag.src&&((0,includes/* default */.Z)(UNBLOCKED_SCRIPT_TYPES,tag.type)||!tag.type)){continue;}dom_replaceScriptTag(tag);}};/* harmony default export */ const content_execution_executeEditedInlineScript = (executeEditedInlineScript);
// EXTERNAL MODULE: ./src/helpers/isFunction.ts
var isFunction = __webpack_require__(8987);
;// CONCATENATED MODULE: ./src/helpers/content-execution/loadSiteScriptsForConsent.ts
const dummyExecuteScript=script=>{};const SCRIPT_EXECUTION_METHODS={[scriptIntegrationMethods/* SCRIPT_INTEGRATION_METHOD_BANNER_LOAD */.yj]:content_execution_executeCFLoadScript,[scriptIntegrationMethods/* SCRIPT_INTEGRATION_METHOD_EDIT_CURRENT */.QE]:content_execution_executeEditedInlineScript,[scriptIntegrationMethods/* SCRIPT_INTEGRATION_METHOD_AUTOBLOCK */["if"]]:dummyExecuteScript,[scriptIntegrationMethods/* SCRIPT_INTEGRATION_METHOD_GTM_LOAD */.I$]:dummyExecuteScript,[scriptIntegrationMethods/* SCRIPT_INTEGRATION_METHOD_MANUAL */.Ko]:dummyExecuteScript};if(true){const executeAutoblockedScript=(__webpack_require__(7299)/* ["default"] */ .Z);SCRIPT_EXECUTION_METHODS[scriptIntegrationMethods/* SCRIPT_INTEGRATION_METHOD_AUTOBLOCK */["if"]]=executeAutoblockedScript;}const loadSiteScriptsForConsent=(consent,widgetConfig)=>{try{const scripts=widgetConfig.scripts;for(const script of scripts){// omit scripts without consent_key or id
if(widgetConfig.isGranularPolicy&&!script.consent_key||!script.id){continue;}const isAccepted=(0,isServiceAccepted/* default */.Z)(script,consent,widgetConfig.consentPolicy);if(!isAccepted){// omit scripts which categories arren't accepted
continue;}const executeFn=SCRIPT_EXECUTION_METHODS[script.integration]||dummyExecuteScript;if((0,isFunction/* default */.Z)(executeFn)){executeFn(script);}}}catch(e){(0,logger/* consentLogger */.OM)(e);}};/* harmony default export */ const content_execution_loadSiteScriptsForConsent = (loadSiteScriptsForConsent);
;// CONCATENATED MODULE: ./src/helpers/content-execution/loadContentForConsent.ts
const loadContentForConsent=(userConsent,widgetConfig,preloadSettings)=>{try{content_execution_loadSiteScriptsForConsent(userConsent,widgetConfig);const acceptedCategories=constants_categories/* categories */.bd.filter(cat=>{return (0,isCategoryAccepted/* default */.Z)(cat,userConsent,widgetConfig.consentPolicy,widgetConfig.scripts);});if(true){const{getAutoblockInstance}=__webpack_require__(5982);const autoblock=getAutoblockInstance();if(preloadSettings&&!widgetConfig.isGranularPolicy){const unblockableScripts=[];preloadSettings.autoblock.filter(item=>{const shouldUnblock=item.consent_keys.every(cat=>!!userConsent[cat]);return shouldUnblock;}).forEach(item=>unblockableScripts.push(...item.urls));if(unblockableScripts.length>0){autoblock.unblock(unblockableScripts);}}}loadInlineScriptsForConsent(acceptedCategories);loadInlineIframeForConsent(acceptedCategories);}catch(e){// don't crash if remote scripts don't load, try to load inline content anyway
(0,report/* default */.Z)(e);}};/* harmony default export */ const content_execution_loadContentForConsent = (loadContentForConsent);
;// CONCATENATED MODULE: ./src/hooks/useUrl.ts
const useUrl=()=>{const[url,setUrl]=(0,hooks_module/* useState */.eJ)(dom/* _WINDOW_ */.X6.location.pathname);(0,hooks_module/* useEffect */.d4)(()=>{const epagesEventTraget=dom/* _WINDOW_ */.X6.eComEventTarget;if(!epagesEventTraget){return;}const handler=event=>{const newUrl=event.detail.url;if(newUrl!==url){setUrl(newUrl);}};// on mount setup an a listener for epages page navigation
(0,addEventListener/* default */.Z)(epagesEventTraget,"pageview",handler);// return function which will be called on unmount to clear the interval
return()=>(0,removeEventListener/* default */.Z)(epagesEventTraget,"pageview",handler);// need to pass url as dependency so tht the interval callback has access to updated url after change
},[url]);// return the current url to the hook consumer
return url;};/* harmony default export */ const hooks_useUrl = (useUrl);
// EXTERNAL MODULE: ./src/helpers/dispatchRenderEmbedsEvent.ts
var dispatchRenderEmbedsEvent = __webpack_require__(3825);
;// CONCATENATED MODULE: ./src/core/ContentLoader/ContentLoader.tsx
const ContentLoader=()=>{const url=hooks_useUrl();// load content for consent when website url changes
const{hasConsented,userConsent,preConsent}=(0,useUserConsent/* default */.Z)();const{widgetConfig,preloadSettings}=(0,useAppState/* default */.Z)();// load scripts after user consented
(0,hooks_module/* useEffect */.d4)(()=>{const executeContent=()=>{return content_execution_loadContentForConsent(hasConsented?userConsent:preConsent,widgetConfig,preloadSettings);};// execute content when consent changes
executeContent();// listen for embed render event and execute content then
(0,addEventListener/* default */.Z)(dom/* _WINDOW_ */.X6,dispatchRenderEmbedsEvent/* EVENT_NAME */.W,executeContent);// return function which will remove event listener before next re-render
// or when component unmounts
return()=>(0,removeEventListener/* default */.Z)(dom/* _WINDOW_ */.X6,dispatchRenderEmbedsEvent/* EVENT_NAME */.W,executeContent);},[hasConsented,userConsent,preConsent,widgetConfig,url,preloadSettings]);// load content loader css on first render
(0,hooks_module/* useEffect */.d4)(()=>{__webpack_require__.e(/* import() */ 560).then(__webpack_require__.bind(__webpack_require__, 8560));},[]);return primitives/* NULL */.QV;};/* harmony default export */ const ContentLoader_ContentLoader = (ContentLoader);
;// CONCATENATED MODULE: ./src/core/ContentLoader/index.ts

// EXTERNAL MODULE: ./src/core/PublicApi/CookieFirstPublicApi.ts
var CookieFirstPublicApi = __webpack_require__(6996);
// EXTERNAL MODULE: ./src/helpers/dispatchAppInitializedEvent.ts
var dispatchAppInitializedEvent = __webpack_require__(3392);
// EXTERNAL MODULE: ./src/helpers/fetchSiteCookies.ts
var fetchSiteCookies = __webpack_require__(7657);
// EXTERNAL MODULE: ./src/hooks/useTranslation.ts
var useTranslation = __webpack_require__(3011);
;// CONCATENATED MODULE: ./src/core/PublicApi/PublicApi.tsx
const PublicApi=()=>{const{stealthMode}=integrationSettings["default"];const{changePanelTab,widgetConfig}=(0,useAppState/* default */.Z)();const consent=(0,useUserConsent/* default */.Z)();const[isInitialized,setIsInitialized]=(0,hooks_module/* useState */.eJ)(false);const{userLang,setUserLang}=(0,useTranslation/* default */.Z)();(0,hooks_module/* useEffect */.d4)(()=>{dom/* _WINDOW_ */.X6[core_config/* JS_API_OBJECT_NAME */.W$]=(0,CookieFirstPublicApi/* createCookieFirstPublicApiInstance */.p)({setPanelTab:changePanelTab,consent,widgetConfig,stealthMode,fetchLatestScan:()=>(0,fetchSiteCookies/* default */.Z)(userLang,widgetConfig.version),setUserLang});if(!isInitialized){setIsInitialized(true);(0,dispatchAppInitializedEvent/* default */.Z)();}if(true){dom/* _WINDOW_ */.X6.cookiefirst_show_settings=dom/* _WINDOW_ */.X6[core_config/* JS_API_OBJECT_NAME */.W$].openPanel;}},[isInitialized,changePanelTab,consent,userLang,stealthMode,widgetConfig,setUserLang]);return primitives/* NULL */.QV;};/* harmony default export */ const PublicApi_PublicApi = (PublicApi);
;// CONCATENATED MODULE: ./src/core/PublicApi/index.ts

// EXTERNAL MODULE: ./src/core/TranslationsContext.ts
var TranslationsContext = __webpack_require__(3672);
;// CONCATENATED MODULE: ./src/helpers/init/detectAppLanguage.ts
// handle some langs using the same translations for different dialects
const LANG_CODES_MAP={nb:"no",nn:"no"};const cleanLangString=function(){let rawLang=arguments.length>0&&arguments[0]!==undefined?arguments[0]:"";let lang=rawLang||"";if((0,includes/* default */.Z)(lang,"-")){lang=lang.split("-")[0];}else if((0,includes/* default */.Z)(lang,"_")){lang=lang.split("_")[0];}if(lang.length!==2){return"";}return LANG_CODES_MAP[lang]||lang;};const detectAppLanguage=function(){let whitelist=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];let forcedLang=arguments.length>1&&arguments[1]!==undefined?arguments[1]:primitives/* NULL */.QV;let respectSavedLang=arguments.length>2?arguments[2]:undefined;if(!whitelist.length){return primitives/* NULL */.QV;}const isOnWhitelist=lang=>{return (0,includes/* default */.Z)(whitelist,lang);};const searchLang=new URL(dom/* _WINDOW_ */.X6.location.href).searchParams.get(core_config/* LANGUAGE_COOKIE */.Ep);// detect language forced by query string
if(searchLang){const ql=cleanLangString(searchLang);if(isOnWhitelist(ql)){return ql;}}if(respectSavedLang){// detect language saved in the local storage
const localStorageKey=`${core_config/* GENERIC_PREFIX */.o$}-user-lang`;const localUserLang=(0,getLocalStorageItem/* default */.Z)(localStorageKey,primitives/* NULL */.QV);if(localUserLang&&isOnWhitelist(localUserLang)){return localUserLang;}}// detect language forced by website
if(forcedLang){if(forcedLang==="inherit"){// website forced inheritance of it's own language
const htmlLang=cleanLangString(dom/* _DOCUMENT_ */.uI.documentElement.lang||"");if(isOnWhitelist(htmlLang)){return htmlLang;}}const parsedForced=cleanLangString(forcedLang);if(isOnWhitelist(parsedForced)){// website forced a language code
return parsedForced;}}// detect lang from browser preferences
const nav=navigator;let found=[];if(nav.languages){// chrome only: needs conversion to array
found.push(...Array.from(nav.languages));}found.push(nav.userLanguage||nav.language);found=found.filter(i=>(0,isString/* default */.Z)(i)).map(i=>i.toLowerCase());for(let i=0;i<found.length;i++){const lang=cleanLangString(found[i]);if(isOnWhitelist(lang)){return lang;}}return whitelist[0];};/* harmony default export */ const init_detectAppLanguage = (detectAppLanguage);
// EXTERNAL MODULE: ./src/helpers/getTextDirection.ts
var getTextDirection = __webpack_require__(5491);
;// CONCATENATED MODULE: ./src/helpers/init/loadTranslations.ts
const ERROR_PREFIX="Failed to load translatios";const loadTextsFile=(dir,lang,version)=>{const url=(0,getStaticFileUrl/* default */.Z)(`${dir}/lang-widget-${lang}.json`,version);(0,logger/* coreLogger */.cl)("load translation file for "+lang+" from "+url);return (0,createPromise/* default */.Z)((resolve,reject)=>{(0,getJson/* default */.Z)(url).then(_ref=>{let[res]=_ref;(0,logger/* coreLogger */.cl)("init lang: "+lang);resolve(res);},e=>{(0,logger/* coreLogger */.cl)(new Error(ERROR_PREFIX+"("+lang+")"));reject(e);});});};const loadTranslations=(baseUrl,langs,userLang,version)=>{return (0,createPromise/* default */.Z)(resolve=>{loadTextsFile(baseUrl,userLang||"",version||(0,randomString/* default */.Z)()).then(texts=>resolve(texts||{}),e=>{(0,report/* default */.Z)(e);// try to load fallback lang
loadTextsFile(baseUrl,langs[0],version||(0,randomString/* default */.Z)()).then(texts=>resolve(texts||{}),e=>{(0,logger/* coreLogger */.cl)(ERROR_PREFIX);(0,report/* default */.Z)(e);resolve({});});});});};/* harmony default export */ const init_loadTranslations = (loadTranslations);
// EXTERNAL MODULE: ./src/helpers/getByPath.ts
var getByPath = __webpack_require__(4948);
;// CONCATENATED MODULE: ./src/core/TranslationsProvider/TranslationsProvider.tsx
const TranslationsProvider=_ref=>{let{children=primitives/* NULL */.QV}=_ref;const{dir,forcedLang}=integrationSettings["default"];const{widgetConfig}=(0,useAppState/* default */.Z)();const[isInitialized,setIsInitialized]=(0,hooks_module/* useState */.eJ)(primitives/* FALSE */.Dv);const[texts,setTexts]=(0,hooks_module/* useState */.eJ)({});const availableLocales=(0,hooks_module/* useMemo */.Ye)(()=>widgetConfig.languages.map(item=>item.value),[widgetConfig.languages]);const[userLang,setUserLangState]=(0,hooks_module/* useState */.eJ)(init_detectAppLanguage(availableLocales,forcedLang,widgetConfig.showLanguageSwitcher)||availableLocales[0]);const setUserLang=lang=>{if(!(0,includes/* default */.Z)(availableLocales,lang)){throw new Error("New language must be one of the configured locales for this domain: "+availableLocales.join(", "));}setUserLangState(lang);(0,saveLocalStorageItem/* default */.Z)(core_config/* LANGUAGE_COOKIE */.Ep,lang);};(0,hooks_module/* useEffect */.d4)(()=>{init_loadTranslations(dir||"",widgetConfig.languages.map(item=>item.value),userLang,widgetConfig.version).then(texts=>{setTexts(texts||{});// mark app as initialized to render the components
setIsInitialized(primitives/* TRUE */.uX);});// disable eslint error about missinge dependency in useEffect
// we make the dependencies array empty on purpose
// to only execute effect once on component mount
// and when lang changes
// eslint-disable-next-line react-hooks/exhaustive-deps
},[userLang]);const textDirection=(0,hooks_module/* useMemo */.Ye)(()=>(0,getTextDirection/* default */.ZP)(userLang),[userLang]);// don't render anything until app has loaded
if(!isInitialized){return primitives/* NULL */.QV;}/**
   *
   * @param {string} key  translation key
   * @param {genericObject} replacements replacements for variables inside the translation text
   * @param {string} fallback default value in case translation is not found
   */const translate=function(key){let replacements=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};let fallback=arguments.length>2?arguments[2]:undefined;const placeholder=(0,isString/* default */.Z)(fallback)?fallback:"";const replacementsKeys=(0,objectKeys/* default */.Z)(replacements);const txt=(0,getByPath/* default */.Z)(texts,key)||placeholder;if(!(0,includes/* default */.Z)(txt,"{{")||!replacementsKeys.length){return txt;}let final=txt;for(let i=replacementsKeys.length-1;i>=0;i--){const key=replacementsKeys[i];const value=replacements[key];final=final.replace(`{{${key}}}`,value);}return final;};return (0,jsxRuntime_module/* jsx */.tZ)(TranslationsContext/* default */.Z.Provider,{value:{userLang,t:translate,setUserLang,textDirection},children:children});};/* harmony default export */ const TranslationsProvider_TranslationsProvider = (TranslationsProvider);
;// CONCATENATED MODULE: ./src/core/TranslationsProvider/index.ts

// EXTERNAL MODULE: ./src/core/UserConsentContext.ts
var UserConsentContext = __webpack_require__(9475);
;// CONCATENATED MODULE: ./src/helpers/consent/calculateGranularMetadata.ts
const calculateGranularMetadata=widgetConfig=>{const granularMetadata=widgetConfig.scripts.reduce((aggregate,script)=>{aggregate[script.consent_key]={unique_service_uuid:script.unique_service_uuid,name:script.name,categories:script.categories};return aggregate;},{});return granularMetadata;};/* harmony default export */ const consent_calculateGranularMetadata = (calculateGranularMetadata);
;// CONCATENATED MODULE: ./src/helpers/consent/isConsentEqual.ts
/**
 * Check if consentA is equal to consentB
 */const isConsentEqual=function(){let consentA=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};let consentB=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};let widgetConfig=arguments.length>2?arguments[2]:undefined;const keysToCheck=[];if(widgetConfig.isGranularPolicy){keysToCheck.push(...widgetConfig.scripts.map(s=>s.consent_key));}else{keysToCheck.push(...constants_categories/* categories */.bd);}for(let i=0;i<keysToCheck.length;i++){const key=keysToCheck[i];if(consentB[key]&&!consentA[key]||consentA[key]&&!consentB[key]){return false;}}return true;};/* harmony default export */ const consent_isConsentEqual = (isConsentEqual);
;// CONCATENATED MODULE: ./src/helpers/consent/isConsentStricter.ts
/**
 * Check if consentA is stricter than consentB, useful
 * when user changes their consent and we want to check if
 * any of the previously accepted categories/scripts has been rejected
 *
 */const isConsentStricter=(consentA,consentB,widgetConfig)=>{if(widgetConfig.isGranularPolicy){for(const script of widgetConfig.scripts){const key=script.consent_key;// if script was accepted in B and isn't in A, A is stricter
if(consentB[key]&&!consentA[key]){return true;}}}else{for(let i=0;i<constants_categories/* categories */.bd.length;i++){const cat=constants_categories/* categories */.bd[i];// if category was accepted in B and isn't in A, A is stricter
if(consentB[cat]&&!consentA[cat]){return true;}}}return false;};/* harmony default export */ const consent_isConsentStricter = (isConsentStricter);
;// CONCATENATED MODULE: ./src/helpers/consent/saveLocalVisitorId.ts
const saveLocalVisitorId=function(){let visitorId=arguments.length>0&&arguments[0]!==undefined?arguments[0]:"";(0,saveLocalStorageItem/* default */.Z)(core_config/* VISITOR_ID_COOKIE */.MZ,visitorId);};/* harmony default export */ const consent_saveLocalVisitorId = (saveLocalVisitorId);
// EXTERNAL MODULE: ./src/helpers/dispatchConsentEvent.ts
var dispatchConsentEvent = __webpack_require__(5383);
// EXTERNAL MODULE: ./src/helpers/dispatchJSEvent.ts
var dispatchJSEvent = __webpack_require__(7179);
;// CONCATENATED MODULE: ./src/helpers/dispatchUserConsentedEvent.ts
const EVENT_NAME=`${core_config/* EVENTS_PREFIX */.OH}_consent_action`;const dispatchUserConsentedEvent=()=>{const jsEventData=primitives/* NULL */.QV;(0,dispatchJSEvent/* default */.Z)(EVENT_NAME,jsEventData);};/* harmony default export */ const helpers_dispatchUserConsentedEvent = (dispatchUserConsentedEvent);
// EXTERNAL MODULE: ./src/helpers/dispatchConsentLoadedEvent.ts + 1 modules
var dispatchConsentLoadedEvent = __webpack_require__(3116);
// EXTERNAL MODULE: ./src/helpers/logUserConsent.ts + 1 modules
var logUserConsent = __webpack_require__(5726);
// EXTERNAL MODULE: ./src/helpers/tcf/tcfHelpers/loadLocalTCFConsent.ts
var loadLocalTCFConsent = __webpack_require__(6667);
// EXTERNAL MODULE: ./src/helpers/tcf/TCFdeleteLocalTCString.ts
var TCFdeleteLocalTCString = __webpack_require__(9680);
;// CONCATENATED MODULE: ./src/helpers/consent/shouldForceReconsent.ts
const shouldForceReconsent=function(){let consent=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};let consentTimestamp=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;let widgetConfig=arguments.length>2&&arguments[2]!==undefined?arguments[2]:(0,WidgetConfig/* createWidgetConfig */.B)();// Check if saved consent was with tcf enabled and if so, force reconsent and remove old tcf consent
const tcfConsent=(0,loadLocalTCFConsent/* default */.Z)(widgetConfig);if(tcfConsent&&!widgetConfig.tcfEnabled){// If so, remove the tcf consent and force reconsent
(0,TCFdeleteLocalTCString/* default */.Z)(widgetConfig.bulkConsent);(0,deleteLocalConsent/* default */.Z)();return primitives/* TRUE */.uX;}if(!(0,isObject/* default */.Z)(consent)||typeof consentTimestamp!=="number"||!(0,isObject/* default */.Z)(widgetConfig)){return primitives/* FALSE */.Dv;}const reconsent=widgetConfig.reconsent;const reconsentAfter=reconsent.after;// number of days after which consent should be checked
const reconsentCheck=reconsent.check;// if we should check for all configured categories to be accepted or just any of them
const categories=reconsent.categories.filter(i=>(0,includes/* default */.Z)(constants_categories/* categories */.bd,i));// categories to check for acceptance
// no re-consent timeline specified, feature disabled
if(!reconsentAfter||typeof reconsentAfter!=="number"){return primitives/* FALSE */.Dv;}// no categories specified to check, so no need to force re-consent
if(!categories.length){return primitives/* FALSE */.Dv;}const now=(0,getTimestamp/* default */.Z)();const isOldEnough=now-consentTimestamp>=reconsentAfter*time/* DAY_IN_SECONDS */.i;// consent not old enough according to criteria setup by client
if(!isOldEnough){return primitives/* FALSE */.Dv;}const categoriesMeetGoal=()=>{const isAccepted=cat=>{return (0,isCategoryAccepted/* default */.Z)(cat,consent,widgetConfig.consentPolicy,widgetConfig.scripts);};if(reconsentCheck==="ALL"){return categories.every(isAccepted);}else{return categories.some(isAccepted);}};return!categoriesMeetGoal();};/* harmony default export */ const consent_shouldForceReconsent = (shouldForceReconsent);
;// CONCATENATED MODULE: ./src/core/UserConsentProvider/types.ts
const CONSENT_STATE_ACTION_TOGGLE_CATEGORY=0;const CONSENT_STATE_ACTION_TOGGLE_SERVICE=1;const CONSENT_STATE_ACTION_SET_VISITOR_ID=2;const CONSENT_STATE_ACTION_START_CONSENT_SAVE=3;const CONSENT_STATE_ACTION_CONSENT_SAVE_FINISHED=4;const CONSENT_STATE_ACTION_START_WITHDRAW=5;const CONSENT_STATE_ACTION_TOGGLE_WITHDRAW_MODAL=6;const CONSENT_STATE_ACTION_ACCEPT_ALL=7;const CONSENT_STATE_ACTION_FORCE_RECONSENT=8;// Basic action type
// Individual action types
;// CONCATENATED MODULE: ./src/core/UserConsentProvider/consentStateReducer.ts
const createConsentStateReducer=widgetConfig=>{const{isGranularPolicy,scripts}=widgetConfig;return(state,action)=>{switch(action.type){case CONSENT_STATE_ACTION_TOGGLE_SERVICE:{const{script,shouldBeAccepted}=action.payload;const{consent_key}=script;if(// can't toggle script when not in granular mode
!isGranularPolicy||// can't toggle script which doesn't have a consent_key
!consent_key||// can't toggle script which has necessary category
(0,includes/* default */.Z)(script.categories,constants_categories/* NECESSARY */.a3)){return state;}(0,logger/* consentLogger */.OM)("Toggle script",consent_key);return{...state,tempConsent:{...state.tempConsent,[consent_key]:shouldBeAccepted}};}case CONSENT_STATE_ACTION_TOGGLE_CATEGORY:{const{category,shouldBeAccepted}=action.payload;(0,logger/* consentLogger */.OM)("Toggle category",category,shouldBeAccepted);if(category===constants_categories/* NECESSARY */.a3){// can't change acceptance state of the main category
return state;}if(isGranularPolicy){const requestedScripts=scripts.filter(script=>{return (0,includes/* default */.Z)(script.categories,category)&&!(0,includes/* default */.Z)(script.categories,constants_categories/* NECESSARY */.a3)// can't change necessary, it's always accepted
;});return{...state,tempConsent:requestedScripts.reduce((aggregate,script)=>({...aggregate,[script.consent_key]:!!shouldBeAccepted}),state.tempConsent)};}else{return{...state,tempConsent:{...state.tempConsent,[category]:!!shouldBeAccepted}};}}case CONSENT_STATE_ACTION_START_CONSENT_SAVE:{return{...state,isSavingConsent:primitives/* TRUE */.uX};}case CONSENT_STATE_ACTION_CONSENT_SAVE_FINISHED:{const{consent,timestamp}=action.payload;return{...state,consentTimestamp:timestamp,tempConsent:consent,userConsent:consent,hasConsented:primitives/* TRUE */.uX,isForcingReconsent:primitives/* FALSE */.Dv,isSavingConsent:primitives/* FALSE */.Dv};}case CONSENT_STATE_ACTION_SET_VISITOR_ID:{return{...state,visitorId:action.payload};}case CONSENT_STATE_ACTION_START_WITHDRAW:{return{...state,isWithdrawing:true};}case CONSENT_STATE_ACTION_TOGGLE_WITHDRAW_MODAL:{return{...state,showWithdrawModal:action.payload};}case CONSENT_STATE_ACTION_FORCE_RECONSENT:{return{...state,isForcingReconsent:action.payload};}default:return state;}};};/**
 * Calculate accepted categories or scripts object
 * according to pre-selected categories.
 *
 * Use CATEGORY_OPTIN policy for calculations because the object
 * with pre-selected categories has the category structure
 *
 * @param widgetConfig
 * @param source
 * @returns
 */const calculateBaseConsent=(widgetConfig,source)=>{const baseConsent={};if(widgetConfig.isGranularPolicy){widgetConfig.scripts.forEach(script=>{baseConsent[script.consent_key]=(0,isServiceAccepted/* default */.Z)(script,{...source},// the source object has the category optin structure
types_consent/* CONSENT_POLICY_CATEGORY_OPTIN */.hs);});}else{constants_categories/* categories */.bd.forEach(cat=>{baseConsent[cat]=(0,isCategoryAccepted/* default */.Z)(cat,{...source},// the source object has the category optin structure
types_consent/* CONSENT_POLICY_CATEGORY_OPTIN */.hs);});}return Object.freeze(baseConsent);};const calculateInitialState=input=>{const{prevConsent,prevConsentTimestamp,visitorId,widgetConfig}=input;const state={consentTimestamp:null,userConsent:{},baseConsent:{},preConsent:{},tempConsent:{},hasConsented:primitives/* FALSE */.Dv,isSavingConsent:primitives/* FALSE */.Dv,isWithdrawing:primitives/* FALSE */.Dv,showWithdrawModal:primitives/* FALSE */.Dv,isForcingReconsent:primitives/* FALSE */.Dv,visitorId:null};// base consent - pre-selected services/categories
state.baseConsent=calculateBaseConsent(widgetConfig,widgetConfig.baseConsent);// pre consent - pre-executed services/categories
state.preConsent=calculateBaseConsent(widgetConfig,widgetConfig.preConsent);if(!prevConsent){state.tempConsent={...state.baseConsent};return state;}state.userConsent={...prevConsent};state.tempConsent={...prevConsent};state.visitorId=visitorId||primitives/* NULL */.QV;state.consentTimestamp=prevConsentTimestamp||primitives/* NULL */.QV;state.hasConsented=primitives/* TRUE */.uX;if(prevConsentTimestamp&&consent_shouldForceReconsent(prevConsent,prevConsentTimestamp,widgetConfig)){(0,logger/* consentLogger */.OM)("forcing reconsent");state.isForcingReconsent=primitives/* TRUE */.uX;}return state;};
;// CONCATENATED MODULE: ./src/helpers/dispatchAcceptAllEvent.ts
const dispatchAcceptAllEvent_EVENT_NAME=`${core_config/* EVENTS_PREFIX */.OH}_consent_accept_all`;const dispatchAcceptAllEvent=()=>{const jsEventData=primitives/* NULL */.QV;(0,dispatchJSEvent/* default */.Z)(dispatchAcceptAllEvent_EVENT_NAME,jsEventData);};/* harmony default export */ const helpers_dispatchAcceptAllEvent = (dispatchAcceptAllEvent);
;// CONCATENATED MODULE: ./src/helpers/tcf/tcfHelpers/dispatchLogConsentoApiWithTCFEvent.ts
const dispatchLogConsentoApiWithTCFEvent_EVENT_NAME=`${core_config/* EVENTS_PREFIX */.OH}_tcf_log_consent_to_api`;const dispatchLogConsentoApiWithTCFEvent=payload=>{const jsEventData={...payload};(0,dispatchJSEvent/* default */.Z)(dispatchLogConsentoApiWithTCFEvent_EVENT_NAME,jsEventData);};/* harmony default export */ const tcfHelpers_dispatchLogConsentoApiWithTCFEvent = (dispatchLogConsentoApiWithTCFEvent);
;// CONCATENATED MODULE: ./src/helpers/dispatchUserDeniedEvent.ts
const dispatchUserDeniedEvent_EVENT_NAME=`${core_config/* EVENTS_PREFIX */.OH}_denied_action`;const dispatchUserDeniedEvent=()=>{const jsEventData=primitives/* NULL */.QV;(0,dispatchJSEvent/* default */.Z)(dispatchUserDeniedEvent_EVENT_NAME,jsEventData);};/* harmony default export */ const helpers_dispatchUserDeniedEvent = (dispatchUserDeniedEvent);
;// CONCATENATED MODULE: ./src/helpers/consent/saveWithdrawCookie.ts
/**
 * Saves consent in localstorage and first-party cookie
 *
 */const saveWithdrawCookie=widgetConfig=>{const lifetime=widgetConfig.consentLifetime||time/* YEAR_IN_SECONDS */.z;const cookieExpiry=(0,getTimestamp/* default */.Z)()+lifetime;(0,saveLocalCookie/* default */.Z)(core_config/* CONSENT_COOKIE */.Q8,core_config/* WITHDRAW_COOKIE */.fx,cookieExpiry,widgetConfig.bulkConsent);};/* harmony default export */ const consent_saveWithdrawCookie = (saveWithdrawCookie);
;// CONCATENATED MODULE: ./src/core/UserConsentProvider/useManageConsentState.ts
const reloadWindow=()=>dom/* _WINDOW_ */.X6.location.reload();const useManageConsentState=input=>{const{widgetConfig,visitorCountry,visitorRegion}=(0,useAppState/* default */.Z)();const bulkConfig=widgetConfig.bulkConsent;const scripts=widgetConfig.scripts;const useGranularConsent=widgetConfig.isGranularPolicy;const[state,dispatch]=(0,hooks_module/* useReducer */._Y)(createConsentStateReducer(widgetConfig),calculateInitialState({...input,widgetConfig}));// on init send consent loaded event
(0,hooks_module/* useEffect */.d4)(()=>{const hasConsented=state.hasConsented;(0,dispatchConsentLoadedEvent/* default */.ZP)(hasConsented?state.userConsent:state.preConsent,hasConsented,widgetConfig);},[]);// eslint-disable-line react-hooks/exhaustive-deps
const dispatchAction=(type,payload)=>{dispatch({type,payload});};const setVisitorId=visitorId=>{dispatchAction(CONSENT_STATE_ACTION_SET_VISITOR_ID,visitorId);consent_saveLocalVisitorId(visitorId);};const setIsForcingReconsent=isForcingReconsent=>{dispatchAction(CONSENT_STATE_ACTION_FORCE_RECONSENT,isForcingReconsent);};const logConsentToApi=function(){let action=arguments.length>0&&arguments[0]!==undefined?arguments[0]:types_consent/* CONSENT_ACTION_STORE */.mX;let consent=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};let granularMetadata=arguments.length>2&&arguments[2]!==undefined?arguments[2]:primitives/* NULL */.QV;return (0,createPromise/* default */.Z)(resolve=>{(0,logUserConsent/* default */.Z)(consent,action,state.visitorId,widgetConfig.version,visitorCountry,visitorRegion,widgetConfig.consentPolicy,granularMetadata).then(newVisitorId=>{if(newVisitorId){setVisitorId(newVisitorId);}},report/* default */.Z).finally(resolve);});};const saveAndLogConsent=(consent,action,timestamp,widgetConfig)=>{return (0,createPromise/* default */.Z)((resolve,reject)=>{if(action===types_consent/* CONSENT_ACTION_WITHDRAW */.qD){(0,deleteLocalConsent/* default */.Z)(widgetConfig.bulkConsent);if(widgetConfig.bulkConsent.id){consent_saveWithdrawCookie(widgetConfig);}}else{// save local consent in storage
consent_saveLocalConsent(consent,timestamp,widgetConfig);}// execute a few async actions at once
const promises=[];if(bulkConfig.id){// save bulk consent
promises.push(consent_saveBulkConsent(bulkConfig,{action,consent,timestamp,type:widgetConfig.consentType}));}// save consent in DB
const granularMetadata=consent_calculateGranularMetadata(widgetConfig);// It TCF is enabled, dispatch event to move saving consent in DB to the TCF consent state, in order to connect those two.
if(widgetConfig.tcfEnabled){tcfHelpers_dispatchLogConsentoApiWithTCFEvent({consent,userAction:action,visitorId:state.visitorId,configVersion:widgetConfig.version,visitorCountry,visitorRegion,consentPolicy:widgetConfig.consentPolicy,granularMetadata});}else{promises.push(logConsentToApi(action,consent,granularMetadata));}Promise.all(promises).then(()=>resolve(),reject);});};// perform actions after user consents to some services
const handleConsent=newConsent=>{return (0,createPromise/* default */.Z)(resolve=>{// Dispatch event that 'consent' has been required
helpers_dispatchUserConsentedEvent();// copy the consent object to avoid modifying passed object
const consent={...newConsent};// Update tempConsent with passedNewConsent to prevent differences between requested consent to save and tempConsent
state.tempConsent={...newConsent};// a flag for later use
const hasPreviouslyConsented=state.hasConsented;const isConsentEqualToPrevious=consent_isConsentEqual(consent,state.userConsent,widgetConfig);const action=hasPreviouslyConsented?types_consent/* CONSENT_ACTION_UPDATE */.gl:types_consent/* CONSENT_ACTION_STORE */.mX;// don't perform any action if consent is the same as before
// and we aren't forcing re-consent
if(hasPreviouslyConsented&&isConsentEqualToPrevious&&!state.isForcingReconsent){(0,logger/* consentLogger */.OM)("Skip consent log, same consent");// If tcf is enabled, even tho consent is the same as before trigger event to let tcf know that user consented in order to possibly save because tcf consent might have changed
if(widgetConfig.tcfEnabled){const granularMetadata=consent_calculateGranularMetadata(widgetConfig);tcfHelpers_dispatchLogConsentoApiWithTCFEvent({consent,userAction:action,visitorId:state.visitorId,configVersion:widgetConfig.version,visitorCountry,visitorRegion,consentPolicy:widgetConfig.consentPolicy,granularMetadata,hasNormalConsentChanged:primitives/* FALSE */.Dv});}return resolve();}(0,logger/* consentLogger */.OM)("Save consent",consent);const isStricter=consent_isConsentStricter(consent,hasPreviouslyConsented?state.userConsent:state.preConsent,widgetConfig);dispatchAction(CONSENT_STATE_ACTION_START_CONSENT_SAVE,primitives/* NULL */.QV);const timestamp=(0,getTimestamp/* default */.Z)();saveAndLogConsent(consent,action,timestamp,widgetConfig).catch(report/* default */.Z).finally(()=>{dispatchAction(CONSENT_STATE_ACTION_CONSENT_SAVE_FINISHED,{consent,timestamp});// refresh the page if there was previous consent and new consent is different
// or if consent is stricter than the previously executed consent
if(isStricter||hasPreviouslyConsented&&!isConsentEqualToPrevious){reloadWindow();return;}// and dispatch consent event
(0,dispatchConsentEvent/* default */.ZP)(consent,primitives/* TRUE */.uX,widgetConfig);// finally resolve the promise
return resolve();});});};const handleWithdraw=()=>{return (0,createPromise/* default */.Z)(resolve=>{// can't withdraw if hasn't consented yet
if(!state.hasConsented){return resolve();}dispatchAction(CONSENT_STATE_ACTION_START_WITHDRAW,primitives/* NULL */.QV);// Remove TCString from local storage and cookie
(0,TCFdeleteLocalTCString/* default */.Z)(widgetConfig.bulkConsent);saveAndLogConsent({},types_consent/* CONSENT_ACTION_WITHDRAW */.qD,(0,getTimestamp/* default */.Z)(),widgetConfig).catch(report/* default */.Z).finally(reloadWindow);});};const acceptAll=()=>{// Dispatch event that 'acceptAll' has been used
helpers_dispatchAcceptAllEvent();if(useGranularConsent){// accept all configured scripts
const requestedServices=scripts.map(s=>s.consent_key);return acceptServices(requestedServices);}else{// accept all configured categories
return acceptCategories(widgetConfig.cookieCategories);}};const acceptServices=requestedServices=>{const requestedScripts=scripts.filter(script=>{return (0,includes/* default */.Z)(script.categories,constants_categories/* NECESSARY */.a3)||(0,includes/* default */.Z)(requestedServices,script.consent_key);});if(useGranularConsent){const newConsent=requestedScripts.reduce((obj,script)=>({...obj,[script.consent_key]:primitives/* TRUE */.uX}),{...state.userConsent});return handleConsent(newConsent);}else{const requestedCategories=requestedScripts.reduce((aggregate,script)=>{for(let i=0;i<script.categories.length;i++){const cat=script.categories[i];if(!(0,includes/* default */.Z)(aggregate,cat)){aggregate.push(cat);}}return aggregate;},[constants_categories/* NECESSARY */.a3]);return acceptCategories(requestedCategories);}};const declineServices=requestedServices=>{const requestedScripts=scripts.filter(script=>(0,includes/* default */.Z)(requestedServices,script.consent_key));if(useGranularConsent){const newConsent=requestedScripts.reduce((obj,script)=>({...obj,[script.consent_key]:primitives/* FALSE */.Dv}),{...state.userConsent});return handleConsent(newConsent);}else{const requestedCategories=requestedScripts.reduce((aggregate,script)=>{for(let i=0;i<script.categories.length;i++){const cat=script.categories[i];if(!(0,includes/* default */.Z)(aggregate,cat)){aggregate.push(cat);}}return aggregate;},[]);return declineCategories(requestedCategories);}};const acceptCategories=requestedCats=>{if(useGranularConsent){const requestedScripts=scripts.filter(script=>{for(let i=0;i<requestedCats.length;i++){if((0,includes/* default */.Z)(script.categories,requestedCats[i])||(0,includes/* default */.Z)(script.categories,constants_categories/* NECESSARY */.a3)){return primitives/* TRUE */.uX;}}return primitives/* FALSE */.Dv;}).map(s=>s.consent_key);return acceptServices(requestedScripts);}else{const newConsent=requestedCats.reduce((aggregate,category)=>({...aggregate,[category]:primitives/* TRUE */.uX}),{...state.userConsent});return handleConsent(newConsent);}};const declineCategories=requestedCats=>{if(useGranularConsent){const requestedServices=scripts.filter(script=>{for(let i=0;i<requestedCats.length;i++){if((0,includes/* default */.Z)(script.categories,requestedCats[i])&&!(0,includes/* default */.Z)(script.categories,constants_categories/* NECESSARY */.a3)){return primitives/* TRUE */.uX;}}return primitives/* FALSE */.Dv;}).map(s=>s.consent_key);return declineServices(requestedServices);}else{const newConsent=requestedCats.reduce((aggregate,category)=>({...aggregate,[category]:primitives/* FALSE */.Dv}),{...state.userConsent});return handleConsent(newConsent);}};const acceptDefault=()=>handleConsent(state.baseConsent);const acceptSelected=()=>handleConsent(state.tempConsent);const deny=()=>{const deniedConsent=useGranularConsent?constants_categories/* EMPTY_CONSENT */.qc:constants_categories/* EMPTY_CATEGORY_CONSENT */.Li;// Dispatch event that user has denied
helpers_dispatchUserDeniedEvent();return handleConsent(deniedConsent);};const isScriptToggleEnabled=script=>{return (0,isServiceAccepted/* default */.Z)(script,state.tempConsent,widgetConfig.consentPolicy);};const isCategoryToggleEnabled=category=>{return (0,isCategoryAccepted/* default */.Z)(category,state.tempConsent,widgetConfig.consentPolicy,scripts);};const toggleScript=script=>{dispatchAction(CONSENT_STATE_ACTION_TOGGLE_SERVICE,{script,shouldBeAccepted:!isScriptToggleEnabled(script)});};const toggleCategory=category=>{dispatchAction(CONSENT_STATE_ACTION_TOGGLE_CATEGORY,{category,shouldBeAccepted:!isCategoryToggleEnabled(category)});};const toggleWithdrawModal=show=>{dispatchAction(CONSENT_STATE_ACTION_TOGGLE_WITHDRAW_MODAL,show);};return[{...state,// Consent saving functions
handleConsent,handleWithdraw,acceptAll,acceptCategories,declineCategories,acceptServices,declineServices,acceptDefault,acceptSelected,deny,// functions modifying temp state
toggleScript,toggleCategory,setVisitorId,setIsForcingReconsent,toggleWithdrawModal,// consent querying functions
isScriptAccepted:isScriptToggleEnabled,isCategoryAccepted:isCategoryToggleEnabled}];};/* harmony default export */ const UserConsentProvider_useManageConsentState = (useManageConsentState);
;// CONCATENATED MODULE: ./src/core/UserConsentProvider/UserConsentProvider.tsx
const UserConsentProvider=_ref=>{let{children=primitives/* NULL */.QV,prevConsent=primitives/* NULL */.QV,prevConsentTimestamp=primitives/* NULL */.QV,visitorId}=_ref;const[ctx]=UserConsentProvider_useManageConsentState({prevConsent,prevConsentTimestamp,visitorId});return (0,jsxRuntime_module/* jsx */.tZ)(UserConsentContext/* default */.Z.Provider,{value:ctx,children:children});};/* harmony default export */ const UserConsentProvider_UserConsentProvider = (UserConsentProvider);
;// CONCATENATED MODULE: ./src/core/UserConsentProvider/index.ts

;// CONCATENATED MODULE: ./src/helpers/getEmbedContainer.ts
const NODE_TYPE_TEXT=3;// https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType
/**
 *
 * @param {string} containerId - id of element in which embed should be placed
 * @param {string} shortcode - shortcode to find on page and place embed instead of
 *
 * @returns {(HTMLElement|null)} container - DOM element or null if not found
 */const getEmbedContainer=function(){let containerId=arguments.length>0&&arguments[0]!==undefined?arguments[0]:"";let shortcode=arguments.length>1&&arguments[1]!==undefined?arguments[1]:"";if(!containerId||!shortcode){return primitives/* NULL */.QV;}// find cookie declaration container by ID
const container=dom_getElementById(containerId);if(container){return container;}// find elements with shortcode as part of their content
const elements=dom/* _DOCUMENT_ */.uI.body.querySelectorAll("*");for(let i=0;i<elements.length;i++){const element=elements[i];const innerHTML=element.innerHTML;if(!element||!element.hasChildNodes()||!(0,isString/* default */.Z)(innerHTML)){continue;}// bail early if no shortcode as a child
if(!(0,includes/* default */.Z)(innerHTML,shortcode)){continue;}// scan child elements to look for shortcode
for(let j=0;j<element.childNodes.length;j++){const node=element.childNodes[j];const parent=node.parentNode;const nodeValue=node.nodeValue;if(node.nodeType!==NODE_TYPE_TEXT||!nodeValue||!parent){continue;}if(!(0,includes/* default */.Z)(nodeValue,shortcode)){continue;}// replace shortcode with the container div
parent.innerHTML=parent.innerHTML.replace(shortcode,`<div id="${containerId}"></div>`);// after replacing, find the new container by id
return getEmbedContainer(containerId,shortcode);}}return primitives/* NULL */.QV;};/* harmony default export */ const helpers_getEmbedContainer = (getEmbedContainer);
;// CONCATENATED MODULE: ./src/hooks/useEmbedContainer.ts
const useEmbedContainer=function(){let containerId=arguments.length>0&&arguments[0]!==undefined?arguments[0]:"";let shortcode=arguments.length>1&&arguments[1]!==undefined?arguments[1]:"";const url=hooks_useUrl();const[renderId,setRenderId]=(0,hooks_module/* useState */.eJ)((0,randomString/* default */.Z)());(0,hooks_module/* useEffect */.d4)(()=>{const handler=()=>setRenderId((0,randomString/* default */.Z)());// on mount setup an a listener for embeds render request event
(0,addEventListener/* default */.Z)(dom/* _WINDOW_ */.X6,dispatchRenderEmbedsEvent/* EVENT_NAME */.W,handler);// return function which will be called on unmount to clear the event listener
return()=>(0,removeEventListener/* default */.Z)(dom/* _WINDOW_ */.X6,dispatchRenderEmbedsEvent/* EVENT_NAME */.W,handler);},[]);// search for embed container on each url change
// and each renderId change
// this is made to support single page applications
const container=(0,hooks_module/* useMemo */.Ye)(()=>{return helpers_getEmbedContainer(containerId,shortcode);},[containerId,shortcode,url,renderId]);// eslint-disable-line react-hooks/exhaustive-deps
return container;};/* harmony default export */ const hooks_useEmbedContainer = (useEmbedContainer);
;// CONCATENATED MODULE: ./src/core/EmbedsManager/EmbedsManager.tsx
const CookiesAndPolicyEmbeds=helpers_createAsyncComponent(()=>Promise.all(/* import() | embeds */[__webpack_require__.e(207), __webpack_require__.e(441), __webpack_require__.e(735)]).then(__webpack_require__.bind(__webpack_require__, 2723)));const POLICY_CONTAINER_ID=`${core_config/* EMBED_ELEMENTS_PREFIX */.Bs}-policy-page`;const POLICY_SHORTCODE=`[${core_config/* GENERIC_PREFIX */.o$}_declaration]`;const POLICY_WITH_LIST_CONTAINER_ID=`${core_config/* EMBED_ELEMENTS_PREFIX */.Bs}-policy-cookie-list`;const POLICY_WITH_LIST_SHORTCODE=`[${core_config/* GENERIC_PREFIX */.o$}_policy_cookie_list]`;const COOKIES_TABLE_CONTAINER_ID=`${core_config/* EMBED_ELEMENTS_PREFIX */.Bs}-cookies-table`;const COOKIES_TABLE_SHORTCODE=`[${core_config/* GENERIC_PREFIX */.o$}_cookies_table]`;const COOKIES_LIST_CONTAINER_ID=`${core_config/* EMBED_ELEMENTS_PREFIX */.Bs}-cookies-list`;const COOKIES_LIST_SHORTCODE=`[${core_config/* GENERIC_PREFIX */.o$}_cookies_list]`;const EmbedsManager=()=>{const containers=[hooks_useEmbedContainer(POLICY_CONTAINER_ID,POLICY_SHORTCODE),hooks_useEmbedContainer(POLICY_WITH_LIST_CONTAINER_ID,POLICY_WITH_LIST_SHORTCODE),hooks_useEmbedContainer(COOKIES_TABLE_CONTAINER_ID,COOKIES_TABLE_SHORTCODE),hooks_useEmbedContainer(COOKIES_LIST_CONTAINER_ID,COOKIES_LIST_SHORTCODE)];// only fetch and render the embeds component when any embed is detected
if(containers.filter(Boolean).length===0){return primitives/* NULL */.QV;}return (0,jsxRuntime_module/* jsx */.tZ)(CookiesAndPolicyEmbeds,{containers:containers});};/* harmony default export */ const EmbedsManager_EmbedsManager = (EmbedsManager);
;// CONCATENATED MODULE: ./src/core/EmbedsManager/index.ts

// EXTERNAL MODULE: ./src/hooks/useTCFDynamicImport.ts
var useTCFDynamicImport = __webpack_require__(9908);
;// CONCATENATED MODULE: ./src/components/ConditionalWrapper/ConditionalWrapper.tsx
const ConditionalWrapper=_ref=>{let{condition,wrapper,children}=_ref;return condition?wrapper(children):children;};/* harmony default export */ const ConditionalWrapper_ConditionalWrapper = (ConditionalWrapper);
;// CONCATENATED MODULE: ./src/core/App/App.tsx
const CookieFirstApp=_ref=>{let{settings}=_ref;const{apiKey}=integrationSettings["default"];const{prevConsent,visitorId,prevConsentTimestamp,...config}=settings;if(!settings||!apiKey){throw new Error(errors/* MISSING_API_KEY */.Aw);}const widgetConfig=config.widgetConfig;const{TCFApi,TCFUserConsentProvider,PublicApiTCF}=(0,useTCFDynamicImport/* default */.Z)(widgetConfig);return (0,jsxRuntime_module/* jsx */.tZ)(AppStateProvider_AppStateProvider,{config:config,children:(0,jsxRuntime_module/* jsx */.tZ)(TranslationsProvider_TranslationsProvider,{children:(0,jsxRuntime_module/* jsx */.tZ)(UserConsentProvider_UserConsentProvider,{prevConsentTimestamp:prevConsentTimestamp,prevConsent:prevConsent,visitorId:visitorId,...config,children:(0,jsxRuntime_module/* jsx */.tZ)(ConditionalWrapper_ConditionalWrapper,{condition:widgetConfig.tcfEnabled,wrapper:children=>(0,jsxRuntime_module/* jsx */.tZ)(TCFUserConsentProvider,{vendorsList:widgetConfig.tcfVendors,gatpList:widgetConfig.acVendors,tcfCountry:widgetConfig.tcfCountry,prevConsent:config.tcfPrevConsent,prevConsentTimestamp:config.tcfPrevConsentTimestamp,widgetConfig:widgetConfig,children:children}),children:(0,jsxRuntime_module/* jsxs */.BX)(jsxRuntime_module/* Fragment */.HY,{children:[TCFApi&&widgetConfig.tcfEnabled?(0,jsxRuntime_module/* jsx */.tZ)(TCFApi,{}):(0,jsxRuntime_module/* jsx */.tZ)(jsxRuntime_module/* Fragment */.HY,{}),(0,jsxRuntime_module/* jsx */.tZ)(BannerUIManager_BannerUIManager,{}),(0,jsxRuntime_module/* jsx */.tZ)(EmbedsManager_EmbedsManager,{}),widgetConfig.tcfEnabled?PublicApiTCF&&(0,jsxRuntime_module/* jsx */.tZ)(PublicApiTCF,{}):(0,jsxRuntime_module/* jsx */.tZ)(PublicApi_PublicApi,{}),(0,jsxRuntime_module/* jsx */.tZ)(ContentLoader_ContentLoader,{})]})})})})});};/* harmony default export */ const App = (CookieFirstApp);
;// CONCATENATED MODULE: ./src/core/App/index.ts

// EXTERNAL MODULE: ./node_modules/preact/dist/preact.module.js
var preact_module = __webpack_require__(3987);
;// CONCATENATED MODULE: ./src/helpers/init/app.tsx
const app=settings=>{const body=dom/* _DOCUMENT_ */.uI.body;// handle the case of script added to <head> - wait for body to become available
if(!body){setTimeout(()=>app(settings),1);return;}(0,preact_module/* render */.sY)((0,jsxRuntime_module/* jsx */.tZ)(App,{settings:settings}),body);};/* harmony default export */ const init_app = (app);
;// CONCATENATED MODULE: ./src/index.ts
const INIT_TIME_CONST_KEY='__COOKIE_BANNER_INIT_TIME__';const main=()=>{// guard against multiple instances of banner
if(window[INIT_TIME_CONST_KEY]&&"production"==="production"){return;}window[INIT_TIME_CONST_KEY]=Date.now();(0,logger/* coreLogger */.cl)("start");init_init().then(settings=>{init_app(settings);});};main();if(false){}
})();

/******/ })()
;